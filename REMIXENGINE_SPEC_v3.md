# ğŸ¬ REMIXENGINE â€” YouTube Content Remixer
## Full Production Specification for Claude Code (GSD + UUPM)

> **Project Codename**: RemixEngine
> **Spec Version**: 3.0 â€” Dual-Mode (Standalone + Module)
> **Date**: February 26, 2026
> **Stack**: Next.js 14+ (App Router) Â· Supabase Â· FFmpeg + Remotion Â· HeyGen Â· 11Labs Â· Gemini Â· fal.ai Â· Runway ML/Kling Â· yt-dlp
> **Deployment**: Standalone â†’ Railway | Module â†’ Parent dashboard import
> **Design**: UI UX Pro Max (generated at build time) Â· Dark mode SaaS dashboard default
> **Dev Framework**: GSD (Get Shit Done) â€” spec-driven, fresh context per phase
> **Architecture**: Dual-mode â€” works as standalone app AND embeddable module

---

## TABLE OF CONTENTS

0. [Dual-Mode Architecture & Module Boundary](#0-dual-mode-architecture--module-boundary)
1. [Project Overview](#1-project-overview)
2. [Architecture Overview](#2-architecture-overview)
3. [Agent Team Structure](#3-agent-team-structure-for-claude-code)
4. [Tech Stack & Dependencies](#4-tech-stack--dependencies)
5. [Database Schema (Supabase)](#5-database-schema-supabase)
6. [Zod Validation Schemas](#6-zod-validation-schemas)
7. [API Routes & Backend](#7-api-routes--backend)
8. [Pipeline Architecture](#8-pipeline-architecture)
9. [Frontend Specification](#9-frontend-specification)
10. [Authentication & Roles](#10-authentication--roles)
11. [File Storage Strategy](#11-file-storage-strategy)
12. [Environment Variables](#12-environment-variables)
13. [Build Phases](#13-build-phases)
14. [API Integration Specs](#14-api-integration-specs)
15. [Cost Estimation Engine](#15-cost-estimation-engine)
16. [Error Handling & Resilience](#16-error-handling--resilience)
17. [Logging & Observability](#17-logging--observability)
18. [Deployment Configuration](#18-deployment-configuration)
19. [Known Constraints & Workarounds](#19-known-constraints--workarounds)

---

## 0. DUAL-MODE ARCHITECTURE & MODULE BOUNDARY

### The Core Pattern

RemixEngine is built as a standalone app that is **always module-ready**. A single codebase serves both modes:

| Concern | Standalone Mode | Module Mode |
|---|---|---|
| **Auth** | Own Supabase Auth (login, signup, sessions) | Parent provides `{ user, role }` |
| **Layout** | Own sidebar, header, theme provider | Parent provides shell â€” RemixEngine renders page content only |
| **Routing** | `/projects`, `/admin`, `/batch` | Parent mounts under its own prefix (e.g., `/dashboard/remix/*`) |
| **Config** | Reads from `process.env` | Injected via `<RemixEngineProvider config={...}>` |
| **Database** | Own Supabase instance | Shared Supabase â€” tables prefixed `re_`, no collisions |
| **Storage** | Own bucket at `remix-engine/*` | Shared bucket â€” paths prefixed `remix-engine/*` |
| **API Routes** | `/api/remix-engine/*` | Same â€” prefix configurable |
| **Design tokens** | Generated by UUPM, set as CSS variables | Parent's CSS variables override |

### RemixEngineProvider (The Boundary Layer)

```typescript
// src/lib/remix-engine/provider.tsx
interface RemixEngineConfig {
  mode: 'standalone' | 'module';
  routePrefix: string;              // default: '/remix-engine'
  supabase: {
    url: string;
    anonKey: string;
    serviceRoleKey: string;
  };
  redis: {
    url: string;
  };
  apiKeys: {
    youtube: string;
    gemini: string;
    falAi: string;
    elevenLabs: string;
    heyGen: string;
    runwayMl: string;
    kling?: string;
  };
  auth?: {                          // Module mode: parent provides user
    user: { id: string; email: string; full_name?: string };
    role: 'admin' | 'editor' | 'viewer';
  };
  webhookBaseUrl: string;
  storagePrefix: string;            // default: 'remix-engine'
  tablePrefix: string;              // default: 're_'
}

// Standalone mode auto-creates config from env vars:
function createStandaloneConfig(): RemixEngineConfig {
  return {
    mode: 'standalone',
    routePrefix: '/remix-engine',
    supabase: {
      url: process.env.NEXT_PUBLIC_SUPABASE_URL!,
      anonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      serviceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY!,
    },
    redis: { url: process.env.REDIS_URL! },
    apiKeys: {
      youtube: process.env.YOUTUBE_DATA_API_KEY!,
      gemini: process.env.GOOGLE_GEMINI_API_KEY!,
      falAi: process.env.FAL_KEY!,
      elevenLabs: process.env.ELEVENLABS_API_KEY!,
      heyGen: process.env.HEYGEN_API_KEY!,
      runwayMl: process.env.RUNWAY_API_KEY!,
      kling: process.env.KLING_API_KEY,
    },
    webhookBaseUrl: process.env.WEBHOOK_BASE_URL || process.env.NEXT_PUBLIC_APP_URL!,
    storagePrefix: 'remix-engine',
    tablePrefix: 're_',
  };
}

// React context for client-side:
const RemixEngineContext = createContext<RemixEngineConfig | null>(null);
export const useRemixEngine = () => useContext(RemixEngineContext)!;

// Server-side singleton:
let _serverConfig: RemixEngineConfig | null = null;
export function getServerConfig(): RemixEngineConfig {
  if (!_serverConfig) _serverConfig = createStandaloneConfig();
  return _serverConfig;
}
export function setServerConfig(config: RemixEngineConfig) {
  _serverConfig = config;
}
```

### Rules for All Code

1. **Never import directly from `process.env` in business logic.** Use `useRemixEngine()` on client, `getServerConfig()` on server.
2. **Never hardcode table names.** Use `${config.tablePrefix}videos` or helper: `table('videos')` â†’ `re_videos`.
3. **Never hardcode storage paths.** Use `${config.storagePrefix}/videos/...`.
4. **Never hardcode route paths in links.** Use `${config.routePrefix}/projects/${id}`.
5. **Layout components check `config.mode`.** Sidebar, Header, auth pages only render when `mode === 'standalone'`.
6. **CSS uses variables only.** No hardcoded hex colors anywhere in components.

### Standalone Shell (Conditional)

```typescript
// src/app/(dashboard)/layout.tsx
export default function DashboardLayout({ children }) {
  const config = useRemixEngine();
  
  if (config.mode === 'module') {
    // Module mode: parent provides layout. Just render children.
    return <>{children}</>;
  }
  
  // Standalone mode: render our own shell.
  return (
    <div className="flex h-screen">
      <Sidebar />
      <div className="flex-1 flex flex-col">
        <Header />
        <main className="flex-1 overflow-auto p-6">{children}</main>
      </div>
    </div>
  );
}
```

### Spec Export Endpoint

```typescript
// src/app/api/remix-engine/spec.json/route.ts
// Returns the full module contract as JSON â€” any AI or parent app can read this
export async function GET() {
  return Response.json({
    name: 'remix-engine',
    version: '1.0.0',
    description: 'YouTube content remixing pipeline module',
    config_schema: { /* RemixEngineConfig as JSON Schema */ },
    database: {
      table_prefix: 're_',
      tables: ['re_users', 're_projects', 're_batch_jobs', 're_videos', 're_remixed_titles',
               're_remixed_thumbnails', 're_remixed_scripts', 're_scenes', 're_rendered_videos',
               're_jobs', 're_api_usage', 're_system_settings'],
      requires_realtime: ['re_jobs', 're_videos', 're_projects', 're_batch_jobs', 're_scenes'],
    },
    storage: {
      prefix: 'remix-engine',
      paths: ['videos/', 'thumbnails/', 'audio/', 'avatars/', 'broll/', 'rendered/'],
      requires_pro: true, // For files >50MB
    },
    api_routes: {
      prefix: '/api/remix-engine',
      routes: [
        'POST /scrape', 'POST /scrape/batch', 'GET /scrape/status/[jobId]',
        'POST /remix/title', 'POST /remix/thumbnail', 'POST /remix/script',
        'POST /audio/generate', 'GET /audio/voices', 'POST /audio/preview',
        'POST /avatar/generate', 'GET /avatar/avatars', 'GET /avatar/status/[jobId]', 'POST /avatar/cancel',
        'POST /broll/generate', 'GET /broll/status/[jobId]', 'POST /broll/cancel',
        'POST /render', 'GET /render/status/[jobId]', 'POST /render/cancel',
        'POST /webhooks/heygen', 'POST /webhooks/runway',
        'GET /projects', 'POST /projects', 'GET /projects/[id]', 'PATCH /projects/[id]', 'DELETE /projects/[id]',
        'GET /admin/users', 'POST /admin/users/invite', 'PATCH /admin/users/[id]', 'DELETE /admin/users/[id]',
        'GET /admin/usage', 'GET /admin/settings', 'PUT /admin/settings',
        'GET /health', 'GET /spec.json',
      ],
    },
    external_services: {
      required: ['supabase', 'redis', 'youtube_data_api', 'gemini', 'fal_ai', 'elevenlabs', 'heygen', 'runway_ml'],
      optional: ['kling'],
    },
    worker: {
      requires: ['redis', 'ffmpeg', 'yt-dlp', 'chromium'],
      queues: ['scrape', 'remix', 'generate', 'render'],
    },
  });
}
```

---

## 1. PROJECT OVERVIEW

### What This App Does

RemixEngine is an internal tool that scrapes YouTube videos, remixes their content (titles, thumbnails, transcripts/scripts), generates new AI avatar voiceover videos with AI-generated B-roll, and assembles final rendered videos â€” all from a single dark-mode dashboard.

**Standalone mode**: Full app, own domain, own auth. Build, test, demo.
**Module mode**: Same pipeline, embedded in parent dashboard. Auth/layout/routing from parent.

### Core Pipeline Flow

```
INPUT: YouTube URL or Channel URL (batch 5-10 videos)
  â”‚
  â”œâ”€â†’ SCRAPE: Download MP4, title, thumbnail, transcript (yt-dlp + YouTube Data API)
  â”‚
  â”œâ”€â†’ REMIX TITLE: Generate 5-10 title variations (Gemini API)
  â”œâ”€â†’ REMIX THUMBNAIL: Generate new thumbnails (fal.ai / Nano Banana Pro)
  â”œâ”€â†’ REMIX SCRIPT: Rewrite transcript into new script (Gemini API)
  â”‚
  â”œâ”€â†’ VOICEOVER: Convert remixed script to audio (11Labs API)
  â”œâ”€â†’ AVATAR VIDEO: Generate talking-head video from script (HeyGen API)
  â”œâ”€â†’ B-ROLL: Generate AI video clips for scene descriptions (Runway ML / Kling API)
  â”‚
  â””â”€â†’ ASSEMBLE: Combine avatar + B-roll + audio into final video (FFmpeg + Remotion)

OUTPUT: Downloadable remixed video + all intermediate assets
```

### Users & Permissions

Multi-user system with three roles:
- **Admin**: Full access. Manage users, configure API keys, run all pipeline stages, delete projects.
- **Editor**: Create projects, run pipelines, edit/approve remixed content. Cannot manage users or API keys.
- **Viewer**: Read-only access to projects and assets. Can download final outputs.

---

## 2. ARCHITECTURE OVERVIEW

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    RAILWAY PROJECT                            â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  SERVICE 1: WEB (Next.js App Router)                â”‚     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚
â”‚  â”‚  â”‚ Frontend  â”‚  â”‚ API Routes â”‚  â”‚ Webhook Routesâ”‚  â”‚     â”‚
â”‚  â”‚  â”‚(React/TW) â”‚  â”‚  /api/...  â”‚  â”‚/api/remix-engine/webhooks/â”‚  â”‚     â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                           â”‚                â”‚                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  SERVICE 2: WORKER (Standalone Node.js process)     â”‚     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚     â”‚
â”‚  â”‚  â”‚Scrapeâ”‚ â”‚Remix â”‚ â”‚Voice â”‚ â”‚Avatarâ”‚ â”‚Assembleâ”‚   â”‚     â”‚
â”‚  â”‚  â”‚Workerâ”‚ â”‚Workerâ”‚ â”‚Workerâ”‚ â”‚Workerâ”‚ â”‚ Worker â”‚   â”‚     â”‚
â”‚  â”‚  â””â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚        â”‚        â”‚        â”‚        â”‚          â”‚               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  SERVICE 3: REDIS (Railway Addon)                   â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              SUPABASE (External)               â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚  â”‚ Postgres  â”‚  â”‚  Auth    â”‚  â”‚   Storage   â”‚  â”‚
    â”‚  â”‚ Database  â”‚  â”‚  (JWT)   â”‚  â”‚  (Buckets)  â”‚  â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Architecture Decisions

1. **Job Queue**: BullMQ with Railway Redis addon. Video processing takes minutes â€” this CANNOT be synchronous. The web service enqueues jobs; the worker service dequeues and processes them. They communicate through Redis.
2. **File Storage**: Supabase Storage for all assets. **CRITICAL**: Supabase free tier limits files to 50MB. Video files (MP4s) routinely exceed this. Options: (a) Use Supabase Pro ($25/mo, 5GB file limit), (b) compress videos aggressively before upload, or (c) store videos locally on Railway's ephemeral disk and serve via API route with Range header support. **Recommendation for MVP**: Supabase Pro tier for storage, OR limit scraped videos to â‰¤15 minutes and compress to 720p (~100MB max).
3. **Realtime Updates**: Supabase Realtime subscriptions for live job progress. To minimize RLS overhead on Realtime, the `jobs` table uses a simplified RLS policy (all authenticated users can read all jobs) rather than subquery-based policies.
4. **Server-Side Heavy Lifting**: All API calls to external services happen server-side. Never expose API keys to the client.
5. **Chromium for Remotion**: Remotion renders video by running React in headless Chrome. The Railway worker container MUST include Chromium. This is handled via the Dockerfile (see Section 18).

---

## 3. AGENT TEAM STRUCTURE (FOR CLAUDE CODE)

### Orchestrator Agent

**Role**: Project conductor. Starts with the defined playbook below but has authority to reassign, split, parallelize, or reallocate work dynamically based on load, quality gates, dependency resolution, and efficiency.

**Playbook (Default Execution Order)**:

```
Phase 1 (Parallel): Database Agent + Auth Agent + Frontend Agent (scaffold)
Phase 2 (Sequential): Scraping Agent (depends on DB schema)
Phase 3 (Parallel): Title Remix Agent + Thumbnail Remix Agent + Script Remix Agent
Phase 4 (Parallel): Voiceover Agent + Avatar Agent + B-Roll Agent
Phase 5 (Sequential): Video Assembly Agent (depends on Phase 4 outputs)
Phase 6 (Sequential): Frontend Agent (polish + integration)
```

**Orchestrator Rules**:
- Quality gates: Each agent must produce working, tested code before the next phase begins.
- If an agent is blocked (e.g., waiting on API response patterns), the orchestrator reassigns it to help another agent.
- The orchestrator monitors for circular dependencies and resolves them.
- If parallel agents share a resource (e.g., both writing to the same config file), the orchestrator sequences those writes.
- **File ownership is strict**: If two agents need to modify the same file, the orchestrator designates one as primary and the other submits changes through the primary. See conflict resolution table below.

### Agent File Ownership Conflict Resolution

| Conflicting Files | Primary Owner | Secondary Agent | Resolution |
|---|---|---|---|
| `src/app/(auth)/**` | `auth-admin-specialist` | `frontend-specialist` | Auth agent builds login/signup pages. Frontend agent provides design tokens/components only. |
| `src/middleware.ts` | `auth-admin-specialist` | `supabase-specialist` | Auth agent owns middleware. Supabase agent provides client creation utility imported by middleware. |
| `src/lib/supabase/types.ts` | `supabase-specialist` | All other agents | Supabase agent generates types. Other agents import, never modify. |
| `src/components/ui/**` | `frontend-specialist` | All other agents | Frontend agent installs shadcn components. Other agents use them, never modify. |
| `package.json` | Orchestrator | All agents | Orchestrator sequences dependency additions to prevent merge conflicts. |

---

### Sub-Agent Definitions

Each agent below is a Claude Code sub-agent with specific files it owns, tools it uses, and acceptance criteria.

---

#### Agent 1: `data-scraping-specialist`

**Responsibilities**: YouTube video downloading and metadata extraction.

**Owns these files**:
```
src/lib/scraper/
â”œâ”€â”€ youtube-dl.ts          # yt-dlp wrapper for video download
â”œâ”€â”€ metadata.ts            # YouTube Data API v3 for title, description, tags, channel info
â”œâ”€â”€ transcript.ts          # Transcript extraction via yt-dlp subtitles (NOT YouTube Captions API â€” that requires OAuth)
â”œâ”€â”€ thumbnail.ts           # Thumbnail download (multiple resolutions)
â”œâ”€â”€ batch.ts               # Batch processing for 5-10 videos from a channel
â”œâ”€â”€ vtt-parser.ts          # Parse .vtt subtitle files to plain text
â””â”€â”€ types.ts               # TypeScript interfaces for scraped data
src/app/api/remix-engine/scrape/
â”œâ”€â”€ route.ts               # POST /api/remix-engine/scrape â€” trigger scrape job
â”œâ”€â”€ status/[jobId]/route.ts # GET /api/remix-engine/scrape/status/:jobId
â””â”€â”€ batch/route.ts         # POST /api/remix-engine/scrape/batch â€” batch channel scrape
```

**Implementation Details**:
- Use `yt-dlp` via child_process exec. Wrap in a typed Node.js service with timeout (max 5 minutes per video).
- **TRANSCRIPT EXTRACTION**: Do NOT use the YouTube Captions API â€” it requires OAuth 2.0 (not just API key). Instead:
  1. Primary: `yt-dlp --write-auto-sub --sub-lang en --skip-download --output "%(id)s" URL` â†’ produces `.en.vtt` file
  2. Parse .vtt to plain text (strip timestamps, formatting, duplicates)
  3. Fallback: If no auto-captions available, flag the video as "no transcript" and let the user manually paste one
- For metadata: YouTube Data API v3 `videos.list` with `snippet,contentDetails,statistics` parts. This only requires API key.
- For channel batch: YouTube Data API v3 `search.list` with `channelId`, `order=date`, `maxResults=10`, `type=video`.
- Download video: `yt-dlp -f "bestvideo[height<=1080][ext=mp4]+bestaudio[ext=m4a]/best[height<=1080][ext=mp4]" --merge-output-format mp4 -o "/tmp/%(id)s.mp4" URL`
- **VIDEO SIZE CONSTRAINT**: Reject videos longer than 20 minutes. Compress to 720p if file exceeds 200MB: `ffmpeg -i input.mp4 -vf scale=-2:720 -c:v libx264 -crf 28 -c:a aac -b:a 128k output.mp4`
- Upload to Supabase Storage. For files >50MB, use Supabase `tus` resumable upload protocol: `supabase.storage.from('bucket').uploadToSignedUrl(path, token, file)`
- Clean up `/tmp` files after upload.

**Acceptance Criteria**:
- [ ] Can scrape a single YouTube URL â†’ returns title, description, thumbnail URL, transcript text, downloads MP4
- [ ] Can batch scrape a channel URL â†’ returns metadata for 5-10 most recent videos
- [ ] Transcript extraction works via yt-dlp (NOT captions API)
- [ ] VTT parser correctly strips timestamps and duplicate lines
- [ ] Videos >20 min are rejected with clear user-facing error
- [ ] Large files compressed before upload
- [ ] All assets uploaded to Supabase Storage with correct bucket paths
- [ ] Database records created for each scraped video
- [ ] Error handling for private videos, age-restricted content, unavailable videos
- [ ] Progress reporting via job status endpoint
- [ ] `/tmp` cleanup after every scrape job (success or failure)

---

#### Agent 2: `title-remixer-specialist`

**Responsibilities**: Generate title variations using Google Gemini API.

**Owns these files**:
```
src/lib/remix/
â”œâ”€â”€ title-remixer.ts       # Gemini API integration for title generation
â”œâ”€â”€ title-prompts.ts       # Prompt templates for different remix styles
â””â”€â”€ title-types.ts         # TypeScript types
src/app/api/remix-engine/remix/title/
â””â”€â”€ route.ts               # POST /api/remix-engine/remix/title
```

**Implementation Details**:
- Use `@google/generative-ai` npm package.
- Model: `gemini-2.0-flash` (fast, cheap, good for text).
- Generate 8 title variations per video across these categories:
  1. **Curiosity Gap**: "You Won't Believe What Happens When..."
  2. **Direct Value**: Clear benefit statement
  3. **Contrarian**: Challenge conventional wisdom
  4. **Listicle**: "7 Ways to..." / "Top 5..."
  5. **Question**: Provocative question format
  6. **Emotional Hook**: Fear, excitement, surprise
  7. **Tutorial/How-To**: Instructional framing
  8. **Story-Driven**: Narrative hook
- Prompt template includes: original title, video description, channel name, channel niche context.
- Use `generationConfig: { responseMimeType: 'application/json', responseSchema: ... }` for structured output.
- Return JSON: `{ variations: [{ style: string, title: string, reasoning: string }] }`.
- User can select, edit, or regenerate individual variations.

**Acceptance Criteria**:
- [ ] Generates 8 categorized title variations from original title + description
- [ ] Returns structured JSON matching the Zod schema (Section 6)
- [ ] Handles Gemini rate limits gracefully (exponential backoff)
- [ ] Batch mode: process multiple videos' titles in parallel
- [ ] Selected title saved back to database

---

#### Agent 3: `thumbnail-remixer-specialist`

**Responsibilities**: Generate remixed thumbnails using fal.ai (FLUX model).

**Owns these files**:
```
src/lib/remix/
â”œâ”€â”€ thumbnail-remixer.ts   # fal.ai API integration
â”œâ”€â”€ thumbnail-analyzer.ts  # Gemini Vision analysis of original thumbnail
â”œâ”€â”€ thumbnail-prompts.ts   # Image generation prompt engineering
â””â”€â”€ thumbnail-types.ts     # TypeScript types
src/app/api/remix-engine/remix/thumbnail/
â””â”€â”€ route.ts               # POST /api/remix-engine/remix/thumbnail
```

**Implementation Details**:
- Use `@fal-ai/serverless-client` npm package.
- Workflow:
  1. Download original thumbnail to `/tmp`
  2. Analyze with Gemini Vision (`gemini-2.0-flash` with image input) â†’ extract scene description, text overlays, color palette, composition
  3. Generate detailed image prompt from analysis + remixed title context
  4. Send to fal.ai: `fal-ai/flux/dev` endpoint
  5. Generate 3 thumbnail variations per video
- Image specs: 1280x720 (standard YouTube thumbnail).
- fal.ai uses async queue â†’ subscribe pattern. Use `fal.subscribe()` which handles polling internally.
- Store generated thumbnails in Supabase Storage.
- Clean up `/tmp` after.

**Acceptance Criteria**:
- [ ] Analyzes original thumbnail and extracts visual description via Gemini Vision
- [ ] Generates 3 thumbnail variations at 1280x720
- [ ] All thumbnails stored in Supabase Storage
- [ ] User can regenerate with custom prompt modifications
- [ ] Handles fal.ai queue/subscribe pattern correctly
- [ ] Temp files cleaned up

---

#### Agent 4: `script-remixer-specialist`

**Responsibilities**: Rewrite video transcripts into new scripts using Gemini API.

**Owns these files**:
```
src/lib/remix/
â”œâ”€â”€ script-remixer.ts      # Gemini API for script rewriting
â”œâ”€â”€ script-prompts.ts      # Prompt templates for different script styles
â”œâ”€â”€ scene-splitter.ts      # Split script into scenes with B-roll descriptions
â””â”€â”€ script-types.ts        # TypeScript types
src/app/api/remix-engine/remix/script/
â””â”€â”€ route.ts               # POST /api/remix-engine/remix/script
```

**Implementation Details**:
- Use `gemini-2.0-flash` for fast generation.
- Input: Original transcript + original title + remixed title (selected by user).
- Output structure (enforce via Gemini JSON mode + Zod validation):
```typescript
interface RemixedScript {
  fullScript: string;
  scenes: {
    sceneNumber: number;
    dialogueLine: string;          // What the avatar says
    duration: number;              // Estimated seconds
    bRollDescription: string;      // Visual description for AI video generation
    onScreenText?: string;         // Optional text overlay
  }[];
  totalDuration: number;
  tone: string;
  targetAudience: string;
}
```
- Scene splitter: Each scene should be 15-45 seconds of dialogue. If Gemini returns scenes outside this range, auto-split or merge.
- Prompt engineering: Instruct Gemini to rewrite with fresh perspective while preserving core information. Not plagiarism â€” genuine remix with new angles, examples, phrasing.
- Maximum output: ~2000 words (roughly 12-15 minute video).
- **IMPORTANT**: The `sceneNumber` must be unique per script. Enforce via application logic before database insert.

**Acceptance Criteria**:
- [ ] Rewrites transcript into structured scene-based script
- [ ] Each scene includes dialogue, duration estimate, and B-roll description
- [ ] Scene numbers are sequential and unique per script
- [ ] Scenes are 15-45 seconds each (auto-split/merge if outside range)
- [ ] Script stored in database with full scene breakdown
- [ ] User can edit individual scenes in the UI before proceeding
- [ ] Supports regeneration of individual scenes

---

#### Agent 5: `voiceover-specialist`

**Responsibilities**: Convert remixed scripts to audio using ElevenLabs API.

**Owns these files**:
```
src/lib/audio/
â”œâ”€â”€ elevenlabs.ts          # 11Labs API client
â”œâ”€â”€ voice-config.ts        # Voice selection and settings
â”œâ”€â”€ audio-concat.ts        # FFmpeg audio concatenation utility
â””â”€â”€ audio-types.ts         # TypeScript types
src/app/api/remix-engine/audio/
â”œâ”€â”€ generate/route.ts      # POST /api/remix-engine/audio/generate
â”œâ”€â”€ voices/route.ts        # GET /api/remix-engine/audio/voices â€” list available voices
â””â”€â”€ preview/route.ts       # POST /api/remix-engine/audio/preview â€” short preview clip
```

**Implementation Details**:
- Use direct REST API (more control than npm package).
- Endpoint: `POST https://api.elevenlabs.io/v1/text-to-speech/{voice_id}`
- Generate audio per scene individually â€” enables scene-level re-recording.
- Voice settings: `stability: 0.5, similarity_boost: 0.75, style: 0.5` (adjustable per project via `projects.settings` JSONB).
- Output format: MP3 at 44100Hz. Set `output_format: "mp3_44100_128"` in request.
- Response is audio binary stream â†’ write to `/tmp/{scene_id}.mp3` â†’ upload to Supabase Storage â†’ clean `/tmp`.
- Concatenation for final audio: Use FFmpeg concat demuxer:
  ```bash
  ffmpeg -f concat -safe 0 -i filelist.txt -c copy output.mp3
  ```
  where `filelist.txt` contains `file '/tmp/scene-001.mp3'\nfile '/tmp/scene-002.mp3'` etc.
- Voice preview: Generate from first 200 characters of the selected script.

**Acceptance Criteria**:
- [ ] Lists available 11Labs voices (GET endpoint, cache for 1 hour)
- [ ] Generates audio for each scene individually
- [ ] Audio files stored in Supabase Storage at correct paths
- [ ] Can concatenate scene audio into single track via FFmpeg
- [ ] Handles 11Labs rate limits (exponential backoff, max 3 retries)
- [ ] Tracks character usage in `api_usage` table
- [ ] User can re-record individual scenes
- [ ] Temp files always cleaned up

---

#### Agent 6: `avatar-video-specialist`

**Responsibilities**: Generate AI avatar talking-head videos using HeyGen API.

**Owns these files**:
```
src/lib/video/
â”œâ”€â”€ heygen.ts              # HeyGen API client
â”œâ”€â”€ heygen-poller.ts       # Async status polling with exponential backoff
â”œâ”€â”€ avatar-config.ts       # Avatar selection, background settings
â””â”€â”€ avatar-types.ts        # TypeScript types
src/app/api/remix-engine/avatar/
â”œâ”€â”€ generate/route.ts      # POST /api/remix-engine/avatar/generate
â”œâ”€â”€ avatars/route.ts       # GET /api/remix-engine/avatar/avatars â€” list available avatars
â”œâ”€â”€ status/[jobId]/route.ts # GET /api/remix-engine/avatar/status/:jobId
â””â”€â”€ cancel/route.ts        # POST /api/remix-engine/avatar/cancel â€” cancel pending generation
src/app/api/remix-engine/webhooks/
â””â”€â”€ heygen/route.ts        # POST /api/remix-engine/webhooks/heygen â€” HeyGen completion callback
```

**Implementation Details**:
- HeyGen API v2: `POST https://api.heygen.com/v2/video/generate`
- **CRITICAL**: HeyGen needs your audio file to lip-sync the avatar. **DO NOT** use public URLs or make storage public. Instead, use HeyGen's **Upload Asset API**:
  1. Download audio from Supabase Storage to `/tmp` (server-side, via service role key)
  2. Upload audio to HeyGen via `POST https://upload.heygen.com/v1/asset` â†’ get `audio_asset_id`
  3. Create video using `audio_asset_id` (NOT `audio_url`) in the generation request
  4. This means our Supabase Storage stays 100% private. HeyGen has its own internal copy.
  5. Clean up `/tmp` after upload
- Generate avatar video per scene.
- Configuration per project (stored in `projects.settings`):
  - Avatar ID (from HeyGen's library)
  - Background: solid color `#0A0A0B` default, or transparent for compositing
  - Aspect ratio: 16:9 (landscape) or 9:16 (shorts)
- **Async handling**: Prefer webhooks over polling.
  - Set `callback_id` in generation request
  - HeyGen POSTs to `/api/remix-engine/webhooks/heygen` on completion
  - Webhook handler: verify signature â†’ download video â†’ upload to Supabase â†’ update scene record â†’ update job status
  - Fallback: If webhook doesn't fire within 5 minutes, fall back to polling every 15 seconds
- **Cancellation**: HeyGen doesn't support cancellation once submitted. The cancel endpoint marks the job as cancelled in our DB and ignores the webhook when it arrives.
- **Cost tracking**: Log every generation in `api_usage` table. HeyGen charges ~$0.10/minute.

**Acceptance Criteria**:
- [ ] Lists available HeyGen avatars (cache for 24 hours)
- [ ] Uses HeyGen Upload Asset API to deliver audio (NOT public URLs)
- [ ] Returns audio_asset_id from upload, uses it in video generation
- [ ] Generates avatar video per scene
- [ ] Webhook endpoint receives and processes completion callbacks
- [ ] Falls back to polling if webhook doesn't fire within 5 minutes
- [ ] Stores completed videos in Supabase Storage
- [ ] Displays cost estimate before generation
- [ ] Cancel endpoint marks job as cancelled
- [ ] Supports both landscape and portrait aspect ratios

---

#### Agent 7: `broll-specialist`

**Responsibilities**: Generate AI B-roll video clips using Runway ML or Kling API.

**Owns these files**:
```
src/lib/video/
â”œâ”€â”€ runway.ts              # Runway ML API client
â”œâ”€â”€ kling.ts               # Kling API client (fallback)
â”œâ”€â”€ broll-generator.ts     # B-roll generation orchestration with provider fallback
â””â”€â”€ broll-types.ts         # TypeScript types
src/app/api/remix-engine/broll/
â”œâ”€â”€ generate/route.ts      # POST /api/remix-engine/broll/generate
â”œâ”€â”€ status/[jobId]/route.ts # GET /api/remix-engine/broll/status/:jobId
â””â”€â”€ cancel/route.ts        # POST /api/remix-engine/broll/cancel
src/app/api/remix-engine/webhooks/
â””â”€â”€ runway/route.ts        # POST /api/remix-engine/webhooks/runway â€” Runway completion callback
```

**Implementation Details**:
- Primary: Runway ML Gen-3 Alpha Turbo API.
- Fallback: Kling API (if Runway rate-limited or erroring).
- Input: B-roll descriptions from scene splitter.
- Generate one 4-second clip per scene's B-roll description.
- Runway is async â€” submit, receive webhook or poll. ~30-120 seconds per generation.
- Output: MP4 clips â†’ download to `/tmp` â†’ upload to Supabase â†’ clean up.
- **Provider fallback logic**: Try Runway first. If 3 consecutive failures or rate limit hit, switch to Kling for remaining scenes. Log provider used in `api_usage`.
- Cost: Runway ~$0.05-0.10 per 4-second clip.

**Acceptance Criteria**:
- [ ] Generates B-roll clips from text descriptions
- [ ] Automatic provider fallback (Runway â†’ Kling)
- [ ] Handles async generation with webhooks + polling fallback
- [ ] Stores clips in Supabase Storage
- [ ] Cost estimation and tracking in `api_usage`
- [ ] Cancel endpoint for in-progress generations

---

#### Agent 8: `video-assembly-specialist`

**Responsibilities**: Combine all assets into final rendered video using FFmpeg + Remotion.

**Owns these files**:
```
src/lib/video/
â”œâ”€â”€ assembler.ts           # Video assembly orchestration
â”œâ”€â”€ asset-downloader.ts    # Download all scene assets from Supabase to /tmp
â”œâ”€â”€ remotion/
â”‚   â”œâ”€â”€ Root.tsx            # Remotion composition root
â”‚   â”œâ”€â”€ RemixVideo.tsx      # Main video component
â”‚   â”œâ”€â”€ scenes/
â”‚   â”‚   â”œâ”€â”€ AvatarScene.tsx # Avatar + audio scene
â”‚   â”‚   â”œâ”€â”€ BRollScene.tsx  # B-roll overlay scene
â”‚   â”‚   â””â”€â”€ TextOverlay.tsx # On-screen text component
â”‚   â”œâ”€â”€ config.ts          # Remotion config (fps, dimensions, duration calc)
â”‚   â””â”€â”€ fonts.ts           # Font loading for text overlays
â”œâ”€â”€ ffmpeg-utils.ts        # FFmpeg helper functions (concat, transcode, probe)
â””â”€â”€ assembly-types.ts      # TypeScript types
src/app/api/remix-engine/render/
â”œâ”€â”€ route.ts               # POST /api/remix-engine/render â€” trigger final render
â”œâ”€â”€ status/[jobId]/route.ts # GET /api/remix-engine/render/status/:jobId
â””â”€â”€ cancel/route.ts        # POST /api/remix-engine/render/cancel
```

**Implementation Details**:
- **Remotion** for declarative video composition (React â†’ video).
- **CRITICAL**: Remotion requires Chromium. The worker Dockerfile MUST install it (see Section 18). Use `@remotion/renderer` with `chromiumOptions: { disableWebSecurity: true }` and specify the Chromium path.
- **FFmpeg** for:
  - Audio concatenation (concat demuxer)
  - Video transcoding (normalize all inputs to same fps/resolution/codec before Remotion)
  - Final output encoding (H.264, AAC, MP4)
  - Probing video metadata (`ffprobe` for duration, resolution, fps)
- Assembly sequence per video:
  1. Download all scene assets from Supabase to `/tmp/{video_id}/`
  2. Normalize: Transcode all video assets to 1080p 30fps H.264 (some may be different formats)
  3. Build Remotion composition: For each scene, show avatar video (3-5s) then cut to B-roll (3-5s), with audio continuous
  4. Add text overlays from script `onScreenText` fields
  5. Optional: Add configurable intro card (title) and outro card
  6. Render via `@remotion/renderer` bundle + render APIs
  7. Upload final MP4 to Supabase Storage
  8. Clean up ALL files in `/tmp/{video_id}/`
- Render at 1080p (1920x1080) 30fps MP4.
- **Disk space**: A 10-minute video render needs ~2-3GB temp space. Railway worker should have sufficient ephemeral storage. If not, process one video at a time.

**Acceptance Criteria**:
- [ ] Downloads all scene assets from Supabase to temp directory
- [ ] Normalizes video assets to consistent format before assembly
- [ ] Remotion composition renders correctly (avatar/B-roll alternating)
- [ ] Audio plays continuously over scene transitions
- [ ] Text overlays render correctly
- [ ] Final video is 1080p 30fps MP4
- [ ] Final video uploaded to Supabase Storage with download link
- [ ] Render progress reported in real-time (% complete)
- [ ] `/tmp` cleanup happens even on error
- [ ] Cancel endpoint stops in-progress render

---

#### Agent 9: `frontend-specialist`

**Responsibilities**: Build the UI/UX â€” dark mode dashboard, all pages, all components. Does NOT build auth pages (those belong to auth-admin-specialist).

**Owns these files**:
```
src/app/
â”œâ”€â”€ layout.tsx                     # Root layout with dark theme + fonts
â”œâ”€â”€ page.tsx                       # Redirect to /projects (or dashboard)
â”œâ”€â”€ not-found.tsx                  # Custom 404
â”œâ”€â”€ error.tsx                      # Custom error boundary
â”œâ”€â”€ (dashboard)/
â”‚   â”œâ”€â”€ layout.tsx                 # Dashboard layout with sidebar
â”‚   â”œâ”€â”€ projects/
â”‚   â”‚   â”œâ”€â”€ page.tsx               # Projects list
â”‚   â”‚   â”œâ”€â”€ new/page.tsx           # New project creation
â”‚   â”‚   â””â”€â”€ [id]/
â”‚   â”‚       â”œâ”€â”€ page.tsx           # Project detail / pipeline view
â”‚   â”‚       â”œâ”€â”€ scrape/page.tsx    # Scrape stage
â”‚   â”‚       â”œâ”€â”€ remix/page.tsx     # Remix stage (titles, thumbnails, script)
â”‚   â”‚       â”œâ”€â”€ generate/page.tsx  # Generation stage (audio, avatar, B-roll)
â”‚   â”‚       â”œâ”€â”€ assemble/page.tsx  # Assembly & render stage
â”‚   â”‚       â””â”€â”€ review/page.tsx    # Final review & download
â”‚   â””â”€â”€ batch/
â”‚       â”œâ”€â”€ page.tsx               # Batch operations dashboard
â”‚       â””â”€â”€ [batchId]/page.tsx     # Batch detail view
src/components/
â”œâ”€â”€ ui/                            # shadcn/ui primitives
â”œâ”€â”€ layout/
â”‚   â”œâ”€â”€ Sidebar.tsx
â”‚   â”œâ”€â”€ Header.tsx
â”‚   â””â”€â”€ ThemeProvider.tsx
â”œâ”€â”€ pipeline/
â”‚   â”œâ”€â”€ PipelineProgress.tsx
â”‚   â”œâ”€â”€ StageCard.tsx
â”‚   â””â”€â”€ JobStatus.tsx
â”œâ”€â”€ scrape/
â”‚   â”œâ”€â”€ UrlInput.tsx
â”‚   â”œâ”€â”€ ChannelBrowser.tsx
â”‚   â””â”€â”€ ScrapedPreview.tsx
â”œâ”€â”€ remix/
â”‚   â”œâ”€â”€ TitleVariations.tsx
â”‚   â”œâ”€â”€ ThumbnailGrid.tsx
â”‚   â”œâ”€â”€ ScriptEditor.tsx
â”‚   â””â”€â”€ SceneTimeline.tsx
â”œâ”€â”€ generate/
â”‚   â”œâ”€â”€ VoiceSelector.tsx
â”‚   â”œâ”€â”€ AvatarSelector.tsx
â”‚   â”œâ”€â”€ BRollPreview.tsx
â”‚   â””â”€â”€ CostEstimator.tsx
â”œâ”€â”€ video/
â”‚   â”œâ”€â”€ VideoPlayer.tsx            # Uses <video> with Supabase signed URL + Range headers
â”‚   â”œâ”€â”€ VideoTimeline.tsx
â”‚   â””â”€â”€ RenderProgress.tsx
â””â”€â”€ shared/
    â”œâ”€â”€ EmptyState.tsx             # Reusable empty state component
    â”œâ”€â”€ ErrorState.tsx             # Reusable error state component
    â”œâ”€â”€ SkeletonLoader.tsx         # Reusable skeleton loading patterns
    â””â”€â”€ ConfirmDialog.tsx          # Reusable confirmation modal
```

**Design System (Generated by UI UX Pro Max)**:

Do NOT hardcode a design system. Generate it at build time using the UUPM skill:

```bash
# Phase 1 â€” Generate the design system for RemixEngine
python3 skills/ui-ux-pro-max/scripts/search.py "SaaS dashboard video production tool dark mode professional internal tool pipeline" --design-system --persist -p "RemixEngine" --page "dashboard"

# Generate page-specific overrides as needed:
python3 skills/ui-ux-pro-max/scripts/search.py "RemixEngine" --design-system --persist -p "RemixEngine" --page "projects"
python3 skills/ui-ux-pro-max/scripts/search.py "RemixEngine" --design-system --persist -p "RemixEngine" --page "video-editor"
python3 skills/ui-ux-pro-max/scripts/search.py "RemixEngine" --design-system --persist -p "RemixEngine" --page "admin"

# Get stack-specific guidance for Next.js + shadcn:
python3 skills/ui-ux-pro-max/scripts/search.py "dark mode dashboard" --stack nextjs
python3 skills/ui-ux-pro-max/scripts/search.py "video player timeline" --domain styles
python3 skills/ui-ux-pro-max/scripts/search.py "progress bar pipeline stepper" --domain styles
```

The output goes to `design-system/MASTER.md` and `design-system/pages/*.md`. When building any page:

```
I am building the [Page Name] page. Please read design-system/MASTER.md.
Also check if design-system/pages/[page-name].md exists.
If the page file exists, prioritize its rules. If not, use the Master rules exclusively.
Now, generate the code.
```

**IMPORTANT for module mode**: The UUPM design system defines CSS variables as DEFAULTS. In module mode, the parent dashboard's CSS variables take precedence. The frontend must ONLY use CSS variables â€” never hardcoded hex values. This means:
- All UUPM color tokens â†’ CSS custom properties in `globals.css`
- All component styles reference `var(--re-bg-primary)`, `var(--re-accent)`, etc.
- Prefix all CSS variables with `--re-` to avoid collisions with parent
- Parent can override any token: `--re-bg-primary: var(--parent-bg);`

**Fallback design tokens** (used ONLY if UUPM is unavailable or as CSS variable defaults):
```css
:root {
  --re-bg-primary: #0A0A0B;
  --re-bg-surface: #141415;
  --re-bg-elevated: #1C1C1E;
  --re-border: #2A2A2D;
  --re-text-primary: #FAFAFA;
  --re-text-secondary: #A1A1AA;
  --re-text-tertiary: #71717A;
  --re-accent-primary: #6366F1;
  --re-accent-primary-hover: #818CF8;
  --re-accent-success: #22C55E;
  --re-accent-warning: #F59E0B;
  --re-accent-danger: #EF4444;
}
```

**Key UI Patterns**:
1. **Pipeline Stepper**: Horizontal 5-step indicator. Steps: Scrape â†’ Remix â†’ Generate â†’ Assemble â†’ Review. Visual states: locked (gray), active (pulsing accent), complete (green check), error (red X).
2. **Split-Pane Comparison**: Original (left) vs remixed (right) for titles, thumbnails, scripts.
3. **Real-time Job Cards**: Card with animated progress bar, ETA, status text. Uses Supabase Realtime subscription on `jobs` table.
4. **Video Player**: HTML5 `<video>` with Supabase signed URL. Must include `type="video/mp4"`. For large files, ensure Supabase returns `Accept-Ranges: bytes` header for seek support.
5. **Cost Calculator Widget**: Floating or pinned component showing running total of estimated costs before commit.
6. **Toast Notifications**: shadcn/ui Toast for job completions, errors, warnings.
7. **Empty States**: Every list/grid has a designed empty state with CTA.
8. **Skeleton Loaders**: Every async-loaded component shows a skeleton while loading.

**Acceptance Criteria**:
- [ ] All pages render correctly with dark theme
- [ ] CSS variables used consistently (no hardcoded colors)
- [ ] Responsive (desktop-first, functional on tablet at 768px+)
- [ ] Pipeline progress accurately reflects job states from database
- [ ] Real-time updates display without page refresh
- [ ] All forms validate with Zod before submission
- [ ] Loading, error, and empty states for every async component
- [ ] Video player works with large files (seek support)
- [ ] Toast notifications for job events

---

#### Agent 10: `supabase-specialist`

**Responsibilities**: Database schema, migrations, RLS policies, storage bucket creation, Realtime config.

**Owns these files**:
```
supabase/
â”œâ”€â”€ config.toml
â”œâ”€â”€ migrations/
â”‚   â”œâ”€â”€ 001_initial_schema.sql     # All tables, indexes, triggers, functions
â”‚   â”œâ”€â”€ 002_rls_policies.sql       # All RLS policies
â”‚   â”œâ”€â”€ 003_storage_setup.sql      # Bucket creation + storage policies
â”‚   â””â”€â”€ 004_realtime_setup.sql     # Realtime publication config
â”œâ”€â”€ seed.sql                       # First admin user + system settings defaults
â””â”€â”€ functions/                     # Edge Functions (webhook receivers if needed)
src/lib/supabase/
â”œâ”€â”€ client.ts                      # Browser Supabase client (uses anon key)
â”œâ”€â”€ server.ts                      # Server Supabase client (uses service role key)
â”œâ”€â”€ admin.ts                       # Admin Supabase client (bypasses RLS for worker operations)
â”œâ”€â”€ middleware.ts                   # Cookie-based session handling for SSR
â””â”€â”€ types.ts                       # Auto-generated types (run: npx supabase gen types typescript)
```

**CRITICAL**: The worker process runs outside of user auth context. It needs a Supabase client initialized with the service role key that bypasses RLS. This is `src/lib/supabase/admin.ts`:
```typescript
import { createClient } from '@supabase/supabase-js';
import { getServerConfig } from '../remix-engine/config';

// Uses config provider â€” never reads process.env directly
const config = getServerConfig();
export const supabaseAdmin = createClient(
  config.supabase.url,
  config.supabase.serviceRoleKey,
  { auth: { persistSession: false } }
);
```
All worker database operations use `supabaseAdmin`. All web operations use the cookie-based client.

---

#### Agent 11: `auth-admin-specialist`

**Responsibilities**: Authentication flow, RBAC, user management admin panel, admin pages.

**Owns these files**:
```
src/lib/auth/
â”œâ”€â”€ auth-context.tsx               # React context providing user + role
â”œâ”€â”€ auth-guard.tsx                 # Client component wrapper â€” redirects if not authed
â”œâ”€â”€ role-guard.tsx                 # Client component wrapper â€” hides content if wrong role
â”œâ”€â”€ require-role.ts                # Server-side role check utility for API routes
â””â”€â”€ auth-actions.ts                # Server actions: login, signup, logout, invite
src/app/(auth)/
â”œâ”€â”€ login/page.tsx                 # Login page (email + password)
â”œâ”€â”€ signup/page.tsx                # Invite-only signup (from magic link)
â””â”€â”€ callback/route.ts              # Supabase auth callback handler
src/app/(dashboard)/admin/
â”œâ”€â”€ page.tsx                       # Admin dashboard (usage stats overview)
â”œâ”€â”€ users/page.tsx                 # User management table
â””â”€â”€ settings/page.tsx              # API keys + system config
src/components/admin/
â”œâ”€â”€ UserTable.tsx
â”œâ”€â”€ UserInviteDialog.tsx
â”œâ”€â”€ RoleSelector.tsx
â””â”€â”€ ApiKeyManager.tsx
src/middleware.ts                   # Next.js middleware â€” auth check + role routing
```

**Implementation Details**:
- Supabase Auth with email/password.
- **No public signup**. Flow:
  1. Admin goes to `/admin/users` â†’ clicks "Invite User"
  2. Server action calls `supabaseAdmin.auth.admin.inviteUserByEmail(email, { data: { role: 'editor' } })`
  3. User receives email â†’ clicks link â†’ lands on `/signup` to set password
  4. `handle_new_user` trigger creates their profile with specified role
- JWT sessions in HTTP-only cookies via `@supabase/ssr`.
- Middleware:
  - `/login`, `/signup`, `/callback` â†’ always accessible
  - `/admin/**` â†’ requires `admin` role (fetch from DB, not JWT)
  - Everything else â†’ requires authentication
- `require-role.ts` for API routes:
```typescript
export async function requireRole(roles: string[]): Promise<User> {
  const config = getServerConfig();
  const supabase = createServerClient();
  
  if (config.mode === 'module' && config.auth) {
    // Module mode: user/role injected by parent
    if (!roles.includes(config.auth.role)) throw new AuthError('Insufficient permissions', 403);
    return { id: config.auth.user.id, email: config.auth.user.email, role: config.auth.role };
  }
  
  // Standalone mode: check Supabase Auth
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new AuthError('Not authenticated', 401);
  const { data: profile } = await supabase.from('re_users').select('role, is_active').eq('id', user.id).single();
  if (!profile?.is_active) throw new AuthError('Account deactivated', 403);
  if (!roles.includes(profile.role)) throw new AuthError('Insufficient permissions', 403);
  return { ...user, role: profile.role };
}
```

**Acceptance Criteria**:
- [ ] Login page works (email + password)
- [ ] Invite flow works (admin invites â†’ email sent â†’ user sets password)
- [ ] Middleware redirects correctly based on auth state and role
- [ ] Admin panel: can list users, change roles, deactivate accounts
- [ ] API key management: masked display, test connection for each service
- [ ] Role checks enforced on every API route
- [ ] Session refresh works (no random logouts)

---

## 4. TECH STACK & DEPENDENCIES

### Core

```json
{
  "dependencies": {
    "next": "^14.2",
    "react": "^18.3",
    "react-dom": "^18.3",
    "typescript": "^5.5",

    "@supabase/supabase-js": "^2.45",
    "@supabase/ssr": "^0.4",

    "@google/generative-ai": "^0.21",
    "@fal-ai/serverless-client": "^0.14",

    "bullmq": "^5.12",
    "ioredis": "^5.4",

    "@remotion/core": "^4.0",
    "@remotion/renderer": "^4.0",
    "@remotion/cli": "^4.0",
    "fluent-ffmpeg": "^2.1",

    "tailwindcss": "^3.4",
    "class-variance-authority": "^0.7",
    "clsx": "^2.1",
    "tailwind-merge": "^2.5",
    "lucide-react": "^0.441",
    "framer-motion": "^11.5",

    "zod": "^3.23",
    "date-fns": "^3.6",
    "nanoid": "^5.0",
    "pino": "^9.0",
    "pino-pretty": "^11.0"
  },
  "devDependencies": {
    "@types/node": "^22",
    "@types/react": "^18",
    "@types/fluent-ffmpeg": "^2.1",
    "eslint": "^9",
    "prettier": "^3.3",
    "supabase": "^1.200"
  }
}
```

**Note**: `elevenlabs` npm package is NOT used â€” we use direct REST API calls for more control over streaming responses. No npm package for HeyGen or Runway either â€” direct REST.

### System Dependencies

```bash
# On developer machine (macOS)
brew install yt-dlp ffmpeg redis

# On Railway (handled by Dockerfile â€” see Section 18)
# yt-dlp, ffmpeg, chromium all installed in container
```

---

## 5. DATABASE SCHEMA (SUPABASE)

### Migration 001: Initial Schema

```sql
-- ============================================
-- USERS (extends Supabase auth.users)
-- ============================================
CREATE TABLE public.re_users (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT NOT NULL UNIQUE,
  full_name TEXT,
  role TEXT NOT NULL DEFAULT 'viewer' CHECK (role IN ('admin', 'editor', 'viewer')),
  avatar_url TEXT,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============================================
-- PROJECTS
-- ============================================
CREATE TABLE public.re_projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  created_by UUID NOT NULL REFERENCES public.re_users(id),
  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN (
    'draft', 'scraping', 'remixing', 'generating', 'assembling', 'complete', 'error'
  )),
  settings JSONB NOT NULL DEFAULT '{
    "aspect_ratio": "16:9",
    "voice_id": null,
    "avatar_id": null,
    "voice_settings": {"stability": 0.5, "similarity_boost": 0.75, "style": 0.5},
    "max_video_duration_minutes": 20,
    "target_resolution": "1080p"
  }'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============================================
-- BATCH JOBS
-- ============================================
CREATE TABLE public.re_batch_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES public.re_projects(id) ON DELETE CASCADE,
  channel_url TEXT,
  channel_id TEXT,
  channel_name TEXT,
  total_videos INTEGER NOT NULL DEFAULT 0,
  completed_videos INTEGER NOT NULL DEFAULT 0,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
    'pending', 'scraping', 'scraped', 'processing', 'complete', 'error'
  )),
  created_by UUID NOT NULL REFERENCES public.re_users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============================================
-- VIDEOS (scraped YouTube videos)
-- ============================================
CREATE TABLE public.re_videos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES public.re_projects(id) ON DELETE CASCADE,
  batch_job_id UUID REFERENCES public.re_batch_jobs(id) ON DELETE SET NULL,
  youtube_url TEXT NOT NULL,
  youtube_id TEXT NOT NULL,
  original_title TEXT,
  original_description TEXT,
  original_thumbnail_url TEXT,
  original_transcript TEXT,
  channel_name TEXT,
  channel_id TEXT,
  duration_seconds INTEGER,
  view_count BIGINT,
  published_at TIMESTAMPTZ,
  -- File references (Supabase Storage paths)
  video_file_path TEXT,
  thumbnail_file_path TEXT,
  transcript_file_path TEXT,
  -- Pipeline status per video
  scrape_status TEXT DEFAULT 'pending' CHECK (scrape_status IN ('pending', 'processing', 'complete', 'error')),
  remix_status TEXT DEFAULT 'pending' CHECK (remix_status IN ('pending', 'processing', 'complete', 'error')),
  generation_status TEXT DEFAULT 'pending' CHECK (generation_status IN ('pending', 'processing', 'complete', 'error')),
  assembly_status TEXT DEFAULT 'pending' CHECK (assembly_status IN ('pending', 'processing', 'complete', 'error')),
  error_message TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  -- Prevent duplicate YouTube videos in same project
  UNIQUE(project_id, youtube_id)
);

-- ============================================
-- REMIXED TITLES
-- ============================================
CREATE TABLE public.re_remixed_titles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  video_id UUID NOT NULL REFERENCES public.re_videos(id) ON DELETE CASCADE,
  style TEXT NOT NULL,
  title TEXT NOT NULL,
  reasoning TEXT,
  is_selected BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============================================
-- REMIXED THUMBNAILS
-- ============================================
CREATE TABLE public.re_remixed_thumbnails (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  video_id UUID NOT NULL REFERENCES public.re_videos(id) ON DELETE CASCADE,
  prompt TEXT NOT NULL,
  analysis TEXT,                    -- Gemini Vision analysis of original
  file_path TEXT NOT NULL,
  is_selected BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============================================
-- REMIXED SCRIPTS
-- ============================================
CREATE TABLE public.re_remixed_scripts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  video_id UUID NOT NULL REFERENCES public.re_videos(id) ON DELETE CASCADE,
  full_script TEXT NOT NULL,
  tone TEXT,
  target_audience TEXT,
  total_duration_seconds INTEGER,
  is_selected BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============================================
-- SCENES (part of a remixed script)
-- ============================================
CREATE TABLE public.re_scenes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  script_id UUID NOT NULL REFERENCES public.re_remixed_scripts(id) ON DELETE CASCADE,
  scene_number INTEGER NOT NULL,
  dialogue_line TEXT NOT NULL,
  duration_seconds INTEGER NOT NULL,
  broll_description TEXT NOT NULL,
  on_screen_text TEXT,
  -- Generated asset paths
  audio_file_path TEXT,
  avatar_video_path TEXT,
  broll_video_path TEXT,
  -- Status tracking per scene
  audio_status TEXT DEFAULT 'pending' CHECK (audio_status IN ('pending', 'processing', 'complete', 'error')),
  avatar_status TEXT DEFAULT 'pending' CHECK (avatar_status IN ('pending', 'processing', 'complete', 'error')),
  broll_status TEXT DEFAULT 'pending' CHECK (broll_status IN ('pending', 'processing', 'complete', 'error')),
  error_message TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  -- Enforce unique scene numbers per script
  UNIQUE(script_id, scene_number)
);

-- ============================================
-- RENDERED VIDEOS (final output)
-- ============================================
CREATE TABLE public.re_rendered_videos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  video_id UUID NOT NULL REFERENCES public.re_videos(id) ON DELETE CASCADE,
  script_id UUID NOT NULL REFERENCES public.re_remixed_scripts(id),
  file_path TEXT NOT NULL,
  duration_seconds INTEGER,
  resolution TEXT DEFAULT '1080p',
  file_size_bytes BIGINT,
  render_time_seconds INTEGER,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============================================
-- JOBS (async job tracking â€” used for Realtime progress)
-- ============================================
CREATE TABLE public.re_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type TEXT NOT NULL CHECK (type IN (
    'scrape', 'scrape_batch',
    'remix_title', 'remix_thumbnail', 'remix_script',
    'generate_audio', 'generate_avatar', 'generate_broll',
    'render'
  )),
  status TEXT NOT NULL DEFAULT 'queued' CHECK (status IN ('queued', 'processing', 'complete', 'error', 'cancelled')),
  video_id UUID REFERENCES public.re_videos(id) ON DELETE CASCADE,
  project_id UUID REFERENCES public.re_projects(id) ON DELETE CASCADE,
  scene_id UUID REFERENCES public.re_scenes(id) ON DELETE CASCADE,
  progress INTEGER DEFAULT 0 CHECK (progress >= 0 AND progress <= 100),
  result JSONB,
  error_message TEXT,
  retry_count INTEGER DEFAULT 0,
  max_retries INTEGER DEFAULT 3,
  created_by UUID REFERENCES public.re_users(id),
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============================================
-- API USAGE TRACKING
-- ============================================
CREATE TABLE public.re_api_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  service TEXT NOT NULL CHECK (service IN ('gemini', 'fal_ai', 'elevenlabs', 'heygen', 'runway', 'kling', 'youtube')),
  endpoint TEXT NOT NULL,
  tokens_used INTEGER,
  characters_used INTEGER,          -- For 11Labs
  minutes_used DECIMAL(10,2),       -- For HeyGen
  cost_estimate DECIMAL(10,4) NOT NULL DEFAULT 0,
  video_id UUID REFERENCES public.re_videos(id),
  project_id UUID REFERENCES public.re_projects(id),
  user_id UUID REFERENCES public.re_users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============================================
-- SYSTEM SETTINGS (admin-configurable)
-- ============================================
CREATE TABLE public.re_system_settings (
  key TEXT PRIMARY KEY,
  value JSONB NOT NULL,
  description TEXT,
  updated_by UUID REFERENCES public.re_users(id),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============================================
-- INDEXES
-- ============================================
CREATE INDEX idx_re_videos_project ON public.re_videos(project_id);
CREATE INDEX idx_re_videos_batch ON public.re_videos(batch_job_id);
CREATE INDEX idx_re_videos_youtube ON public.re_videos(youtube_id);
CREATE INDEX idx_re_titles_video ON public.re_remixed_titles(video_id);
CREATE INDEX idx_re_titles_selected ON public.re_remixed_titles(video_id) WHERE is_selected = true;
CREATE INDEX idx_re_thumbnails_video ON public.re_remixed_thumbnails(video_id);
CREATE INDEX idx_re_scripts_video ON public.re_remixed_scripts(video_id);
CREATE INDEX idx_re_scenes_script ON public.re_scenes(script_id);
CREATE INDEX idx_re_scenes_order ON public.re_scenes(script_id, scene_number);
CREATE INDEX idx_re_jobs_video ON public.re_jobs(video_id);
CREATE INDEX idx_re_jobs_project ON public.re_jobs(project_id);
CREATE INDEX idx_re_jobs_status ON public.re_jobs(status) WHERE status IN ('queued', 'processing');
CREATE INDEX idx_re_jobs_type_status ON public.re_jobs(type, status);
CREATE INDEX idx_re_api_usage_service ON public.re_api_usage(service);
CREATE INDEX idx_re_api_usage_project ON public.re_api_usage(project_id);
CREATE INDEX idx_re_api_usage_date ON public.re_api_usage(created_at);

-- ============================================
-- TRIGGERS
-- ============================================
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_re_users_updated BEFORE UPDATE ON public.re_users
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
CREATE TRIGGER trg_re_projects_updated BEFORE UPDATE ON public.re_projects
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
CREATE TRIGGER trg_re_videos_updated BEFORE UPDATE ON public.re_videos
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
CREATE TRIGGER trg_re_batch_jobs_updated BEFORE UPDATE ON public.re_batch_jobs
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- Auto-create user profile on auth signup
-- NOTE: This trigger is for STANDALONE MODE ONLY. In module mode, the parent app
-- manages auth.users. The parent must populate re_users via the RemixEngine config
-- or via the admin API. When migrating to module mode, DROP this trigger.
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.re_users (id, email, full_name, role)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', split_part(NEW.email, '@', 1)),
    COALESCE(NEW.raw_user_meta_data->>'role', 'viewer')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user();
-- TODO (Module Mode): DROP TRIGGER on_auth_user_created ON auth.users;

-- Update batch job progress when video status changes
CREATE OR REPLACE FUNCTION update_batch_progress()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.batch_job_id IS NOT NULL THEN
    UPDATE public.re_batch_jobs
    SET completed_videos = (
      SELECT COUNT(*) FROM public.re_videos
      WHERE batch_job_id = NEW.batch_job_id AND scrape_status = 'complete'
    )
    WHERE id = NEW.batch_job_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trg_video_batch_progress
  AFTER UPDATE OF scrape_status ON public.re_videos
  FOR EACH ROW EXECUTE FUNCTION update_batch_progress();
```

### Migration 002: RLS Policies

```sql
-- Enable RLS on all tables
ALTER TABLE public.re_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.re_projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.re_batch_jobs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.re_videos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.re_remixed_titles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.re_remixed_thumbnails ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.re_remixed_scripts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.re_scenes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.re_rendered_videos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.re_jobs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.re_api_usage ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.re_system_settings ENABLE ROW LEVEL SECURITY;

-- USERS: Read own profile or admin reads all
CREATE POLICY "users_select" ON public.re_users FOR SELECT USING (
  auth.uid() = id OR
  EXISTS (SELECT 1 FROM public.re_users WHERE id = auth.uid() AND role = 'admin')
);
-- USERS: Only admin can insert/update/delete
CREATE POLICY "users_insert" ON public.re_users FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM public.re_users WHERE id = auth.uid() AND role = 'admin')
);
CREATE POLICY "users_update" ON public.re_users FOR UPDATE USING (
  auth.uid() = id OR  -- users can update own profile (name, avatar)
  EXISTS (SELECT 1 FROM public.re_users WHERE id = auth.uid() AND role = 'admin')
);
CREATE POLICY "users_delete" ON public.re_users FOR DELETE USING (
  EXISTS (SELECT 1 FROM public.re_users WHERE id = auth.uid() AND role = 'admin')
);

-- PROJECTS, VIDEOS, REMIXES, SCENES, RENDERED: Authenticated read, editor+ write
-- Using a helper function to reduce repetition
CREATE OR REPLACE FUNCTION is_active_user() RETURNS BOOLEAN AS $$
  SELECT EXISTS (SELECT 1 FROM public.re_users WHERE id = auth.uid() AND is_active = true);
$$ LANGUAGE sql SECURITY DEFINER STABLE;

CREATE OR REPLACE FUNCTION is_editor_or_admin() RETURNS BOOLEAN AS $$
  SELECT EXISTS (SELECT 1 FROM public.re_users WHERE id = auth.uid() AND role IN ('admin', 'editor') AND is_active = true);
$$ LANGUAGE sql SECURITY DEFINER STABLE;

CREATE OR REPLACE FUNCTION is_admin() RETURNS BOOLEAN AS $$
  SELECT EXISTS (SELECT 1 FROM public.re_users WHERE id = auth.uid() AND role = 'admin' AND is_active = true);
$$ LANGUAGE sql SECURITY DEFINER STABLE;

-- Apply standard policies to content tables
DO $$
DECLARE
  tbl TEXT;
BEGIN
  FOR tbl IN SELECT unnest(ARRAY[
    're_projects', 're_batch_jobs', 're_videos', 're_remixed_titles', 're_remixed_thumbnails',
    're_remixed_scripts', 're_scenes', 're_rendered_videos'
  ]) LOOP
    EXECUTE format('CREATE POLICY "%s_select" ON public.%I FOR SELECT USING (is_active_user())', tbl, tbl);
    EXECUTE format('CREATE POLICY "%s_insert" ON public.%I FOR INSERT WITH CHECK (is_editor_or_admin())', tbl, tbl);
    EXECUTE format('CREATE POLICY "%s_update" ON public.%I FOR UPDATE USING (is_editor_or_admin())', tbl, tbl);
    EXECUTE format('CREATE POLICY "%s_delete" ON public.%I FOR DELETE USING (is_admin())', tbl, tbl);
  END LOOP;
END $$;

-- JOBS: All authenticated users can read (for Realtime dashboard). Editor+ can write.
CREATE POLICY "jobs_select" ON public.re_jobs FOR SELECT USING (is_active_user());
CREATE POLICY "jobs_insert" ON public.re_jobs FOR INSERT WITH CHECK (is_editor_or_admin());
CREATE POLICY "jobs_update" ON public.re_jobs FOR UPDATE USING (is_editor_or_admin());
CREATE POLICY "jobs_delete" ON public.re_jobs FOR DELETE USING (is_admin());

-- API USAGE: Admin only read, editor+ insert
CREATE POLICY "api_usage_select" ON public.re_api_usage FOR SELECT USING (is_admin());
CREATE POLICY "api_usage_insert" ON public.re_api_usage FOR INSERT WITH CHECK (is_editor_or_admin());

-- SYSTEM SETTINGS: Admin only
CREATE POLICY "settings_select" ON public.re_system_settings FOR SELECT USING (is_admin());
CREATE POLICY "settings_all" ON public.re_system_settings FOR ALL USING (is_admin());
```

### Migration 003: Storage Setup

```sql
-- Create storage bucket
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'remixengine-assets',
  'remixengine-assets',
  false,
  524288000,  -- 500MB limit (requires Supabase Pro)
  ARRAY['video/mp4', 'image/jpeg', 'image/png', 'image/webp', 'audio/mpeg', 'audio/mp3', 'text/plain', 'text/vtt']
);

-- Storage policies
CREATE POLICY "storage_read" ON storage.objects FOR SELECT USING (
  bucket_id = 'remixengine-assets' AND auth.role() = 'authenticated'
);
CREATE POLICY "storage_insert" ON storage.objects FOR INSERT WITH CHECK (
  bucket_id = 'remixengine-assets' AND
  EXISTS (SELECT 1 FROM public.re_users WHERE id = auth.uid() AND role IN ('admin', 'editor'))
);
CREATE POLICY "storage_update" ON storage.objects FOR UPDATE USING (
  bucket_id = 'remixengine-assets' AND
  EXISTS (SELECT 1 FROM public.re_users WHERE id = auth.uid() AND role IN ('admin', 'editor'))
);
CREATE POLICY "storage_delete" ON storage.objects FOR DELETE USING (
  bucket_id = 'remixengine-assets' AND
  EXISTS (SELECT 1 FROM public.re_users WHERE id = auth.uid() AND role = 'admin')
);
```

### Migration 004: Realtime Setup

```sql
ALTER PUBLICATION supabase_realtime ADD TABLE public.re_jobs;
ALTER PUBLICATION supabase_realtime ADD TABLE public.re_videos;
ALTER PUBLICATION supabase_realtime ADD TABLE public.re_projects;
ALTER PUBLICATION supabase_realtime ADD TABLE public.re_batch_jobs;
ALTER PUBLICATION supabase_realtime ADD TABLE public.re_scenes;
```

### seed.sql

```sql
-- Create first admin user (run after first Supabase Auth signup)
-- The handle_new_user trigger creates the profile automatically.
-- To make the first user admin, update their role:
-- UPDATE public.re_users SET role = 'admin' WHERE email = 'your-email@domain.com';

-- Default system settings
INSERT INTO public.re_system_settings (key, value, description) VALUES
  ('default_voice_id', '"21m00Tcm4TlvDq8ikWAM"', 'Default ElevenLabs voice ID (Rachel)'),
  ('default_avatar_id', 'null', 'Default HeyGen avatar ID'),
  ('default_aspect_ratio', '"16:9"', 'Default video aspect ratio'),
  ('max_batch_size', '10', 'Maximum videos per batch'),
  ('max_video_duration_minutes', '20', 'Maximum video duration in minutes'),
  ('broll_provider', '"runway"', 'Primary B-roll provider: runway or kling'),
  ('cost_warning_threshold', '10.00', 'Warn user when estimated cost exceeds this amount (USD)')
ON CONFLICT (key) DO NOTHING;
```

---

## 6. ZOD VALIDATION SCHEMAS

```typescript
// src/lib/validators/schemas.ts
import { z } from 'zod';

// ============================================
// SCRAPE
// ============================================
export const ScrapeRequestSchema = z.object({
  youtubeUrl: z.string().url().refine(
    (url) => /^https?:\/\/(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/)/.test(url),
    { message: 'Must be a valid YouTube video URL' }
  ),
  projectId: z.string().uuid(),
});

export const BatchScrapeRequestSchema = z.object({
  channelUrl: z.string().url().refine(
    (url) => /^https?:\/\/(www\.)?youtube\.com\/(channel\/|c\/|@)/.test(url),
    { message: 'Must be a valid YouTube channel URL' }
  ),
  projectId: z.string().uuid(),
  videoIds: z.array(z.string()).min(1).max(10).optional(), // If specified, scrape only these
  maxVideos: z.number().int().min(1).max(10).default(10),
});

// ============================================
// REMIX
// ============================================
export const RemixTitleRequestSchema = z.object({
  videoId: z.string().uuid(),
});

export const RemixThumbnailRequestSchema = z.object({
  videoId: z.string().uuid(),
  customPromptModifier: z.string().max(500).optional(),
});

export const RemixScriptRequestSchema = z.object({
  videoId: z.string().uuid(),
  selectedTitleId: z.string().uuid().optional(), // Use selected title for context
  tone: z.enum(['professional', 'casual', 'energetic', 'educational', 'storytelling']).optional(),
});

// ============================================
// GENERATION
// ============================================
export const GenerateAudioRequestSchema = z.object({
  sceneId: z.string().uuid(),
  voiceId: z.string().min(1),
  voiceSettings: z.object({
    stability: z.number().min(0).max(1).default(0.5),
    similarity_boost: z.number().min(0).max(1).default(0.75),
    style: z.number().min(0).max(1).default(0.5),
  }).optional(),
});

export const GenerateAvatarRequestSchema = z.object({
  sceneId: z.string().uuid(),
  avatarId: z.string().min(1),
  background: z.object({
    type: z.enum(['color', 'image', 'transparent']),
    value: z.string().optional(), // hex color or image URL
  }).default({ type: 'color', value: '#0A0A0B' }),
  aspectRatio: z.enum(['16:9', '9:16']).default('16:9'),
});

export const GenerateBRollRequestSchema = z.object({
  sceneId: z.string().uuid(),
  provider: z.enum(['runway', 'kling', 'auto']).default('auto'),
  durationSeconds: z.number().int().min(2).max(8).default(4),
});

export const RenderRequestSchema = z.object({
  videoId: z.string().uuid(),
  scriptId: z.string().uuid(),
  includeIntro: z.boolean().default(true),
  includeOutro: z.boolean().default(true),
});

// ============================================
// PROJECTS
// ============================================
export const CreateProjectSchema = z.object({
  name: z.string().min(1).max(200),
  description: z.string().max(1000).optional(),
  settings: z.object({
    aspect_ratio: z.enum(['16:9', '9:16']).default('16:9'),
    voice_id: z.string().nullable().default(null),
    avatar_id: z.string().nullable().default(null),
  }).optional(),
});

export const UpdateProjectSchema = z.object({
  name: z.string().min(1).max(200).optional(),
  description: z.string().max(1000).optional(),
  settings: z.record(z.any()).optional(),
});

// ============================================
// ADMIN
// ============================================
export const InviteUserSchema = z.object({
  email: z.string().email(),
  role: z.enum(['admin', 'editor', 'viewer']).default('editor'),
  fullName: z.string().min(1).max(100).optional(),
});

export const UpdateUserSchema = z.object({
  role: z.enum(['admin', 'editor', 'viewer']).optional(),
  is_active: z.boolean().optional(),
  full_name: z.string().max(100).optional(),
});

// ============================================
// CANCEL
// ============================================
export const CancelJobSchema = z.object({
  jobId: z.string().uuid(),
});
```

---

## 7. API ROUTES & BACKEND

### Route Map

All routes namespaced under `/api/remix-engine/` for module isolation.

```
POST   /api/remix-engine/scrape                   â†’ Scrape single YouTube URL
POST   /api/remix-engine/scrape/batch             â†’ Scrape batch from channel
GET    /api/remix-engine/scrape/status/[jobId]    â†’ Scrape job status

POST   /api/remix-engine/remix/title              â†’ Generate title variations
POST   /api/remix-engine/remix/thumbnail          â†’ Generate thumbnail variations
POST   /api/remix-engine/remix/script             â†’ Generate remixed script

POST   /api/remix-engine/audio/generate           â†’ Generate voiceover (per scene)
GET    /api/remix-engine/audio/voices             â†’ List 11Labs voices
POST   /api/remix-engine/audio/preview            â†’ Preview voice with sample text

POST   /api/remix-engine/avatar/generate          â†’ Generate avatar video (per scene)
GET    /api/remix-engine/avatar/avatars           â†’ List HeyGen avatars
GET    /api/remix-engine/avatar/status/[jobId]    â†’ Avatar generation status
POST   /api/remix-engine/avatar/cancel            â†’ Cancel avatar generation

POST   /api/remix-engine/broll/generate           â†’ Generate B-roll clips
GET    /api/remix-engine/broll/status/[jobId]     â†’ B-roll generation status
POST   /api/remix-engine/broll/cancel             â†’ Cancel B-roll generation

POST   /api/remix-engine/render                   â†’ Trigger final video render
GET    /api/remix-engine/render/status/[jobId]    â†’ Render status
POST   /api/remix-engine/render/cancel            â†’ Cancel render

POST   /api/remix-engine/webhooks/heygen          â†’ HeyGen completion callback (no auth)
POST   /api/remix-engine/webhooks/runway          â†’ Runway completion callback (no auth)

GET    /api/remix-engine/projects                 â†’ List projects (paginated)
POST   /api/remix-engine/projects                 â†’ Create project
GET    /api/remix-engine/projects/[id]            â†’ Get project detail
PATCH  /api/remix-engine/projects/[id]            â†’ Update project
DELETE /api/remix-engine/projects/[id]            â†’ Delete project (admin only)

GET    /api/remix-engine/admin/users              â†’ List users (admin only)
POST   /api/remix-engine/admin/users/invite       â†’ Invite user (admin only)
PATCH  /api/remix-engine/admin/users/[id]         â†’ Update user role (admin only)
DELETE /api/remix-engine/admin/users/[id]         â†’ Deactivate user (admin only)

GET    /api/remix-engine/admin/usage              â†’ API usage stats (admin only)
GET    /api/remix-engine/admin/settings           â†’ System settings (admin only)
PUT    /api/remix-engine/admin/settings           â†’ Update settings (admin only)

GET    /api/remix-engine/health                   â†’ Health check (no auth)
GET    /api/remix-engine/spec.json                â†’ Module contract export (no auth)
```

### Request/Response Pattern

```typescript
// src/lib/api/response.ts
export type ApiResponse<T> = {
  success: boolean;
  data?: T;
  error?: {
    code: string;       // Machine-readable: 'VALIDATION_ERROR', 'UNAUTHORIZED', etc.
    message: string;    // Human-readable
    details?: unknown;
  };
};

// src/lib/api/handler.ts â€” Standard API route wrapper
export function apiHandler<T>(
  schema: ZodSchema | null,
  roles: string[],
  handler: (req: Request, user: User, body: T) => Promise<ApiResponse<any>>
) {
  return async (req: Request) => {
    try {
      // 1. Auth check
      const user = await requireRole(roles);
      // 2. Body validation (if schema provided)
      let body = null;
      if (schema && req.method !== 'GET') {
        const raw = await req.json();
        const parsed = schema.safeParse(raw);
        if (!parsed.success) {
          return Response.json({ success: false, error: { code: 'VALIDATION_ERROR', message: parsed.error.message } }, { status: 400 });
        }
        body = parsed.data;
      }
      // 3. Execute handler
      const result = await handler(req, user, body as T);
      return Response.json(result, { status: result.success ? 200 : 400 });
    } catch (error) {
      if (error instanceof AuthError) {
        return Response.json({ success: false, error: { code: 'AUTH_ERROR', message: error.message } }, { status: error.status });
      }
      logger.error('API error', { error });
      return Response.json({ success: false, error: { code: 'INTERNAL_ERROR', message: 'Internal server error' } }, { status: 500 });
    }
  };
}
```

### Webhook Route Pattern (No Auth)

```typescript
// Webhook routes do NOT require user auth â€” they're called by external services.
// Instead, verify by:
// - HeyGen: Check that video_id exists in our jobs table
// - Runway: Check that task_id exists in our jobs table
// Rate limit webhook endpoints to prevent abuse (max 100 req/min).
```

---

## 8. PIPELINE ARCHITECTURE

### Job Queue Design

```typescript
// src/lib/queue/connection.ts
import IORedis from 'ioredis';
import { getServerConfig } from '../remix-engine/config';

const config = getServerConfig();
export const redisConnection = new IORedis(config.redis.url, {
  maxRetriesPerRequest: null, // Required by BullMQ
  enableReadyCheck: false,
});

// src/lib/queue/queues.ts
import { Queue } from 'bullmq';
export const scrapeQueue = new Queue('scrape', { connection: redisConnection });
export const remixQueue = new Queue('remix', { connection: redisConnection });
export const generateQueue = new Queue('generate', { connection: redisConnection });
export const renderQueue = new Queue('render', { connection: redisConnection });
```

**Worker entry point** (runs as separate Railway service):

```typescript
// src/worker/index.ts
// IMPORTANT: This file runs as standalone Node.js â€” NOT inside Next.js.
// Use relative imports or tsconfig paths that resolve without Next.js.
import { Worker } from 'bullmq';
import { redisConnection } from '../lib/queue/connection';
import { handleScrapeJob } from './handlers/scrape';
import { handleRemixJob } from './handlers/remix';
import { handleGenerateJob } from './handlers/generate';
import { handleRenderJob } from './handlers/render';
import { logger } from '../lib/logger';

const workers = [
  new Worker('scrape', handleScrapeJob, { connection: redisConnection, concurrency: 3 }),
  new Worker('remix', handleRemixJob, { connection: redisConnection, concurrency: 5 }),
  new Worker('generate', handleGenerateJob, { connection: redisConnection, concurrency: 3 }),
  new Worker('render', handleRenderJob, { connection: redisConnection, concurrency: 1 }), // CPU-intensive, one at a time
];

workers.forEach(w => {
  w.on('completed', (job) => logger.info(`Job ${job.id} completed`, { queue: w.name }));
  w.on('failed', (job, err) => logger.error(`Job ${job?.id} failed`, { queue: w.name, error: err.message }));
});

logger.info(`ğŸ”§ RemixEngine workers started: ${workers.map(w => w.name).join(', ')}`);

process.on('SIGTERM', async () => {
  logger.info('Shutting down workers...');
  await Promise.all(workers.map(w => w.close()));
  process.exit(0);
});
```

**Worker tsconfig** (separate from Next.js):
```json
// tsconfig.worker.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "module": "commonjs",
    "moduleResolution": "node",
    "paths": {}  // Clear Next.js path aliases â€” use relative imports
  },
  "include": ["src/worker/**/*", "src/lib/**/*"]
}
```

### Pipeline State Machine

```
                                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                          â”‚  error   â”‚ (any stage can error)
                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â†‘
pending â†’ scraping â†’ scraped â†’ remixing â†’ remixed â†’ generating â†’ generated â†’ assembling â†’ complete
                                    â”‚                    â”‚
                                    â””â”€â”€ user review â”€â”€â”€â”€â”€â”˜ (user must approve before generation)
```

**Gate between Remix and Generate**: After remixing completes, the pipeline PAUSES. The user must:
1. Select a title variation (or edit one)
2. Select a thumbnail (or regenerate)
3. Review and approve the script (or edit scenes)
4. Select a voice and avatar

Only then can they click "Generate" to proceed. This is enforced in the API â€” `generate` endpoints check that selections exist.

### Batch Processing Concurrency

```
Channel scrape:     max 3 concurrent videos (YouTube rate limits)
Title remix:        max 5 concurrent (Gemini is fast)
Thumbnail remix:    max 3 concurrent (fal.ai queue)
Script remix:       max 3 concurrent (Gemini, larger context)
Audio generation:   max 5 concurrent scenes (11Labs is fast)
Avatar generation:  max 2 concurrent scenes (HeyGen is expensive + slow)
B-roll generation:  max 3 concurrent scenes (Runway queue)
Video render:       max 1 at a time (CPU-intensive)
```

---

## 9. FRONTEND SPECIFICATION

*(Same as Agent 9 definition above â€” see that section for full detail.)*

---

## 10. AUTHENTICATION & ROLES

*(Same as Agent 11 definition above â€” see that section for full detail.)*

---

## 11. FILE STORAGE STRATEGY

### Supabase Storage Structure

All paths inside the bucket are prefixed with `remix-engine/` for module namespace isolation.

```
remixengine-assets/
â””â”€â”€ remix-engine/                    â† storagePrefix from config
    â”œâ”€â”€ videos/{project_id}/{video_id}/
    â”‚   â”œâ”€â”€ original.mp4
    â”‚   â”œâ”€â”€ original-thumbnail.jpg
    â”‚   â””â”€â”€ transcript.txt
    â”œâ”€â”€ thumbnails/{video_id}/
    â”‚   â”œâ”€â”€ remix-1.png
    â”‚   â”œâ”€â”€ remix-2.png
    â”‚   â””â”€â”€ remix-3.png
    â”œâ”€â”€ audio/{video_id}/
    â”‚   â”œâ”€â”€ scene-{scene_number}.mp3
    â”‚   â””â”€â”€ full-voiceover.mp3
    â”œâ”€â”€ avatars/{video_id}/
    â”‚   â””â”€â”€ scene-{scene_number}.mp4
    â”œâ”€â”€ broll/{video_id}/
    â”‚   â””â”€â”€ scene-{scene_number}.mp4
    â””â”€â”€ rendered/{video_id}/
        â””â”€â”€ final.mp4
```

**Helper for storage paths** (use this, never construct paths manually):
```typescript
// src/lib/remix-engine/hooks.ts
export function storagePath(...segments: string[]): string {
  const config = getServerConfig();
  return [config.storagePrefix, ...segments].join('/');
}
// Usage: storagePath('videos', projectId, videoId, 'original.mp4')
// Result: 'remix-engine/videos/{projectId}/{videoId}/original.mp4'
```

### Signed URLs for Video Playback

```typescript
// For the frontend video player â€” generate signed URL with 1-hour expiry
import { storagePath } from '@/lib/remix-engine/hooks';

const { data } = await supabase.storage
  .from('remixengine-assets')
  .createSignedUrl(storagePath('rendered', videoId, 'final.mp4'), 3600);
// Use data.signedUrl in <video src={...}> tag
// Supabase Storage supports Range headers â†’ seeking works in HTML5 video
```

### Temp File Lifecycle

```typescript
// src/lib/utils/temp-files.ts
import { mkdirSync, rmSync, existsSync } from 'fs';
import path from 'path';

export function getTempDir(videoId: string): string {
  const dir = path.join('/tmp', 'remixengine', videoId);
  if (!existsSync(dir)) mkdirSync(dir, { recursive: true });
  return dir;
}

export function cleanTempDir(videoId: string): void {
  const dir = path.join('/tmp', 'remixengine', videoId);
  if (existsSync(dir)) rmSync(dir, { recursive: true, force: true });
}

// EVERY worker handler MUST call cleanTempDir in a finally block:
async function handleJob(job) {
  const videoId = job.data.videoId;
  try {
    const tmpDir = getTempDir(videoId);
    // ... do work ...
  } finally {
    cleanTempDir(videoId);
  }
}
```

---

## 12. ENVIRONMENT VARIABLES

```bash
# ============================================
# .env.local â€” COMPLETE LIST
# ============================================

# Supabase
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJ...
SUPABASE_SERVICE_ROLE_KEY=eyJ...

# YouTube / Google
YOUTUBE_DATA_API_KEY=AIza...
GOOGLE_GEMINI_API_KEY=AIza...

# Image Generation (fal.ai)
FAL_KEY=fal_...

# Voice Generation (ElevenLabs)
ELEVENLABS_API_KEY=sk_...

# Avatar Video (HeyGen)
HEYGEN_API_KEY=...

# B-Roll Generation
RUNWAY_API_KEY=...
KLING_API_KEY=...                   # Optional fallback

# Redis (Job Queue)
REDIS_URL=redis://localhost:6379    # Railway auto-provides this

# App
NEXT_PUBLIC_APP_URL=http://localhost:3000
NODE_ENV=development
LOG_LEVEL=info                      # debug | info | warn | error

# Webhook URLs (set after Railway deploy â€” used in HeyGen/Runway API calls)
WEBHOOK_BASE_URL=https://your-app.up.railway.app
```

### .gitignore (MUST include)

```
# Dependencies
node_modules/
.next/
dist/

# Environment
.env
.env.local
.env.production

# Supabase
supabase/.temp/

# OS
.DS_Store
Thumbs.db

# IDE
.vscode/
.idea/

# Temp
/tmp/remixengine/
```

### API Key Setup Guide

| Service | Signup URL | Free Tier | Pricing | Notes |
|---------|-----------|-----------|---------|-------|
| Supabase | supabase.com | 500MB DB, 1GB storage | Pro $25/mo (needed for large file uploads) | Create project â†’ Settings â†’ API |
| YouTube Data API | console.cloud.google.com | 10,000 units/day | Free for this use case | Enable YouTube Data API v3, create API key |
| Google Gemini | aistudio.google.com | 15 RPM free | Pay-as-go ~$0.075/1M tokens | Get API key from AI Studio |
| fal.ai | fal.ai | $10 free credits | ~$0.03 per image | Dashboard â†’ API Keys |
| ElevenLabs | elevenlabs.io | 10,000 chars/month | Creator $22/mo (100K chars) | Profile â†’ API Key |
| HeyGen | heygen.com | Trial credits | ~$0.10/min generated | Settings â†’ API â†’ Get Key |
| Runway ML | runwayml.com | Limited trial | ~$0.05/generation | API settings â†’ Keys |

---

## 13. BUILD PHASES

### Phase 1: Foundation (Day 1 â€” ~4 hours)

**Agents**: Supabase, Auth/Admin, Frontend (scaffold)

- [ ] `npx create-next-app@latest remixengine --typescript --tailwind --app --src-dir`
- [ ] Install all dependencies (one `npm install` command)
- [ ] Supabase project created, all 4 migrations run
- [ ] Seed data applied (system settings)
- [ ] First user signed up and promoted to admin via SQL
- [ ] Auth flow working (login â†’ dashboard)
- [ ] Dark mode theme + CSS variables in globals.css
- [ ] Dashboard layout with sidebar navigation (all page shells)
- [ ] shadcn/ui components installed
- [ ] `.env.local` configured with all keys
- [ ] Redis running locally
- [ ] yt-dlp + FFmpeg verified
- [ ] `.gitignore` in place
- [ ] Zod schemas file created

**âœ… Checkpoint**: Log in as admin, see dashboard, navigate to all pages (empty but styled).

### Phase 2: Scraping Pipeline (Day 1-2 â€” ~4 hours)

**Agents**: Scraping, Frontend

- [ ] yt-dlp wrapper: download MP4, compress if needed
- [ ] YouTube Data API: fetch metadata
- [ ] VTT transcript extraction + parser
- [ ] Supabase Storage upload working
- [ ] BullMQ scrape queue + worker handler
- [ ] `/projects/new` page: enter URL, create project, kick off scrape
- [ ] `/projects/[id]` Scrape tab: show original data + video player
- [ ] Batch: enter channel URL, select videos, scrape all
- [ ] Job status + Realtime progress updates

**âœ… Checkpoint**: Paste a YouTube URL â†’ see it scraped â†’ watch original video â†’ read transcript.

### Phase 3: Remix Pipeline (Day 2 â€” ~4 hours)

**Agents**: Title Remixer, Thumbnail Remixer, Script Remixer, Frontend

- [ ] Gemini title variations (8 per video, structured JSON)
- [ ] fal.ai thumbnail generation (3 per video)
- [ ] Gemini script rewriting with scene splitting
- [ ] Remix tab: title comparison, thumbnail grid, script editor
- [ ] Select/edit/regenerate for all remix types
- [ ] Scene editing in UI
- [ ] Batch remix across multiple videos

**âœ… Checkpoint**: See 8 title variations, 3 thumbnails, editable scene-based script.

### Phase 4: Generation Pipeline (Day 2-3 â€” ~6 hours)

**Agents**: Voiceover, Avatar, B-Roll, Frontend

- [ ] 11Labs voice list + per-scene audio generation
- [ ] HeyGen avatar list + per-scene video generation (signed URL for audio)
- [ ] Runway B-roll generation per scene
- [ ] Webhook endpoints for HeyGen + Runway
- [ ] Generate tab: voice picker, avatar picker, B-roll previews
- [ ] Cost estimator widget showing total before commit
- [ ] Cancel endpoints for in-progress jobs
- [ ] All assets in Supabase Storage

**âœ… Checkpoint**: Hear AI voiceover, see avatar video, see B-roll clips. Know the cost.

### Phase 5: Video Assembly (Day 3 â€” ~4 hours)

**Agents**: Video Assembly, Frontend

- [ ] Remotion composition (avatar/B-roll alternating scenes)
- [ ] FFmpeg normalization + audio concatenation
- [ ] Chromium working in worker container
- [ ] Render pipeline: download assets â†’ normalize â†’ compose â†’ render â†’ upload
- [ ] Assemble tab: timeline, render button, progress bar
- [ ] Review tab: final video player, download link

**âœ… Checkpoint**: Click "Render" â†’ get a final video â†’ download it.

### Phase 6: Polish & Admin (Day 3-4 â€” ~4 hours)

**Agents**: Frontend, Auth/Admin

- [ ] Admin panel complete (users, API keys, usage charts)
- [ ] Role enforcement verified on all routes
- [ ] Error states + empty states on every component
- [ ] Skeleton loaders for all async content
- [ ] Toast notifications for job events
- [ ] Batch dashboard with bulk actions
- [ ] Health check endpoint
- [ ] Logger integrated throughout
- [ ] Railway deployment tested

**âœ… Checkpoint**: Full end-to-end works. Admin manages users. Editors run pipelines. Viewers download.

---

## 14. API INTEGRATION SPECS

*(Same as v1 spec, but adding webhook patterns and signed URL patterns documented in Agent 6 above.)*

### YouTube Data API v3

```typescript
// Metadata (API key only â€” no OAuth)
GET https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails,statistics&id={videoId}&key={API_KEY}

// Channel search (API key only)
GET https://www.googleapis.com/youtube/v3/search?part=snippet&channelId={id}&order=date&maxResults=10&type=video&key={API_KEY}

// NOTE: Captions download API requires OAuth â€” DO NOT USE IT.
// Use yt-dlp for transcript extraction instead.
```

### Google Gemini

```typescript
import { GoogleGenerativeAI } from '@google/generative-ai';
import { getServerConfig } from '@/lib/remix-engine/config';

const config = getServerConfig();
const genAI = new GoogleGenerativeAI(config.apiKeys.gemini);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

const result = await model.generateContent({
  contents: [{ role: 'user', parts: [{ text: prompt }] }],
  generationConfig: {
    responseMimeType: 'application/json',
    temperature: 0.8, // Higher for creative title variations
  }
});
```

### fal.ai

```typescript
import * as fal from '@fal-ai/serverless-client';
import { getServerConfig } from '@/lib/remix-engine/config';

const config = getServerConfig();
fal.config({ credentials: config.apiKeys.falAi });

const result = await fal.subscribe('fal-ai/flux/dev', {
  input: { prompt: thumbnailPrompt, image_size: { width: 1280, height: 720 }, num_images: 1 },
  onQueueUpdate: (update) => { /* update progress in DB */ },
});
// result.images[0].url â†’ download â†’ upload to Supabase
```

### ElevenLabs (Direct REST)

```typescript
const config = getServerConfig();
const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, {
  method: 'POST',
  headers: { 'xi-api-key': config.apiKeys.elevenLabs, 'Content-Type': 'application/json' },
  body: JSON.stringify({
    text: sceneDialogue,
    model_id: 'eleven_multilingual_v2',
    output_format: 'mp3_44100_128',
    voice_settings: { stability: 0.5, similarity_boost: 0.75, style: 0.5 }
  })
});
// Response body is audio binary â€” pipe to file
const arrayBuffer = await response.arrayBuffer();
writeFileSync(tmpPath, Buffer.from(arrayBuffer));
```

### HeyGen (Upload Asset Pattern â€” No Public URLs Needed)

**WHY THIS APPROACH**: HeyGen requires accessible audio to lip-sync the avatar. Instead of
making our Supabase Storage public or using signed URLs, we use HeyGen's Upload Asset API
to push the audio file directly into HeyGen's internal storage. This is the professional
enterprise pattern â€” our storage stays 100% private, no URLs are ever exposed.

```typescript
// src/lib/video/heygen.ts

/**
 * STRATEGY: Upload audio to HeyGen's asset storage, then reference by asset_id.
 * This avoids ALL public URL requirements. Our Supabase storage stays private.
 *
 * Flow:
 * 1. Download audio from Supabase Storage to /tmp (server-side, using service role key)
 * 2. Upload audio to HeyGen via Upload Asset API â†’ receive audio_asset_id
 * 3. Create video using audio_asset_id (NOT audio_url)
 * 4. Audio in Supabase stays private. HeyGen has its own copy internally.
 */

// Step 1: Download audio from private Supabase Storage to temp file
async function downloadAudioFromSupabase(audioPath: string): Promise<string> {
  const { data, error } = await supabaseAdmin.storage
    .from('remixengine-assets')
    .download(audioPath);
  if (error) throw new Error(`Failed to download audio: ${error.message}`);
  
  const tmpPath = `/tmp/heygen-upload-${nanoid()}.mp3`;
  const buffer = Buffer.from(await data.arrayBuffer());
  writeFileSync(tmpPath, buffer);
  return tmpPath;
}

// Step 2: Upload audio to HeyGen's internal asset storage
async function uploadAudioToHeyGen(filePath: string): Promise<string> {
  const formData = new FormData();
  const fileBuffer = readFileSync(filePath);
  const blob = new Blob([fileBuffer], { type: 'audio/mpeg' });
  formData.append('file', blob, 'scene-audio.mp3');

  const response = await fetch('https://upload.heygen.com/v1/asset', {
    method: 'POST',
    headers: {
      'X-Api-Key': getServerConfig().apiKeys.heyGen,
    },
    body: formData,
  });

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`HeyGen asset upload failed: ${response.status} ${err}`);
  }

  const result = await response.json();
  // Returns: { data: { asset_id: "abc123..." } }
  return result.data.asset_id;
}

// Step 3: Generate avatar video using asset_id (NOT url)
async function generateAvatarVideo(params: {
  audioAssetId: string;
  avatarId: string;
  background: { type: string; value?: string };
  aspectRatio: '16:9' | '9:16';
}): Promise<string> {
  const { audioAssetId, avatarId, background, aspectRatio } = params;
  const dimension = aspectRatio === '16:9'
    ? { width: 1920, height: 1080 }
    : { width: 1080, height: 1920 };

  const response = await fetch('https://api.heygen.com/v2/video/generate', {
    method: 'POST',
    headers: {
      'X-Api-Key': getServerConfig().apiKeys.heyGen,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      video_inputs: [{
        character: {
          type: 'avatar',
          avatar_id: avatarId,
        },
        voice: {
          type: 'audio',
          audio_asset_id: audioAssetId,  // â† ASSET ID, NOT URL
        },
        background: background,
      }],
      dimension,
      callback_url: `${getServerConfig().webhookBaseUrl}/api/remix-engine/webhooks/heygen`,
    }),
  });

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`HeyGen video generation failed: ${response.status} ${err}`);
  }

  const result = await response.json();
  return result.data.video_id;  // Poll or await webhook for completion
}

// Full pipeline per scene:
export async function generateSceneAvatar(scene: Scene, projectSettings: ProjectSettings) {
  const audioPath = scene.audio_file_path; // Supabase Storage path

  // 1. Download from private Supabase to /tmp
  const tmpAudioPath = await downloadAudioFromSupabase(audioPath);

  try {
    // 2. Upload to HeyGen (file transfer: our server â†’ HeyGen, never public)
    const audioAssetId = await uploadAudioToHeyGen(tmpAudioPath);

    // 3. Generate video with asset_id
    const heygenVideoId = await generateAvatarVideo({
      audioAssetId,
      avatarId: projectSettings.avatar_id,
      background: { type: 'color', value: '#0A0A0B' },
      aspectRatio: projectSettings.aspect_ratio,
    });

    // 4. Track in database
    await supabaseAdmin.from('jobs').update({
      status: 'processing',
      result: { heygen_video_id: heygenVideoId, audio_asset_id: audioAssetId },
    }).eq('scene_id', scene.id);

    return heygenVideoId;
  } finally {
    // Always clean up temp file
    unlinkSync(tmpAudioPath);
  }
}
```

### Secure File Delivery Strategy (For ALL External APIs)

The core principle: **Our Supabase Storage stays private. We never generate public URLs.**

| External API | File Delivery Method | How It Works |
|---|---|---|
| **HeyGen** | Upload Asset API â†’ `audio_asset_id` | Push file to HeyGen's storage. Reference by ID. Zero public exposure. |
| **Runway ML** | Signed URL (1-hour expiry) | Runway needs a URL. Generate a Supabase signed URL that auto-expires. Runway fetches it once, URL dies. |
| **fal.ai** | Direct prompt (no file needed) | Text-to-image. No file delivery required. |
| **11Labs** | Text input (no file needed) | Text-to-speech. We send text, receive audio. No file delivery. |
| **Gemini** | Text/base64 input | For thumbnail analysis: convert image to base64 and include inline. No URL needed. |

For Runway ML (the only remaining service that needs a URL):

```typescript
// Runway ML â€” use Supabase signed URL with short expiry
async function getSignedUrlForRunway(storagePath: string): Promise<string> {
  const { data, error } = await supabaseAdmin.storage
    .from('remixengine-assets')
    .createSignedUrl(storagePath, 600); // 10-minute expiry â€” Runway fetches immediately

  if (error) throw new Error(`Signed URL generation failed: ${error.message}`);
  return data.signedUrl;
}

// If even signed URLs feel too exposed, use the API Proxy pattern:
// POST /api/remix-engine/proxy/asset/[token] â€” generates a one-time-use proxy endpoint
// that streams the file from Supabase and self-invalidates after first request.
```

### API Proxy Pattern (Maximum Security â€” Optional)

For teams that want zero external URL exposure, even temporarily:

```typescript
// src/app/api/remix-engine/proxy/asset/[token]/route.ts
// One-time-use proxy that streams a private file and self-destructs

import { supabaseAdmin } from '@/lib/supabase/admin';

// In-memory token store (or Redis for distributed)
const proxyTokens = new Map<string, { path: string; expiresAt: number; used: boolean }>();

export function createProxyToken(storagePath: string, ttlSeconds = 300): string {
  const token = nanoid(32);
  proxyTokens.set(token, {
    path: storagePath,
    expiresAt: Date.now() + ttlSeconds * 1000,
    used: false,
  });
  return `${getServerConfig().webhookBaseUrl}/api/remix-engine/proxy/asset/${token}`;
}

export async function GET(req: Request, { params }: { params: { token: string } }) {
  const entry = proxyTokens.get(params.token);

  // Validate: exists, not expired, not already used
  if (!entry || entry.used || Date.now() > entry.expiresAt) {
    return new Response('Not found', { status: 404 });
  }

  // Mark as used immediately (one-time-use)
  entry.used = true;
  proxyTokens.delete(params.token);

  // Stream file from Supabase
  const { data, error } = await supabaseAdmin.storage
    .from('remixengine-assets')
    .download(entry.path);

  if (error) return new Response('File not found', { status: 404 });

  return new Response(data.stream(), {
    headers: {
      'Content-Type': 'audio/mpeg',
      'Content-Disposition': 'attachment',
      'Cache-Control': 'no-store',
    },
  });
}
```

This gives you a URL like `https://your-app.railway.app/api/remix-engine/proxy/asset/a8f3k2m...`
that works exactly ONCE, expires in 5 minutes, and streams from private storage.
Use this for Runway ML if signed URLs feel too exposed.

### Runway ML

```typescript
const config = getServerConfig();
const response = await fetch('https://api.runwayml.com/v1/image-to-video', {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${config.apiKeys.runwayMl}`, 'Content-Type': 'application/json' },
  body: JSON.stringify({
    prompt: bRollDescription,
    duration: 4,
    ratio: '16:9',
    webhook_url: `${config.webhookBaseUrl}/api/remix-engine/webhooks/runway`,
  })
});
```

---

## 15. COST ESTIMATION ENGINE

```typescript
// src/lib/utils/cost-estimator.ts

export const PRICING = {
  gemini: {
    input_per_1m_tokens: 0.075,
    output_per_1m_tokens: 0.30,
    avg_title_remix_tokens: 2000,     // ~$0.001 per video
    avg_script_remix_tokens: 8000,    // ~$0.003 per video
    avg_thumbnail_analysis_tokens: 3000, // ~$0.001 per video
  },
  fal_ai: {
    per_image: 0.03,
    images_per_video: 3,              // $0.09 per video
  },
  elevenlabs: {
    per_1k_characters: 0.30,
    avg_characters_per_scene: 500,    // ~$0.15 per scene
  },
  heygen: {
    per_minute: 0.10,
    // Each scene ~30s = $0.05 per scene
  },
  runway: {
    per_generation: 0.05,
    // One 4s clip per scene = $0.05 per scene
  },
};

export function estimateProjectCost(scenes: number, avgSceneDuration: number): {
  breakdown: Record<string, number>;
  total: number;
} {
  const breakdown = {
    'Title Remix (Gemini)': PRICING.gemini.avg_title_remix_tokens * PRICING.gemini.output_per_1m_tokens / 1000,
    'Thumbnail (fal.ai)': PRICING.fal_ai.per_image * PRICING.fal_ai.images_per_video,
    'Script Remix (Gemini)': PRICING.gemini.avg_script_remix_tokens * PRICING.gemini.output_per_1m_tokens / 1000,
    'Voiceover (11Labs)': scenes * PRICING.elevenlabs.avg_characters_per_scene * PRICING.elevenlabs.per_1k_characters / 1000,
    'Avatar (HeyGen)': scenes * (avgSceneDuration / 60) * PRICING.heygen.per_minute,
    'B-Roll (Runway)': scenes * PRICING.runway.per_generation,
  };
  const total = Object.values(breakdown).reduce((sum, v) => sum + v, 0);
  return { breakdown, total: Math.round(total * 100) / 100 };
}

// Example: 15 scenes, 30s avg = ~$2.85 per video
```

---

## 16. ERROR HANDLING & RESILIENCE

### Retry Utility

```typescript
// src/lib/utils/retry.ts
import { logger } from '../logger';

export async function withRetry<T>(
  fn: () => Promise<T>,
  opts: { maxRetries?: number; backoffMs?: number; label: string }
): Promise<T> {
  const { maxRetries = 3, backoffMs = 1000, label } = opts;
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error: any) {
      if (attempt === maxRetries) {
        logger.error(`[${label}] All ${maxRetries} attempts failed`, { error: error.message });
        throw error;
      }
      // Don't retry auth errors
      if (error.status === 401 || error.status === 403) throw error;
      const delay = backoffMs * Math.pow(2, attempt - 1) + Math.random() * 500;
      logger.warn(`[${label}] Attempt ${attempt}/${maxRetries} failed, retrying in ${Math.round(delay)}ms`, { error: error.message });
      await new Promise(r => setTimeout(r, delay));
    }
  }
  throw new Error('Unreachable');
}
```

### Dead Letter Handling

Failed jobs after max retries: Update job status to `error` in database. Admin can view failed jobs at `/admin` and retry them manually (which re-enqueues the job). All intermediate assets are preserved â€” retrying doesn't re-scrape or re-remix, only re-runs the failed step.

### Per-User Rate Limiting

```typescript
// src/lib/utils/rate-limiter.ts
// Simple in-memory rate limiter for API routes (reset on deploy)
const rateLimits = new Map<string, { count: number; resetAt: number }>();

export function checkRateLimit(userId: string, maxRequests: number, windowMs: number): boolean {
  const now = Date.now();
  const key = userId;
  const existing = rateLimits.get(key);
  if (!existing || now > existing.resetAt) {
    rateLimits.set(key, { count: 1, resetAt: now + windowMs });
    return true;
  }
  if (existing.count >= maxRequests) return false;
  existing.count++;
  return true;
}

// Usage in API routes:
// if (!checkRateLimit(user.id, 10, 60000)) return rateLimit response
```

---

## 17. LOGGING & OBSERVABILITY

```typescript
// src/lib/logger.ts
import pino from 'pino';

export const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: process.env.NODE_ENV === 'development'
    ? { target: 'pino-pretty', options: { colorize: true, translateTime: 'SYS:HH:MM:ss' } }
    : undefined, // JSON in production (Railway captures stdout)
});

// Create child loggers for each domain:
export const scrapeLogger = logger.child({ module: 'scrape' });
export const remixLogger = logger.child({ module: 'remix' });
export const generateLogger = logger.child({ module: 'generate' });
export const renderLogger = logger.child({ module: 'render' });
export const authLogger = logger.child({ module: 'auth' });

// ALL agents must use domain-specific loggers, not console.log.
// Pattern: logger.info('message', { key: value })
```

**Convention for all agents**: Replace ALL `console.log` with the appropriate domain logger. Every external API call should log: request sent, response received (with status code and timing), error details. Every job should log: started, progress milestones, completed, failed.

---

## 18. DEPLOYMENT CONFIGURATION

### Local Development

```bash
# 1. Clone and install
git clone <repo> && cd remixengine
npm install

# 2. Set up environment
cp .env.example .env.local
# Edit .env.local with your API keys

# 3. Start services
redis-server &
npx supabase start  # Requires Docker

# 4. Run migrations + seed
npx supabase db push
npx supabase db seed

# 5. Sign up first user via UI, then promote to admin:
# psql â†’ UPDATE public.re_users SET role = 'admin' WHERE email = 'you@domain.com';

# 6. Start dev (two terminals)
npm run dev          # Terminal 1: Next.js on :3000
npm run worker:dev   # Terminal 2: BullMQ workers
```

### Railway Deployment (Full Stack)

**3 services in one Railway project:**

1. **Web** (Next.js frontend + API)
2. **Worker** (BullMQ workers)
3. **Redis** (addon)

### Dockerfile (Shared by Web and Worker)

```dockerfile
FROM node:20-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
  ffmpeg \
  python3 \
  python3-pip \
  chromium \
  fonts-liberation \
  libnss3 \
  libatk1.0-0 \
  libatk-bridge2.0-0 \
  libcups2 \
  libdrm2 \
  libxkbcommon0 \
  libxcomposite1 \
  libxdamage1 \
  libxrandr2 \
  libgbm1 \
  libpango-1.0-0 \
  libcairo2 \
  libasound2 \
  && rm -rf /var/lib/apt/lists/*

# Install yt-dlp
RUN pip3 install --break-system-packages yt-dlp

# Set Chromium path for Remotion
ENV CHROMIUM_PATH=/usr/bin/chromium
ENV PUPPETEER_EXECUTABLE_PATH=/usr/bin/chromium

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci --production=false

# Copy source
COPY . .

# Build
RUN npm run build
RUN npm run build:worker

# Default command (overridden per service)
CMD ["npm", "start"]
```

### railway.toml (Web Service)

```toml
[build]
  dockerfilePath = "Dockerfile"

[deploy]
  startCommand = "npm start"
  healthcheckPath = "/api/remix-engine/health"
  healthcheckTimeout = 10
  restartPolicyType = "on_failure"
  numReplicas = 1
```

### worker.railway.toml (Worker Service)

```toml
[build]
  dockerfilePath = "Dockerfile"

[deploy]
  startCommand = "node dist/worker/index.js"
  restartPolicyType = "on_failure"
  numReplicas = 1
```

### package.json Scripts

```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start -p ${PORT:-3000}",
    "build:worker": "tsc --project tsconfig.worker.json",
    "worker:dev": "tsx watch src/worker/index.ts",
    "worker": "node dist/worker/index.js",
    "db:push": "npx supabase db push",
    "db:seed": "npx supabase db seed",
    "db:types": "npx supabase gen types typescript --project-id $SUPABASE_PROJECT_ID > src/lib/supabase/types.ts",
    "lint": "next lint"
  }
}
```

### Railway Environment Variables

Set via Railway dashboard â†’ shared variables:

```
NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY
YOUTUBE_DATA_API_KEY, GOOGLE_GEMINI_API_KEY, FAL_KEY
ELEVENLABS_API_KEY, HEYGEN_API_KEY, RUNWAY_API_KEY, KLING_API_KEY
REDIS_URL=${{redis.REDIS_URL}}
NEXT_PUBLIC_APP_URL=https://<your-web-service>.up.railway.app
WEBHOOK_BASE_URL=https://<your-web-service>.up.railway.app
NODE_ENV=production
LOG_LEVEL=info
CHROMIUM_PATH=/usr/bin/chromium
```

### Estimated Monthly Costs (Railway)

| Resource | Cost |
|----------|------|
| Web service | $5-10 |
| Worker service | $5-15 |
| Redis addon | $3-5 |
| **Railway Total** | **$13-30** |
| Supabase Pro (for large file storage) | $25 |
| **Infrastructure Total** | **$38-55/month** |
| API costs per video (est. 15 scenes) | ~$2-5 |

---

## 19. KNOWN CONSTRAINTS & WORKAROUNDS

| Constraint | Impact | Workaround |
|---|---|---|
| Supabase free tier: 50MB file limit | Can't upload long/HD videos | Use Supabase Pro ($25/mo) or compress to 720p |
| YouTube Captions API requires OAuth | Can't download transcripts via API key | Use yt-dlp `--write-auto-sub` instead |
| HeyGen audio delivery | HeyGen needs accessible audio for lip-sync | Use Upload Asset API â†’ audio_asset_id. Storage stays 100% private. |
| Runway ML file delivery | Runway needs accessible URL for reference images | Use Supabase signed URLs (10-min expiry) or one-time-use API proxy |
| Remotion needs Chromium | Not in default Railway container | Custom Dockerfile installs Chromium |
| Railway ephemeral disk | Files lost on deploy/restart | Always upload to Supabase Storage before cleanup |
| yt-dlp may break when YouTube updates | Video download fails | Pin yt-dlp version, update periodically |
| HeyGen no cancel API | Can't stop generation after submit | Mark as cancelled locally, ignore webhook result |
| 11Labs character limits on free tier | Only ~20 scenes on free | Recommend Creator plan ($22/mo) |
| Runway rate limits | Slow B-roll generation at scale | Auto-fallback to Kling provider |
| Worker path aliases | `@/` doesn't resolve outside Next.js | Separate tsconfig.worker.json with relative paths |
| Concurrent DB writes from parallel workers | Potential race conditions on status updates | Use `UPDATE ... WHERE status = 'expected'` (optimistic locking) |

---

## APPENDIX A: CLAUDE CODE AGENT TEAM CONFIG

Place this as `AGENTS.md` in project root:

```markdown
# RemixEngine Agent Team Configuration

## Orchestrator
You are the conductor of the RemixEngine build. Follow the phase plan but adapt dynamically.

Rules:
- Phases execute in order. Agents within a phase can run in parallel.
- Quality gate: Each phase must produce working, tested code before next phase begins.
- File ownership is STRICT â€” see conflict resolution table in spec.
- ALL agents use pino logger (src/lib/logger.ts), never console.log.
- ALL API routes use the apiHandler wrapper with Zod validation.
- ALL worker handlers clean /tmp in a finally block.
- If an agent is blocked, reassign it to help another agent in the same phase.

## Sub-Agents

### data-scraping-specialist
- FOCUS: src/lib/scraper/**, src/app/api/remix-engine/scrape/**
- TOOLS: yt-dlp (child_process), YouTube Data API v3
- CONSTRAINTS: No OAuth (use yt-dlp for transcripts), max 20min videos, compress >200MB
- TESTS: Scrape a real YouTube URL end-to-end

### title-remixer-specialist
- FOCUS: src/lib/remix/title-*, src/app/api/remix-engine/remix/title/**
- TOOLS: @google/generative-ai (Gemini 2.0 Flash, JSON mode)
- TESTS: Returns valid JSON with 8 title variations matching Zod schema

### thumbnail-remixer-specialist
- FOCUS: src/lib/remix/thumbnail-*, src/app/api/remix-engine/remix/thumbnail/**
- TOOLS: @fal-ai/serverless-client (FLUX model), Gemini Vision for analysis
- TESTS: Generates 3 images at 1280x720, stored in Supabase

### script-remixer-specialist
- FOCUS: src/lib/remix/script-*, scene-splitter, src/app/api/remix-engine/remix/script/**
- TOOLS: @google/generative-ai (Gemini, JSON mode)
- CONSTRAINTS: Scenes must be 15-45s, unique scene_number per script
- TESTS: Returns structured scene breakdown, all scenes have B-roll descriptions

### voiceover-specialist
- FOCUS: src/lib/audio/**, src/app/api/remix-engine/audio/**
- TOOLS: ElevenLabs REST API (direct fetch, NOT npm package)
- TESTS: Generates MP3 per scene, concatenates via FFmpeg

### avatar-video-specialist
- FOCUS: src/lib/video/heygen*, src/app/api/remix-engine/avatar/**, src/app/api/remix-engine/webhooks/heygen/**
- TOOLS: HeyGen REST API
- CONSTRAINTS: Use HeyGen Upload Asset API (audio_asset_id, NOT audio_url). Storage stays private. Implement webhook + polling fallback.
- TESTS: Submits job, receives webhook, downloads video

### broll-specialist
- FOCUS: src/lib/video/runway*, kling*, broll*, src/app/api/remix-engine/broll/**, src/app/api/remix-engine/webhooks/runway/**
- TOOLS: Runway ML REST API, Kling REST API
- CONSTRAINTS: Auto-fallback Runway â†’ Kling on failure
- TESTS: Generates 4s video clip from text prompt

### video-assembly-specialist
- FOCUS: src/lib/video/assembler*, remotion/**, ffmpeg*, src/app/api/remix-engine/render/**
- TOOLS: @remotion/renderer (needs CHROMIUM_PATH), fluent-ffmpeg
- CONSTRAINTS: Normalize all inputs to 1080p 30fps before Remotion. Chromium must be available.
- TESTS: Renders test video from sample assets

### frontend-specialist
- FOCUS: src/app/(dashboard)/**, src/components/** (NOT auth pages, NOT admin pages)
- TOOLS: Next.js, Tailwind, shadcn/ui, Framer Motion, Lucide
- DESIGN: Generate via UUPM skill (`--design-system` flag). Read design-system/MASTER.md before building any page. CSS variables only, prefixed `--re-*`. Zero hardcoded colors.
- CONSTRAINTS: Every async component needs loading/error/empty states. Layout checks `config.mode` â€” only render sidebar/header in standalone.
- TESTS: All pages render, Realtime updates work, video player seeks, module mode renders without shell

### supabase-specialist
- FOCUS: supabase/**, src/lib/supabase/**
- TOOLS: Supabase CLI, PostgreSQL
- CONSTRAINTS: Create admin.ts client for worker (service role key, bypasses RLS)
- TESTS: All migrations run, RLS blocks unauthorized, storage bucket exists

### auth-admin-specialist
- FOCUS: src/lib/auth/**, src/middleware.ts, src/app/(auth)/**, src/app/(dashboard)/admin/**, src/components/admin/**
- TOOLS: @supabase/ssr, Supabase Auth admin API
- CONSTRAINTS: No public signup (invite-only). Require-role check on every API route.
- TESTS: Login, invite flow, role enforcement, admin panel CRUD
```

---

## APPENDIX B: PROJECT DIRECTORY STRUCTURE

```
remixengine/
â”œâ”€â”€ .env.local
â”œâ”€â”€ .env.example
â”œâ”€â”€ .gitignore
â”œâ”€â”€ AGENTS.md
â”œâ”€â”€ README.md
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ railway.toml
â”œâ”€â”€ worker.railway.toml
â”œâ”€â”€ next.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ postcss.config.js
â”œâ”€â”€ tailwind.config.ts
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ tsconfig.worker.json
â”‚
â”œâ”€â”€ # GSD Files (spec-driven development)
â”œâ”€â”€ PROJECT.md
â”œâ”€â”€ REQUIREMENTS.md
â”œâ”€â”€ ROADMAP.md
â”œâ”€â”€ STATE.md
â”œâ”€â”€ REMIXENGINE_SPEC_v2.md          # Full technical spec (source of truth)
â”œâ”€â”€ .planning/                       # GSD planning artifacts (auto-generated)
â”‚
â”œâ”€â”€ # UUPM Design System (generated at build time)
â”œâ”€â”€ design-system/
â”‚   â”œâ”€â”€ MASTER.md                    # Generated by UUPM --design-system
â”‚   â””â”€â”€ pages/                       # Page-specific overrides
â”‚       â”œâ”€â”€ dashboard.md
â”‚       â”œâ”€â”€ projects.md
â”‚       â””â”€â”€ admin.md
â”‚
â”œâ”€â”€ supabase/
â”‚   â”œâ”€â”€ config.toml
â”‚   â”œâ”€â”€ seed.sql
â”‚   â””â”€â”€ migrations/
â”‚       â”œâ”€â”€ 001_initial_schema.sql   # All tables with re_ prefix
â”‚       â”œâ”€â”€ 002_rls_policies.sql
â”‚       â”œâ”€â”€ 003_storage_setup.sql
â”‚       â””â”€â”€ 004_realtime_setup.sql
â”‚
â”œâ”€â”€ public/
â”‚   â””â”€â”€ fonts/
â”‚
â””â”€â”€ src/
    â”œâ”€â”€ app/
    â”‚   â”œâ”€â”€ globals.css              # CSS variables (--re-* prefixed, UUPM defaults)
    â”‚   â”œâ”€â”€ layout.tsx               # Root layout â€” RemixEngineProvider wrapper
    â”‚   â”œâ”€â”€ page.tsx                 # Redirect to /remix-engine/projects
    â”‚   â”œâ”€â”€ not-found.tsx
    â”‚   â”œâ”€â”€ error.tsx
    â”‚   â”œâ”€â”€ (auth)/                  # STANDALONE MODE ONLY
    â”‚   â”‚   â”œâ”€â”€ login/page.tsx
    â”‚   â”‚   â”œâ”€â”€ signup/page.tsx
    â”‚   â”‚   â””â”€â”€ callback/route.ts
    â”‚   â”œâ”€â”€ (dashboard)/
    â”‚   â”‚   â”œâ”€â”€ layout.tsx           # Checks config.mode â€” renders shell or passthrough
    â”‚   â”‚   â”œâ”€â”€ projects/
    â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ new/page.tsx
    â”‚   â”‚   â”‚   â””â”€â”€ [id]/
    â”‚   â”‚   â”‚       â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ scrape/page.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ remix/page.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ generate/page.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ assemble/page.tsx
    â”‚   â”‚   â”‚       â””â”€â”€ review/page.tsx
    â”‚   â”‚   â”œâ”€â”€ batch/
    â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚   â””â”€â”€ [batchId]/page.tsx
    â”‚   â”‚   â””â”€â”€ admin/               # STANDALONE MODE ONLY
    â”‚   â”‚       â”œâ”€â”€ page.tsx
    â”‚   â”‚       â”œâ”€â”€ users/page.tsx
    â”‚   â”‚       â””â”€â”€ settings/page.tsx
    â”‚   â””â”€â”€ api/
    â”‚       â””â”€â”€ remix-engine/        # All API routes namespaced
    â”‚           â”œâ”€â”€ health/route.ts
    â”‚           â”œâ”€â”€ spec.json/route.ts  # Module contract export
    â”‚           â”œâ”€â”€ scrape/
    â”‚           â”œâ”€â”€ remix/
    â”‚           â”œâ”€â”€ audio/
    â”‚           â”œâ”€â”€ avatar/
    â”‚           â”œâ”€â”€ broll/
    â”‚           â”œâ”€â”€ render/
    â”‚           â”œâ”€â”€ projects/
    â”‚           â”œâ”€â”€ admin/
    â”‚           â””â”€â”€ webhooks/
    â”‚               â”œâ”€â”€ heygen/route.ts
    â”‚               â””â”€â”€ runway/route.ts
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ ui/
    â”‚   â”œâ”€â”€ layout/
    â”‚   â”‚   â”œâ”€â”€ Sidebar.tsx          # Only renders in standalone mode
    â”‚   â”‚   â”œâ”€â”€ Header.tsx           # Only renders in standalone mode
    â”‚   â”‚   â””â”€â”€ ThemeProvider.tsx
    â”‚   â”œâ”€â”€ pipeline/
    â”‚   â”œâ”€â”€ scrape/
    â”‚   â”œâ”€â”€ remix/
    â”‚   â”œâ”€â”€ generate/
    â”‚   â”œâ”€â”€ video/
    â”‚   â”œâ”€â”€ admin/
    â”‚   â””â”€â”€ shared/
    â”‚       â”œâ”€â”€ EmptyState.tsx
    â”‚       â”œâ”€â”€ ErrorState.tsx
    â”‚       â”œâ”€â”€ SkeletonLoader.tsx
    â”‚       â””â”€â”€ ConfirmDialog.tsx
    â”œâ”€â”€ lib/
    â”‚   â”œâ”€â”€ remix-engine/
    â”‚   â”‚   â”œâ”€â”€ provider.tsx         # RemixEngineProvider + context + config
    â”‚   â”‚   â”œâ”€â”€ config.ts            # RemixEngineConfig type + createStandaloneConfig()
    â”‚   â”‚   â””â”€â”€ hooks.ts             # useRemixEngine(), table(), storagePath() helpers
    â”‚   â”œâ”€â”€ supabase/
    â”‚   â”‚   â”œâ”€â”€ client.ts            # Browser client (uses config, not env)
    â”‚   â”‚   â”œâ”€â”€ server.ts            # Server client (uses config)
    â”‚   â”‚   â”œâ”€â”€ admin.ts             # Service role client for workers
    â”‚   â”‚   â”œâ”€â”€ middleware.ts
    â”‚   â”‚   â””â”€â”€ types.ts
    â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚   â”œâ”€â”€ auth-context.tsx     # Standalone: own auth. Module: reads from provider.
    â”‚   â”‚   â”œâ”€â”€ auth-guard.tsx
    â”‚   â”‚   â”œâ”€â”€ role-guard.tsx
    â”‚   â”‚   â”œâ”€â”€ require-role.ts
    â”‚   â”‚   â””â”€â”€ auth-actions.ts
    â”‚   â”œâ”€â”€ scraper/
    â”‚   â”œâ”€â”€ remix/
    â”‚   â”œâ”€â”€ audio/
    â”‚   â”œâ”€â”€ video/
    â”‚   â”œâ”€â”€ queue/
    â”‚   â”‚   â”œâ”€â”€ connection.ts
    â”‚   â”‚   â””â”€â”€ queues.ts
    â”‚   â”œâ”€â”€ api/
    â”‚   â”‚   â”œâ”€â”€ response.ts
    â”‚   â”‚   â””â”€â”€ handler.ts
    â”‚   â”œâ”€â”€ validators/
    â”‚   â”‚   â””â”€â”€ schemas.ts
    â”‚   â”œâ”€â”€ utils/
    â”‚   â”‚   â”œâ”€â”€ retry.ts
    â”‚   â”‚   â”œâ”€â”€ cost-estimator.ts
    â”‚   â”‚   â”œâ”€â”€ rate-limiter.ts
    â”‚   â”‚   â””â”€â”€ temp-files.ts
    â”‚   â””â”€â”€ logger.ts
    â”œâ”€â”€ worker/
    â”‚   â”œâ”€â”€ index.ts
    â”‚   â””â”€â”€ handlers/
    â”‚       â”œâ”€â”€ scrape.ts
    â”‚       â”œâ”€â”€ remix.ts
    â”‚       â”œâ”€â”€ generate.ts
    â”‚       â””â”€â”€ render.ts
    â””â”€â”€ middleware.ts                 # Standalone: auth routing. Module: passthrough.
```

---

## APPENDIX C: QUICK START

```bash
npx create-next-app@latest remixengine --typescript --tailwind --app --src-dir --import-alias "@/*"
cd remixengine

npm install @supabase/supabase-js @supabase/ssr @google/generative-ai @fal-ai/serverless-client bullmq ioredis @remotion/core @remotion/renderer @remotion/cli fluent-ffmpeg zod date-fns nanoid framer-motion pino pino-pretty

npx shadcn@latest init
npx shadcn@latest add button card dialog dropdown-menu input label select separator sheet skeleton tabs toast tooltip avatar badge command popover progress scroll-area table textarea

npm install -D @types/fluent-ffmpeg supabase tsx

npx supabase init
npx supabase start
npx supabase db push
```

---

**SPEC VERSION: 3.0 â€” Dual-Mode + GSD + UUPM**

**What changed from v2:**
- Dual-mode architecture (standalone + module) with RemixEngineProvider boundary
- All DB tables prefixed `re_`, all storage paths prefixed `remix-engine/`
- All API routes namespaced under `/api/remix-engine/`
- CSS variables prefixed `--re-*` for collision avoidance in module mode
- Config provider pattern â€” business logic never reads process.env directly
- Layout/auth/admin pages conditional on standalone mode
- Spec export endpoint (`/api/remix-engine/spec.json`) for AI readability
- GSD file set (PROJECT.md, REQUIREMENTS.md, ROADMAP.md, STATE.md) for `/gsd:new-project`
- UUPM design system generated at build time, not hardcoded
- `design-system/` directory for UUPM output with page-specific overrides

**Remaining tradeoffs (accepted for MVP):**
- No automated tests/CI pipeline
- No i18n (English only)
- No mobile optimization below 768px
- Rate limiter is in-memory (resets on deploy)
- Module mode extraction to npm package is V2

**Build standalone. Test standalone. Ship standalone. Extract module when ready.**

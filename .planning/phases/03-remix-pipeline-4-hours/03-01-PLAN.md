---
phase: 03-remix-pipeline-4-hours
plan: 01
type: execute
wave: 1
depends_on:
  - "03-00"
files_modified:
  - package.json
  - src/lib/remix/title-types.ts
  - src/lib/remix/title-prompts.ts
  - src/lib/remix/title-remixer.ts
  - src/lib/remix/script-types.ts
  - src/lib/remix/script-prompts.ts
  - src/lib/remix/script-remixer.ts
autonomous: true
requirements:
  - R3.1
  - R3.3

must_haves:
  truths:
    - "generateTitleVariations() returns exactly 8 validated title objects with style, title, and reasoning fields"
    - "generateRemixedScript() returns a validated script with scenes each having duration 15-45s and unique sequential scene numbers"
    - "Both functions use getServerConfig() for the Gemini API key — zero process.env calls"
    - "Zod validation rejects malformed Gemini responses before they reach the database"
  artifacts:
    - path: "src/lib/remix/title-types.ts"
      provides: "TitleVariationSchema, TitlesResponseSchema, RemixTitleParams Zod schemas"
      exports: ["TitleVariationSchema", "TitlesResponseSchema", "RemixTitleParams"]
    - path: "src/lib/remix/title-remixer.ts"
      provides: "generateTitleVariations function"
      exports: ["generateTitleVariations"]
    - path: "src/lib/remix/script-types.ts"
      provides: "SceneSchema, RemixedScriptSchema, RemixScriptParams Zod schemas"
      exports: ["SceneSchema", "RemixedScriptSchema", "RemixScriptParams"]
    - path: "src/lib/remix/script-remixer.ts"
      provides: "generateRemixedScript function"
      exports: ["generateRemixedScript"]
  key_links:
    - from: "src/lib/remix/title-remixer.ts"
      to: "src/lib/remix-engine/config.ts"
      via: "getServerConfig().apiKeys.gemini"
      pattern: "getServerConfig"
    - from: "src/lib/remix/script-remixer.ts"
      to: "src/lib/remix-engine/config.ts"
      via: "getServerConfig().apiKeys.gemini"
      pattern: "getServerConfig"
---

<objective>
Install Phase 3 dependencies and implement the Gemini-backed title and script remix libraries with full Zod validation.

Purpose: Provides the pure business logic layer for generating 8 categorized title variations and scene-split remixed scripts. These are the core AI functions consumed by the worker handler (Plan 03).

Output: `src/lib/remix/` directory with title and script remixers ready for import.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

Key constraints from STATE.md and CLAUDE.md:
- `getServerConfig()` is the ONLY way to access API keys — never process.env in library code
- Worker imports must use relative paths (no @/ aliases) — these library files will be imported by the worker
- z.record(z.string(), z.any()) required instead of z.record(z.any()) for Zod v3 compat (STATE.md decision)
- All library functions are pure utilities — no cleanup responsibility (scrape handler pattern)

<interfaces>
<!-- Key types the executor needs from the existing codebase. -->

From src/lib/remix-engine/config.ts:
```typescript
export function getServerConfig(): RemixEngineConfig;

interface RemixEngineConfig {
  apiKeys: {
    gemini: string;
    falAi: string;
    // ...
  };
}
```

From src/lib/supabase/types.ts (DB schema reference for field names):
```typescript
// re_remixed_titles
{ id, video_id, style, title, reasoning, is_selected, created_at }

// re_remixed_scripts / re_scenes
{ id, script_id, scene_number, dialogue_line, duration_seconds, broll_description, on_screen_text }
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install packages and create title remix library</name>
  <files>
    package.json
    src/lib/remix/title-types.ts
    src/lib/remix/title-prompts.ts
    src/lib/remix/title-remixer.ts
  </files>
  <action>
**Step 1: Install new packages**
```bash
npm install @google/generative-ai@^0.12 @fal-ai/serverless-client@^0.14
```
These are the ONLY two new packages for Phase 3.

**Step 2: Create `src/lib/remix/title-types.ts`**

Define all Zod schemas for title remix. The 8 styles are an enum — Gemini must return exactly these strings:

```typescript
import { z } from 'zod';

export const TitleStyleSchema = z.enum([
  'Curiosity Gap',
  'Direct Value',
  'Contrarian',
  'Listicle',
  'Question',
  'Emotional Hook',
  'Tutorial',
  'Story-Driven',
]);

export const TitleVariationSchema = z.object({
  style: TitleStyleSchema,
  title: z.string().min(5).max(100),
  reasoning: z.string().min(10).max(500),
});

export const TitlesResponseSchema = z.object({
  variations: z.array(TitleVariationSchema).length(8),
});

export const RemixTitleParamsSchema = z.object({
  originalTitle: z.string().min(1),
  description: z.string(),
  channelName: z.string(),
  videoDuration: z.number().optional(),
});

export type TitleStyle = z.infer<typeof TitleStyleSchema>;
export type TitleVariation = z.infer<typeof TitleVariationSchema>;
export type TitlesResponse = z.infer<typeof TitlesResponseSchema>;
export type RemixTitleParams = z.infer<typeof RemixTitleParamsSchema>;
```

**Step 3: Create `src/lib/remix/title-prompts.ts`**

Build the prompt that instructs Gemini to return exactly 8 variations in JSON mode. The prompt must be explicit about count and field names to minimize schema mismatch:

```typescript
import { RemixTitleParams } from './title-types';

export function buildTitlePrompt(params: RemixTitleParams): string {
  return `You are a YouTube title optimization expert. Create EXACTLY 8 title variations for a video using distinct strategies.

Original title: "${params.originalTitle}"
Channel: "${params.channelName}"
Description: "${params.description.substring(0, 500)}"
${params.videoDuration ? `Duration: ${Math.round(params.videoDuration / 60)} minutes` : ''}

Generate EXACTLY 8 variations — one per style below. Each must:
- Be 5-100 characters
- Be a genuine creative remix preserving core information
- Have exactly three fields: style, title, reasoning

Styles (use EXACTLY these names):
1. "Curiosity Gap" — creates mystery or intrigue, withholds key info
2. "Direct Value" — clear benefit or promise upfront
3. "Contrarian" — challenges conventional wisdom
4. "Listicle" — "N ways", "Top N", numbered format
5. "Question" — provocative question format
6. "Emotional Hook" — triggers fear, excitement, or surprise
7. "Tutorial" — instructional or how-to framing
8. "Story-Driven" — narrative hook that builds tension

CRITICAL: Return EXACTLY 8 objects in "variations" array. One per style. Do not add extra fields. Do not merge styles.`;
}
```

**Step 4: Create `src/lib/remix/title-remixer.ts`**

Implement `generateTitleVariations()` with Gemini JSON mode and Zod validation. Use `getServerConfig()` — not process.env. Log the raw response before parsing so schema mismatches are debuggable. Wrap Zod parse in try-catch and re-throw with context:

```typescript
import { GoogleGenerativeAI } from '@google/generative-ai';
import { z } from 'zod';
import { getServerConfig } from '../remix-engine/config';
import { TitlesResponseSchema, RemixTitleParams } from './title-types';
import { buildTitlePrompt } from './title-prompts';

export async function generateTitleVariations(
  params: RemixTitleParams
): Promise<z.infer<typeof TitlesResponseSchema>> {
  const config = getServerConfig();
  const genAI = new GoogleGenerativeAI(config.apiKeys.gemini);
  const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

  const prompt = buildTitlePrompt(params);

  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }],
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.8,
      topP: 0.95,
      topK: 40,
    },
  });

  const text = result.response.text();

  let parsed: unknown;
  try {
    parsed = JSON.parse(text);
  } catch {
    throw new Error(`Gemini returned invalid JSON for title generation. Raw: ${text.substring(0, 200)}`);
  }

  try {
    return TitlesResponseSchema.parse(parsed);
  } catch (err) {
    if (err instanceof z.ZodError) {
      throw new Error(`Title schema validation failed: ${err.message}. Raw: ${JSON.stringify(parsed).substring(0, 200)}`);
    }
    throw err;
  }
}
```

Note: This file uses `../remix-engine/config` (relative) so it works from both Next.js (`@/lib/remix/`) and worker (relative import). The worker imports will need to use relative paths from the handler file.
  </action>
  <verify>
    <automated>npx tsc --noEmit && npm run test -- src/lib/remix/__tests__/title-remixer.test.ts --watchAll=false</automated>
  </verify>
  <done>
    - `@google/generative-ai` and `@fal-ai/serverless-client` in package.json
    - `src/lib/remix/title-types.ts` exports TitleVariationSchema, TitlesResponseSchema, RemixTitleParams
    - `src/lib/remix/title-prompts.ts` exports buildTitlePrompt
    - `src/lib/remix/title-remixer.ts` exports generateTitleVariations
    - `npx tsc --noEmit` passes with zero errors
    - `src/lib/remix/__tests__/title-remixer.test.ts` passes (all 5 tests GREEN)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create script remix library</name>
  <files>
    src/lib/remix/script-types.ts
    src/lib/remix/script-prompts.ts
    src/lib/remix/script-remixer.ts
  </files>
  <action>
**Step 1: Create `src/lib/remix/script-types.ts`**

Scene duration is in seconds, validated 15-45 per requirement R3.3. Scene numbers are validated sequential (application layer — DB constraint enforces uniqueness at DB layer). Include broll_description (required) and on_screen_text (optional):

```typescript
import { z } from 'zod';

export const SceneSchema = z.object({
  scene_number: z.number().int().min(1),
  dialogue_line: z.string().min(1),
  duration_seconds: z.number().int().min(15).max(45),
  broll_description: z.string().min(5),
  on_screen_text: z.string().optional(),
});

export const RemixedScriptSchema = z.object({
  scenes: z.array(SceneSchema).min(1),
  tone: z.string().optional(),
  target_audience: z.string().optional(),
});

export const RemixScriptParamsSchema = z.object({
  originalTitle: z.string().min(1),
  originalTranscript: z.string().min(1),
  channelName: z.string(),
  targetDurationSeconds: z.number().optional(), // e.g. 120 for 2-minute target
});

export type Scene = z.infer<typeof SceneSchema>;
export type RemixedScript = z.infer<typeof RemixedScriptSchema>;
export type RemixScriptParams = z.infer<typeof RemixScriptParamsSchema>;
```

**Step 2: Create `src/lib/remix/script-prompts.ts`**

The prompt must instruct Gemini to output scenes with strict 15-45s duration estimates. Scene numbers must be sequential starting from 1. Include explicit JSON structure:

```typescript
import { RemixScriptParams } from './script-types';

export function buildScriptPrompt(params: RemixScriptParams): string {
  const transcriptPreview = params.originalTranscript.substring(0, 2000);
  return `You are a YouTube script editor. Rewrite this video content as an engaging script split into scenes.

Original title: "${params.originalTitle}"
Channel: "${params.channelName}"
${params.targetDurationSeconds ? `Target total duration: ~${Math.round(params.targetDurationSeconds / 60)} minutes` : ''}

Original transcript:
${transcriptPreview}

Rewrite this as a remixed script with these rules:
1. Split into scenes. Each scene: 15-45 seconds of spoken dialogue (estimate: ~150 words/min)
2. Scene numbers start at 1 and increase sequentially — no gaps, no duplicates
3. Each scene needs a broll_description: what visual footage would play (e.g. "Close-up of hands typing on keyboard")
4. duration_seconds must be an integer between 15 and 45
5. Keep the core information but improve pacing, hook, and engagement

Return valid JSON with this exact structure:
{
  "tone": "energetic and direct",
  "target_audience": "software developers",
  "scenes": [
    {
      "scene_number": 1,
      "dialogue_line": "spoken dialogue text for this scene",
      "duration_seconds": 25,
      "broll_description": "visual footage description",
      "on_screen_text": "optional text overlay or null"
    }
  ]
}

CRITICAL: scene_number must start at 1 and be sequential. duration_seconds must be 15-45. Do not include scene_number gaps.`;
}
```

**Step 3: Create `src/lib/remix/script-remixer.ts`**

Implement `generateRemixedScript()`. After Zod validation, verify scene numbers are sequential (application-layer check before DB insert). If any scene duration is outside 15-45s range despite Zod validation catching it, that's already handled by the schema. Log scene count on success:

```typescript
import { GoogleGenerativeAI } from '@google/generative-ai';
import { z } from 'zod';
import { getServerConfig } from '../remix-engine/config';
import { RemixedScriptSchema, RemixScriptParams } from './script-types';
import { buildScriptPrompt } from './script-prompts';

export async function generateRemixedScript(
  params: RemixScriptParams
): Promise<z.infer<typeof RemixedScriptSchema>> {
  const config = getServerConfig();
  const genAI = new GoogleGenerativeAI(config.apiKeys.gemini);
  const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

  const prompt = buildScriptPrompt(params);

  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }],
    generationConfig: {
      responseMimeType: 'application/json',
      temperature: 0.7,
      topP: 0.9,
      topK: 40,
    },
  });

  const text = result.response.text();

  let parsed: unknown;
  try {
    parsed = JSON.parse(text);
  } catch {
    throw new Error(`Gemini returned invalid JSON for script generation. Raw: ${text.substring(0, 200)}`);
  }

  let validated: z.infer<typeof RemixedScriptSchema>;
  try {
    validated = RemixedScriptSchema.parse(parsed);
  } catch (err) {
    if (err instanceof z.ZodError) {
      throw new Error(`Script schema validation failed: ${err.message}`);
    }
    throw err;
  }

  // Application-layer: enforce sequential scene numbers starting at 1
  validated.scenes.forEach((scene, idx) => {
    if (scene.scene_number !== idx + 1) {
      throw new Error(
        `Scene numbers must be sequential starting at 1. Got scene_number ${scene.scene_number} at position ${idx + 1}`
      );
    }
  });

  return validated;
}
```
  </action>
  <verify>
    <automated>npx tsc --noEmit && npm run test -- src/lib/remix/__tests__/script-remixer.test.ts --watchAll=false</automated>
  </verify>
  <done>
    - `src/lib/remix/script-types.ts` exports SceneSchema, RemixedScriptSchema, RemixScriptParams
    - `src/lib/remix/script-prompts.ts` exports buildScriptPrompt
    - `src/lib/remix/script-remixer.ts` exports generateRemixedScript with sequential scene number validation
    - `npx tsc --noEmit` passes with zero errors
    - `src/lib/remix/__tests__/script-remixer.test.ts` passes (all 4 tests GREEN)
  </done>
</task>

</tasks>

<verification>
```bash
npx tsc --noEmit
npm run lint
npm run test -- src/lib/remix/__tests__/title-remixer.test.ts src/lib/remix/__tests__/script-remixer.test.ts --watchAll=false
```
All must pass with zero errors after this plan.
</verification>

<success_criteria>
- `src/lib/remix/` directory exists with 6 files (title-types, title-prompts, title-remixer, script-types, script-prompts, script-remixer)
- Both `generateTitleVariations` and `generateRemixedScript` are exported and TypeScript-clean
- Zod schemas enforce exact shapes (8-length array for titles, 15-45s duration for scenes)
- Zero TypeScript errors (`npx tsc --noEmit`)
- No process.env in any of these files — only `getServerConfig()`
- `title-remixer.test.ts` and `script-remixer.test.ts` all tests GREEN
</success_criteria>

<output>
After completion, create `.planning/phases/03-remix-pipeline-4-hours/03-01-SUMMARY.md`
</output>

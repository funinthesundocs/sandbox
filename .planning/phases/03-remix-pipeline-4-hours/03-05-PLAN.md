---
phase: 03-remix-pipeline-4-hours
plan: 05
type: execute
wave: 4
depends_on:
  - "03-00"
  - "03-03"
  - "03-04"
files_modified:
  - src/components/remix/RemixReviewPage.tsx
  - src/components/remix/TitleGrid.tsx
  - src/components/remix/ThumbnailCards.tsx
  - src/components/remix/SceneEditor.tsx
  - src/components/remix/ApprovalGate.tsx
  - src/app/(dashboard)/projects/[id]/videos/[videoId]/remix/page.tsx
autonomous: true
requirements:
  - R3.4
  - R3.5
  - R3.6

must_haves:
  truths:
    - "8 title cards display in a 2-column grid; each card shows title text and its category label"
    - "Selecting a title card marks it as selected (radio pattern) and the card becomes inline-editable"
    - "3 thumbnail image cards display side-by-side (stacking on mobile); each has a per-thumbnail regenerate icon"
    - "Script scenes display as stacked cards showing scene number, estimated duration badge, and dialogue text"
    - "Scene dialogue text becomes a textarea on click and saves on blur via PATCH /api/remix-engine/remix/select"
    - "Sticky approval bar shows Title selected / Thumbnail selected / Script reviewed checkmarks; Approve button disabled until all 3 are checked"
    - "Clicking Approve opens a confirmation dialog summarizing: selected title text, thumbnail number, scene count"
    - "Confirming the dialog marks video as approved (updates DB) and the Generation tab becomes unlocked"
  artifacts:
    - path: "src/components/remix/RemixReviewPage.tsx"
      provides: "Main client component orchestrating all review sections and approval state"
      exports: ["RemixReviewPage"]
    - path: "src/components/remix/TitleGrid.tsx"
      provides: "2-column title card grid with radio selection and inline edit"
      exports: ["TitleGrid"]
    - path: "src/components/remix/ThumbnailCards.tsx"
      provides: "3-card thumbnail display with signed URLs and per-thumbnail regenerate"
      exports: ["ThumbnailCards"]
    - path: "src/components/remix/SceneEditor.tsx"
      provides: "Stacked scene cards with inline dialogue editing and per-scene regenerate"
      exports: ["SceneEditor"]
    - path: "src/components/remix/ApprovalGate.tsx"
      provides: "Sticky checklist + Approve button + confirmation dialog"
      exports: ["ApprovalGate"]
  key_links:
    - from: "src/components/remix/RemixReviewPage.tsx"
      to: "/api/remix-engine/remix/select"
      via: "fetch POST on title/thumbnail selection"
      pattern: "fetch.*remix.*select"
    - from: "src/components/remix/SceneEditor.tsx"
      to: "/api/remix-engine/remix/select"
      via: "fetch PATCH on scene dialogue edit"
      pattern: "fetch.*remix.*select"
    - from: "src/components/remix/ApprovalGate.tsx"
      to: "/api/remix-engine/videos/[videoId]/approve"
      via: "fetch POST on confirm dialog"
      pattern: "fetch.*approve"
---

<objective>
Build the full Remix Review interactive UI: title grid with inline editing, thumbnail cards with regeneration, script scene editor, and the sticky approval gate with confirmation dialog.

Purpose: This is the primary user-facing deliverable of Phase 3. After this plan, users can select titles, thumbnails, and review scenes before approving the pipeline to continue.

Output: 5 React client components + remix page updated to use RemixReviewPage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@design-system/MASTER.md
@.planning/phases/03-remix-pipeline-4-hours/03-CONTEXT.md

Read CONTEXT.md locked decisions carefully. Every UI detail comes from there.

Read design-system/MASTER.md before writing any component styles. Use `--re-*` CSS variables exclusively.

Key locked decisions from CONTEXT.md:
- 2-column title card grid, radio-style cards; selected card is inline-editable
- 3 thumbnail cards side-by-side (stacks on mobile); per-thumbnail regenerate icon
- Stacked scene cards: scene number, estimated duration, dialogue text only (no on-screen text field in this phase)
- Scene text inline-editable on click (textarea, saves on blur)
- Sticky checklist: Title selected / Thumbnail selected / Script reviewed — Approve disabled until all 3 checked
- Confirmation dialog: shows title text, thumbnail number, scene count
- Character count on inline title edit (Claude's discretion)
- "Script reviewed" = simply having a script present (Claude's discretion)

Key from RESEARCH.md:
- inline edit saves selection AND text in one API call (POST /select with editedText)
- Editing title text does NOT auto-select; user must click the radio/card first
- Approve endpoint to create: POST /api/remix-engine/videos/[videoId]/approve

<interfaces>
<!-- Types and contracts the executor needs -->

Approval endpoint to implement (not yet created — create it in this plan):
POST /api/remix-engine/videos/[videoId]/approve
- Auth required
- Verifies is_selected=true exists for title, thumbnail, script
- Updates re_videos: { remix_status stays 'complete', generation_status: 'pending' (unlocks Generation tab visually via re-fetch) }
- Returns { success: true, videoId }

From src/app/(dashboard)/projects/[id]/videos/[videoId]/remix/page.tsx (Plan 04 output):
```typescript
// Page fetches and passes:
titles: Array<{ id, style, title, reasoning, is_selected }>
thumbnailsWithUrls: Array<{ id, prompt, file_path, is_selected, signedUrl: string | null }>
scripts: Array<{ id, full_script, tone, total_duration_seconds, is_selected, re_scenes: Scene[] }>
scenes: Scene[]  // from scripts[0].re_scenes

type Scene = { id, script_id, scene_number, dialogue_line, duration_seconds, broll_description }
```

Select API (Plan 03 output):
```
POST /api/remix-engine/remix/select
Body: { videoId, type: 'title'|'thumbnail'|'script', id, editedText?: string }
Returns: { success: true }

PATCH /api/remix-engine/remix/select
Body: { sceneId, dialogueLine }
Returns: { success: true }
```

Regenerate APIs (Plan 03 output):
```
POST /api/remix-engine/remix/title    — { videoId, projectId }
POST /api/remix-engine/remix/thumbnail — { videoId, projectId, style?, stylePromptOverride? }
POST /api/remix-engine/remix/script   — { videoId, projectId }
```

shadcn/ui components available (from src/components/ui/):
button, input, label, dropdown-menu, tooltip, avatar, separator
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create approval endpoint and title+thumbnail UI components</name>
  <files>
    src/app/api/remix-engine/videos/[videoId]/approve/route.ts
    src/components/remix/TitleGrid.tsx
    src/components/remix/ThumbnailCards.tsx
  </files>
  <action>
**Step 1: Create `src/app/api/remix-engine/videos/[videoId]/approve/route.ts`**

Verifies all 3 selections exist before marking approved. The video stays in 'remixed' state — this just unlocks the generation tab by confirming readiness. Do NOT start generation — that's Phase 4:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

export async function POST(
  _req: NextRequest,
  { params }: { params: Promise<{ videoId: string }> }
) {
  const { videoId } = await params;

  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  // Verify all selections exist
  const [titlesResult, thumbsResult, scriptsResult] = await Promise.all([
    supabase.from('re_remixed_titles').select('id').eq('video_id', videoId).eq('is_selected', true),
    supabase.from('re_remixed_thumbnails').select('id').eq('video_id', videoId).eq('is_selected', true),
    supabase.from('re_remixed_scripts').select('id').eq('video_id', videoId),
  ]);

  const hasTitle = (titlesResult.data?.length ?? 0) > 0;
  const hasThumbnail = (thumbsResult.data?.length ?? 0) > 0;
  const hasScript = (scriptsResult.data?.length ?? 0) > 0;

  if (!hasTitle || !hasThumbnail || !hasScript) {
    return NextResponse.json(
      { error: 'Title, thumbnail, and script must all be selected before approving' },
      { status: 422 }
    );
  }

  // Mark video as remix-approved (generation_status unlocks Generation tab)
  // generation_status moves from 'pending' to 'queued' (or we use a separate approved boolean)
  // Use generation_status: 'pending' stays BUT we can check on frontend if approved
  // Store approval as metadata — update remix_status to a new conceptual state isn't in the enum
  // The correct approach per spec: pipeline_status tracks this. re_videos has remix_status + generation_status.
  // Set generation_status: 'pending' is ALREADY the default. To unlock visually, we can use a different approach:
  // Store in re_system_settings or just trust is_selected state for the UI gate.
  // Simplest correct approach: do nothing server-side beyond validation.
  // The Generation tab unlocks in PipelineTabs when remix_status='complete' AND user has selected items.
  // Return success — client navigates away or refreshes.

  return NextResponse.json({ success: true, videoId });
}
```

Note: The unlock signal is the presence of selections (is_selected=true) — the Generation tab can check this on the server side in its page. This avoids needing a new DB column.

**Step 2: Create `src/components/remix/TitleGrid.tsx`** (client component)

2-column grid of 8 radio-style cards. Locked decision: selected card is inline-editable. Clicking a non-selected card: selects it (POST /select). If card is already selected, the title text is an editable input (saves on blur via POST /select with editedText). Show character count on the input (Claude's discretion).

Per RESEARCH.md Pitfall 4: editing text does NOT auto-select. Selection is by clicking the card. The edit field only appears after the card is selected:

```tsx
'use client';

import { useState } from 'react';
import { RefreshCw } from 'lucide-react';

interface Title {
  id: string;
  style: string;
  title: string;
  reasoning: string | null;
  is_selected: boolean;
}

interface TitleGridProps {
  titles: Title[];
  videoId: string;
  projectId: string;
  onSelectionChange: (selectedId: string) => void;
  onRegenerate: () => void;
}

export function TitleGrid({ titles, videoId, projectId, onSelectionChange, onRegenerate }: TitleGridProps) {
  const [selectedId, setSelectedId] = useState<string | null>(
    titles.find((t) => t.is_selected)?.id ?? null
  );
  const [editValues, setEditValues] = useState<Record<string, string>>(
    Object.fromEntries(titles.map((t) => [t.id, t.title]))
  );
  const [loading, setLoading] = useState<string | null>(null);
  const [regenLoading, setRegenLoading] = useState<string | null>(null);

  async function selectTitle(id: string) {
    if (loading) return;
    setLoading(id);
    setSelectedId(id);

    try {
      await fetch('/api/remix-engine/remix/select', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ videoId, type: 'title', id }),
      });
      onSelectionChange(id);
    } finally {
      setLoading(null);
    }
  }

  async function saveEditedTitle(id: string) {
    const text = editValues[id];
    if (!text?.trim()) return;
    await fetch('/api/remix-engine/remix/select', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ videoId, type: 'title', id, editedText: text }),
    });
  }

  async function regenTitle(id: string) {
    setRegenLoading(id);
    try {
      await fetch('/api/remix-engine/remix/title', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ videoId, projectId }),
      });
      onRegenerate();
    } finally {
      setRegenLoading(null);
    }
  }

  return (
    <div>
      <h2 className="font-semibold mb-3" style={{ fontSize: 'var(--re-text-lg)', color: 'var(--re-text-primary)' }}>
        Title Variations
      </h2>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
        {titles.map((title) => {
          const isSelected = selectedId === title.id;
          return (
            <div
              key={title.id}
              onClick={() => !isSelected && selectTitle(title.id)}
              className="relative rounded-lg p-4 cursor-pointer transition-all"
              style={{
                background: isSelected ? 'var(--re-bg-selected, var(--re-bg-card))' : 'var(--re-bg-card)',
                border: `1.5px solid ${isSelected ? 'var(--re-accent-primary)' : 'var(--re-border-default)'}`,
                opacity: loading === title.id ? 0.7 : 1,
              }}
            >
              {/* Style label + regen */}
              <div className="flex items-center justify-between mb-2">
                <span
                  className="text-xs font-medium px-2 py-0.5 rounded"
                  style={{ background: 'var(--re-bg-hover)', color: 'var(--re-text-muted)' }}
                >
                  {title.style}
                </span>
                <button
                  onClick={(e) => { e.stopPropagation(); regenTitle(title.id); }}
                  disabled={regenLoading === title.id}
                  className="p-1 rounded transition-colors hover:bg-[--re-bg-hover]"
                  style={{ color: 'var(--re-text-muted)' }}
                  title="Regenerate all titles"
                >
                  <RefreshCw className={`w-3.5 h-3.5 ${regenLoading === title.id ? 'animate-spin' : ''}`} />
                </button>
              </div>

              {/* Title text — editable if selected */}
              {isSelected ? (
                <div>
                  <textarea
                    value={editValues[title.id]}
                    onChange={(e) => setEditValues((prev) => ({ ...prev, [title.id]: e.target.value }))}
                    onBlur={() => saveEditedTitle(title.id)}
                    onClick={(e) => e.stopPropagation()}
                    rows={2}
                    maxLength={100}
                    className="w-full resize-none rounded p-1 text-sm font-medium focus:outline-none"
                    style={{ background: 'var(--re-bg-input, var(--re-bg-hover))', color: 'var(--re-text-primary)', border: '1px solid var(--re-border-focus, var(--re-accent-primary))' }}
                  />
                  <div className="text-right text-xs mt-0.5" style={{ color: 'var(--re-text-muted)' }}>
                    {editValues[title.id]?.length ?? 0}/100
                  </div>
                </div>
              ) : (
                <p className="text-sm font-medium leading-snug" style={{ color: 'var(--re-text-primary)' }}>
                  {title.title}
                </p>
              )}

              {/* Selected indicator */}
              {isSelected && (
                <div
                  className="absolute top-3 right-3 w-4 h-4 rounded-full flex items-center justify-center"
                  style={{ background: 'var(--re-accent-primary)' }}
                >
                  <svg className="w-2.5 h-2.5 text-white" fill="currentColor" viewBox="0 0 12 12">
                    <path d="M10 3L5 8.5 2 5.5" stroke="currentColor" strokeWidth="1.5" fill="none" strokeLinecap="round" strokeLinejoin="round"/>
                  </svg>
                </div>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

**Step 3: Create `src/components/remix/ThumbnailCards.tsx`** (client component)

3 cards side-by-side. Locked decision: collapses to stack on mobile. Per-thumbnail regenerate icon with optional style prompt input (Claude's discretion: show a small input below the regenerate icon that appears on click):

```tsx
'use client';

import { useState } from 'react';
import Image from 'next/image';
import { RefreshCw, Check } from 'lucide-react';

interface Thumbnail {
  id: string;
  prompt: string;
  file_path: string;
  is_selected: boolean;
  signedUrl: string | null;
}

interface ThumbnailCardsProps {
  thumbnails: Thumbnail[];
  videoId: string;
  projectId: string;
  onSelectionChange: (selectedId: string) => void;
}

export function ThumbnailCards({ thumbnails, videoId, projectId, onSelectionChange }: ThumbnailCardsProps) {
  const [selectedId, setSelectedId] = useState<string | null>(
    thumbnails.find((t) => t.is_selected)?.id ?? null
  );
  const [regenLoading, setRegenLoading] = useState<string | null>(null);
  const [stylePrompts, setStylePrompts] = useState<Record<string, string>>({});
  const [showPromptFor, setShowPromptFor] = useState<string | null>(null);

  async function selectThumbnail(id: string) {
    setSelectedId(id);
    await fetch('/api/remix-engine/remix/select', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ videoId, type: 'thumbnail', id }),
    });
    onSelectionChange(id);
  }

  async function regenThumbnail(id: string) {
    const thumb = thumbnails.find((t) => t.id === id);
    if (!thumb) return;
    setRegenLoading(id);
    setShowPromptFor(null);
    try {
      // Extract style from file_path (e.g. "...thumbnails/bold_text_overlay.jpg" → "bold-text-overlay")
      const styleMatch = thumb.file_path.match(/thumbnails\/([\w]+)\.jpg/);
      const styleSlug = styleMatch?.[1]?.replace(/_/g, '-') ?? undefined;

      await fetch('/api/remix-engine/remix/thumbnail', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          videoId, projectId,
          style: styleSlug,
          stylePromptOverride: stylePrompts[id] || undefined,
        }),
      });
    } finally {
      setRegenLoading(null);
    }
  }

  if (thumbnails.length === 0) {
    return (
      <div>
        <h2 className="font-semibold mb-3" style={{ fontSize: 'var(--re-text-lg)', color: 'var(--re-text-primary)' }}>
          Thumbnail Variations
        </h2>
        <p className="text-sm" style={{ color: 'var(--re-text-muted)' }}>Thumbnails are generating...</p>
      </div>
    );
  }

  return (
    <div>
      <h2 className="font-semibold mb-3" style={{ fontSize: 'var(--re-text-lg)', color: 'var(--re-text-primary)' }}>
        Thumbnail Variations
      </h2>
      <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
        {thumbnails.map((thumb, idx) => {
          const isSelected = selectedId === thumb.id;
          return (
            <div
              key={thumb.id}
              className="relative group cursor-pointer rounded-lg overflow-hidden"
              style={{ border: `2px solid ${isSelected ? 'var(--re-accent-primary)' : 'var(--re-border-default)'}` }}
              onClick={() => selectThumbnail(thumb.id)}
            >
              {/* Thumbnail image */}
              <div className="relative aspect-video bg-[--re-bg-hover]">
                {thumb.signedUrl ? (
                  <Image
                    src={thumb.signedUrl}
                    alt={`Thumbnail variation ${idx + 1}`}
                    fill
                    className="object-cover"
                    unoptimized // Signed URLs change frequently
                  />
                ) : (
                  <div className="absolute inset-0 flex items-center justify-center">
                    <span className="text-xs" style={{ color: 'var(--re-text-muted)' }}>Loading...</span>
                  </div>
                )}

                {/* Selected overlay */}
                {isSelected && (
                  <div
                    className="absolute inset-0 flex items-center justify-center"
                    style={{ background: 'rgba(0,0,0,0.25)' }}
                  >
                    <div
                      className="w-8 h-8 rounded-full flex items-center justify-center"
                      style={{ background: 'var(--re-accent-primary)' }}
                    >
                      <Check className="w-5 h-5 text-white" />
                    </div>
                  </div>
                )}
              </div>

              {/* Thumbnail label + regen controls */}
              <div
                className="px-3 py-2"
                style={{ background: 'var(--re-bg-card)' }}
              >
                <div className="flex items-center justify-between">
                  <span className="text-xs" style={{ color: 'var(--re-text-muted)' }}>Variation {idx + 1}</span>
                  <div className="flex items-center gap-1">
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        setShowPromptFor(showPromptFor === thumb.id ? null : thumb.id);
                      }}
                      className="p-1 rounded transition-colors hover:bg-[--re-bg-hover]"
                      style={{ color: 'var(--re-text-muted)', fontSize: '10px' }}
                      title="Style options"
                    >
                      Style
                    </button>
                    <button
                      onClick={(e) => { e.stopPropagation(); regenThumbnail(thumb.id); }}
                      disabled={regenLoading === thumb.id}
                      className="p-1 rounded transition-colors hover:bg-[--re-bg-hover]"
                      style={{ color: 'var(--re-text-muted)' }}
                      title="Regenerate this thumbnail"
                    >
                      <RefreshCw className={`w-3.5 h-3.5 ${regenLoading === thumb.id ? 'animate-spin' : ''}`} />
                    </button>
                  </div>
                </div>

                {/* Optional style prompt input */}
                {showPromptFor === thumb.id && (
                  <div className="mt-2" onClick={(e) => e.stopPropagation()}>
                    <input
                      type="text"
                      placeholder="e.g. darker, more dramatic..."
                      value={stylePrompts[thumb.id] ?? ''}
                      onChange={(e) => setStylePrompts((prev) => ({ ...prev, [thumb.id]: e.target.value }))}
                      className="w-full text-xs rounded px-2 py-1"
                      style={{
                        background: 'var(--re-bg-input, var(--re-bg-hover))',
                        color: 'var(--re-text-primary)',
                        border: '1px solid var(--re-border-default)',
                      }}
                      onKeyDown={(e) => { if (e.key === 'Enter') regenThumbnail(thumb.id); }}
                    />
                  </div>
                )}
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
}
```
  </action>
  <verify>
    <automated>npx tsc --noEmit && npm run test -- src/app/api/remix-engine/__tests__/gate.test.ts --watchAll=false</automated>
  </verify>
  <done>
    - `src/app/api/remix-engine/videos/[videoId]/approve/route.ts` exports POST, verifies selections before approving
    - `src/components/remix/TitleGrid.tsx` renders 2-col grid, radio selection, inline edit on selected card, per-title regen
    - `src/components/remix/ThumbnailCards.tsx` renders 3 cards side-by-side (responsive), selection, per-thumbnail regen with style prompt
    - TypeScript compiles clean
    - `gate.test.ts` passes (401 unauth, 422 when title missing, 200 when all selections present)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SceneEditor, ApprovalGate, RemixReviewPage and wire to remix page</name>
  <files>
    src/components/remix/SceneEditor.tsx
    src/components/remix/ApprovalGate.tsx
    src/components/remix/RemixReviewPage.tsx
    src/app/(dashboard)/projects/[id]/videos/[videoId]/remix/page.tsx
  </files>
  <action>
**Step 1: Create `src/components/remix/SceneEditor.tsx`**

Stacked scene cards. Locked decisions: scene number, duration badge, dialogue text only. Click dialogue → textarea, blur → save via PATCH. Per-scene regenerate (queues a new script job — full script regenerates). Full-script regenerate button at top:

```tsx
'use client';

import { useState, useRef } from 'react';
import { RefreshCw } from 'lucide-react';

interface Scene {
  id: string;
  scene_number: number;
  dialogue_line: string;
  duration_seconds: number;
  broll_description: string;
}

interface SceneEditorProps {
  scenes: Scene[];
  videoId: string;
  projectId: string;
  onRegenerate: () => void;
}

export function SceneEditor({ scenes, videoId, projectId, onRegenerate }: SceneEditorProps) {
  const [editValues, setEditValues] = useState<Record<string, string>>(
    Object.fromEntries(scenes.map((s) => [s.id, s.dialogue_line]))
  );
  const [editingId, setEditingId] = useState<string | null>(null);
  const [regenLoading, setRegenLoading] = useState(false);
  const textareaRefs = useRef<Record<string, HTMLTextAreaElement | null>>({});

  async function saveScene(sceneId: string) {
    const text = editValues[sceneId];
    if (!text?.trim()) return;
    await fetch('/api/remix-engine/remix/select', {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sceneId, dialogueLine: text }),
    });
    setEditingId(null);
  }

  async function regenScript() {
    setRegenLoading(true);
    try {
      await fetch('/api/remix-engine/remix/script', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ videoId, projectId }),
      });
      onRegenerate();
    } finally {
      setRegenLoading(false);
    }
  }

  if (scenes.length === 0) {
    return (
      <div>
        <h2 className="font-semibold mb-3" style={{ fontSize: 'var(--re-text-lg)', color: 'var(--re-text-primary)' }}>
          Script Scenes
        </h2>
        <p className="text-sm" style={{ color: 'var(--re-text-muted)' }}>Script is generating...</p>
      </div>
    );
  }

  return (
    <div>
      <div className="flex items-center justify-between mb-3">
        <h2 className="font-semibold" style={{ fontSize: 'var(--re-text-lg)', color: 'var(--re-text-primary)' }}>
          Script Scenes
        </h2>
        <button
          onClick={regenScript}
          disabled={regenLoading}
          className="flex items-center gap-1.5 text-xs px-3 py-1.5 rounded transition-colors"
          style={{
            background: 'var(--re-bg-card)',
            border: '1px solid var(--re-border-default)',
            color: 'var(--re-text-secondary)',
          }}
        >
          <RefreshCw className={`w-3 h-3 ${regenLoading ? 'animate-spin' : ''}`} />
          Regenerate full script
        </button>
      </div>

      <div className="space-y-3">
        {scenes.map((scene) => {
          const isEditing = editingId === scene.id;
          return (
            <div
              key={scene.id}
              className="rounded-lg p-4"
              style={{ background: 'var(--re-bg-card)', border: '1px solid var(--re-border-default)' }}
            >
              {/* Scene header: number + duration + per-scene regen */}
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center gap-2">
                  <span
                    className="text-xs font-mono font-medium px-2 py-0.5 rounded"
                    style={{ background: 'var(--re-bg-hover)', color: 'var(--re-text-secondary)' }}
                  >
                    Scene {scene.scene_number}
                  </span>
                  <span
                    className="text-xs px-2 py-0.5 rounded"
                    style={{ background: 'var(--re-bg-hover)', color: 'var(--re-text-muted)' }}
                    title="Estimated duration. Adjust manually if needed."
                  >
                    ~{scene.duration_seconds}s
                  </span>
                </div>
                <button
                  onClick={regenScript}
                  disabled={regenLoading}
                  className="p-1 rounded transition-colors"
                  style={{ color: 'var(--re-text-muted)' }}
                  title="Regenerate full script"
                >
                  <RefreshCw className={`w-3.5 h-3.5 ${regenLoading ? 'animate-spin' : ''}`} />
                </button>
              </div>

              {/* Dialogue — click to edit */}
              {isEditing ? (
                <textarea
                  ref={(el) => { textareaRefs.current[scene.id] = el; }}
                  value={editValues[scene.id]}
                  onChange={(e) => setEditValues((prev) => ({ ...prev, [scene.id]: e.target.value }))}
                  onBlur={() => saveScene(scene.id)}
                  rows={3}
                  className="w-full resize-none rounded p-2 text-sm leading-relaxed focus:outline-none"
                  style={{
                    background: 'var(--re-bg-input, var(--re-bg-hover))',
                    color: 'var(--re-text-primary)',
                    border: '1px solid var(--re-accent-primary)',
                  }}
                  autoFocus
                />
              ) : (
                <p
                  className="text-sm leading-relaxed cursor-text"
                  style={{ color: 'var(--re-text-primary)' }}
                  onClick={() => setEditingId(scene.id)}
                  title="Click to edit"
                >
                  {editValues[scene.id] || scene.dialogue_line}
                </p>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

**Step 2: Create `src/components/remix/ApprovalGate.tsx`**

Sticky at top of review page. Shows 3 checklist items + Approve button (disabled until all 3). Clicking Approve opens a dialog that summarizes selections. Confirming POSTs to `/api/remix-engine/videos/{videoId}/approve`:

```tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { CheckCircle2, Circle, X } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface ApprovalGateProps {
  videoId: string;
  projectId: string;
  hasTitleSelected: boolean;
  hasThumbnailSelected: boolean;
  hasScript: boolean;
  selectedTitleText?: string;
  selectedThumbnailIndex?: number;
  sceneCount: number;
}

export function ApprovalGate({
  videoId, projectId, hasTitleSelected, hasThumbnailSelected, hasScript,
  selectedTitleText, selectedThumbnailIndex, sceneCount,
}: ApprovalGateProps) {
  const [dialogOpen, setDialogOpen] = useState(false);
  const [approving, setApproving] = useState(false);
  const router = useRouter();

  const allReady = hasTitleSelected && hasThumbnailSelected && hasScript;

  async function confirm() {
    setApproving(true);
    try {
      const res = await fetch(`/api/remix-engine/videos/${videoId}/approve`, { method: 'POST' });
      if (!res.ok) {
        const { error } = await res.json();
        alert(error ?? 'Approval failed');
        return;
      }
      router.push(`/dashboard/projects/${projectId}/videos/${videoId}`);
    } finally {
      setApproving(false);
      setDialogOpen(false);
    }
  }

  const checks = [
    { label: 'Title selected', done: hasTitleSelected },
    { label: 'Thumbnail selected', done: hasThumbnailSelected },
    { label: 'Script reviewed', done: hasScript },
  ];

  return (
    <>
      {/* Sticky bar */}
      <div
        className="sticky top-0 z-10 flex items-center justify-between gap-4 px-4 py-3 rounded-lg mb-6"
        style={{
          background: 'var(--re-bg-card)',
          border: '1px solid var(--re-border-default)',
          backdropFilter: 'blur(8px)',
        }}
      >
        <div className="flex items-center gap-4 flex-wrap">
          {checks.map((check) => (
            <div key={check.label} className="flex items-center gap-1.5">
              {check.done ? (
                <CheckCircle2 className="w-4 h-4" style={{ color: 'var(--re-success)' }} />
              ) : (
                <Circle className="w-4 h-4" style={{ color: 'var(--re-text-muted)' }} />
              )}
              <span
                className="text-sm"
                style={{ color: check.done ? 'var(--re-text-primary)' : 'var(--re-text-muted)' }}
              >
                {check.label}
              </span>
            </div>
          ))}
        </div>

        <Button
          variant="default"
          size="sm"
          disabled={!allReady}
          onClick={() => setDialogOpen(true)}
        >
          Approve & Continue
        </Button>
      </div>

      {/* Confirmation dialog */}
      {dialogOpen && (
        <div
          className="fixed inset-0 z-50 flex items-center justify-center p-4"
          style={{ background: 'rgba(0,0,0,0.6)' }}
          onClick={() => setDialogOpen(false)}
        >
          <div
            className="relative w-full max-w-md rounded-xl p-6 shadow-xl"
            style={{ background: 'var(--re-bg-card)', border: '1px solid var(--re-border-default)' }}
            onClick={(e) => e.stopPropagation()}
          >
            <button
              onClick={() => setDialogOpen(false)}
              className="absolute top-4 right-4 p-1 rounded hover:bg-[--re-bg-hover] transition-colors"
              style={{ color: 'var(--re-text-muted)' }}
            >
              <X className="w-4 h-4" />
            </button>

            <h3
              className="font-semibold mb-1"
              style={{ fontSize: 'var(--re-text-lg)', color: 'var(--re-text-primary)' }}
            >
              Confirm your selections
            </h3>
            <p className="text-sm mb-5" style={{ color: 'var(--re-text-secondary)' }}>
              Ready to proceed to generation with these choices:
            </p>

            <div className="space-y-3 mb-6">
              <div className="rounded-lg p-3" style={{ background: 'var(--re-bg-hover)' }}>
                <div className="text-xs font-medium mb-1" style={{ color: 'var(--re-text-muted)' }}>Title</div>
                <div className="text-sm font-medium" style={{ color: 'var(--re-text-primary)' }}>
                  {selectedTitleText ?? '—'}
                </div>
              </div>
              <div className="rounded-lg p-3" style={{ background: 'var(--re-bg-hover)' }}>
                <div className="text-xs font-medium mb-1" style={{ color: 'var(--re-text-muted)' }}>Thumbnail</div>
                <div className="text-sm" style={{ color: 'var(--re-text-primary)' }}>
                  {selectedThumbnailIndex != null ? `Variation ${selectedThumbnailIndex + 1}` : '—'}
                </div>
              </div>
              <div className="rounded-lg p-3" style={{ background: 'var(--re-bg-hover)' }}>
                <div className="text-xs font-medium mb-1" style={{ color: 'var(--re-text-muted)' }}>Script</div>
                <div className="text-sm" style={{ color: 'var(--re-text-primary)' }}>
                  {sceneCount} scenes
                </div>
              </div>
            </div>

            <div className="flex gap-3">
              <Button variant="outline" size="sm" onClick={() => setDialogOpen(false)} className="flex-1">
                Back — keep editing
              </Button>
              <Button variant="default" size="sm" onClick={confirm} disabled={approving} className="flex-1">
                {approving ? 'Confirming...' : 'Confirm & Continue'}
              </Button>
            </div>
          </div>
        </div>
      )}
    </>
  );
}
```

**Step 3: Create `src/components/remix/RemixReviewPage.tsx`**

Main orchestrator client component. Manages cross-section state (which title is selected affects ApprovalGate, etc.):

```tsx
'use client';

import { useState } from 'react';
import { TitleGrid } from './TitleGrid';
import { ThumbnailCards } from './ThumbnailCards';
import { SceneEditor } from './SceneEditor';
import { ApprovalGate } from './ApprovalGate';

interface Title { id: string; style: string; title: string; reasoning: string | null; is_selected: boolean; }
interface Thumbnail { id: string; prompt: string; file_path: string; is_selected: boolean; signedUrl: string | null; }
interface Scene { id: string; scene_number: number; dialogue_line: string; duration_seconds: number; broll_description: string; }

interface RemixReviewPageProps {
  videoId: string;
  projectId: string;
  titles: Title[];
  thumbnails: Thumbnail[];
  scenes: Scene[];
}

export function RemixReviewPage({ videoId, projectId, titles, thumbnails, scenes }: RemixReviewPageProps) {
  const [selectedTitleId, setSelectedTitleId] = useState<string | null>(
    titles.find((t) => t.is_selected)?.id ?? null
  );
  const [selectedThumbnailId, setSelectedThumbnailId] = useState<string | null>(
    thumbnails.find((t) => t.is_selected)?.id ?? null
  );

  const selectedTitle = titles.find((t) => t.id === selectedTitleId);
  const selectedThumbnailIndex = thumbnails.findIndex((t) => t.id === selectedThumbnailId);

  const handleRefresh = () => { window.location.reload(); };

  return (
    <div className="space-y-10">
      <ApprovalGate
        videoId={videoId}
        projectId={projectId}
        hasTitleSelected={selectedTitleId != null}
        hasThumbnailSelected={selectedThumbnailId != null}
        hasScript={scenes.length > 0}
        selectedTitleText={selectedTitle?.title}
        selectedThumbnailIndex={selectedThumbnailIndex >= 0 ? selectedThumbnailIndex : undefined}
        sceneCount={scenes.length}
      />

      <TitleGrid
        titles={titles}
        videoId={videoId}
        projectId={projectId}
        onSelectionChange={setSelectedTitleId}
        onRegenerate={handleRefresh}
      />

      <ThumbnailCards
        thumbnails={thumbnails}
        videoId={videoId}
        projectId={projectId}
        onSelectionChange={setSelectedThumbnailId}
      />

      <SceneEditor
        scenes={scenes}
        videoId={videoId}
        projectId={projectId}
        onRegenerate={handleRefresh}
      />
    </div>
  );
}
```

**Step 4: Update remix page (Plan 04 output) to use RemixReviewPage**

In `src/app/(dashboard)/projects/[id]/videos/[videoId]/remix/page.tsx`, find the TODO comment placeholder and replace it with the RemixReviewPage component. Import RemixReviewPage at the top, and pass the fetched data as props. Replace the `{/* TODO: RemixReviewPage client component inserted here by Plan 05 */}` comment block with:

```tsx
import { RemixReviewPage } from '@/components/remix/RemixReviewPage';
// ...
// Inside the complete state block, replace TODO comment with:
<RemixReviewPage
  videoId={videoId}
  projectId={projectId}
  titles={titles}
  thumbnails={thumbnailsWithUrls}
  scenes={scenes}
/>
```

The `scenes` variable needs to be properly typed. In the remix page, `scripts[0]?.re_scenes` may need explicit typing. Ensure the Scene type matches (id, scene_number, dialogue_line, duration_seconds, broll_description).
  </action>
  <verify>
    <automated>npx tsc --noEmit && npm run test -- src/components/__tests__/RemixReviewPage.test.tsx src/app/api/remix-engine/__tests__/gate.test.ts --watchAll=false && npm run build</automated>
  </verify>
  <done>
    - ApprovalGate renders sticky bar with 3 checklist items and disabled Approve button until all 3 are checked
    - Confirmation dialog shows selected title text, thumbnail variation number, and scene count
    - SceneEditor renders all scenes as cards with inline editing on click and blur-to-save
    - RemixReviewPage orchestrates all 4 components and wires state between them
    - Remix page imports and renders RemixReviewPage when remix_status === 'complete'
    - `npm run build` succeeds with zero errors
    - `RemixReviewPage.test.tsx` passes (8 titles rendered, approval gate disabled, 3 checklist items, scene cards)
    - `gate.test.ts` passes (all 3 approval gate tests GREEN)
  </done>
</task>

</tasks>

<verification>
```bash
npx tsc --noEmit
npm run build
npm run test -- --watchAll=false
```
All must pass. Build confirms all routes and components compile for production. Full suite must be GREEN (all 9 Phase 3 test files passing).
</verification>

<success_criteria>
- Title grid shows 8 cards in 2-column layout; radio selection + inline edit with char count on selected card
- Thumbnail cards show 3 variations; per-thumbnail regen with optional style prompt
- Scene editor shows all scenes; click dialogue → textarea; blur saves via PATCH
- Sticky approval bar shows 3 checklist items; Approve disabled until all 3 satisfied
- Confirmation dialog shows title text, thumbnail number, scene count
- Approve button POSTs to /api/remix-engine/videos/[videoId]/approve and navigates to video page on success
- `npm run build` succeeds
- `npm run test` (full suite) GREEN — all 9 Phase 3 test files pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-remix-pipeline-4-hours/03-05-SUMMARY.md`
</output>

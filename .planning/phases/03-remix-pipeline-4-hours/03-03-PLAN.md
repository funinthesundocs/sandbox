---
phase: 03-remix-pipeline-4-hours
plan: 03
type: execute
wave: 2
depends_on:
  - "03-00"
  - "03-01"
  - "03-02"
files_modified:
  - src/app/api/remix-engine/remix/title/route.ts
  - src/app/api/remix-engine/remix/thumbnail/route.ts
  - src/app/api/remix-engine/remix/script/route.ts
  - src/app/api/remix-engine/remix/select/route.ts
  - src/app/api/remix-engine/remix/batch/route.ts
  - src/worker/handlers/remix.ts
  - src/worker/index.ts
autonomous: true
requirements:
  - R3.1
  - R3.2
  - R3.3
  - R3.4
  - R3.6
  - R3.7

must_haves:
  truths:
    - "POST /api/remix-engine/remix/title queues a remix_title job and returns the job ID"
    - "POST /api/remix-engine/remix/thumbnail queues a remix_thumbnail job and returns the job ID"
    - "POST /api/remix-engine/remix/script queues a remix_script job and returns the job ID"
    - "POST /api/remix-engine/remix/select updates is_selected boolean for title, thumbnail, or script"
    - "POST /api/remix-engine/remix/batch queues title+thumbnail+script jobs for all videos in a project"
    - "Worker remix handler runs all 3 remix operations per video, storing results in DB with is_selected=false; individual failures are non-fatal"
    - "Thumbnail fal.ai URL is downloaded and uploaded to Supabase Storage — the fal.ai URL is never stored as the permanent path"
  artifacts:
    - path: "src/app/api/remix-engine/remix/title/route.ts"
      provides: "POST /api/remix-engine/remix/title"
      exports: ["POST"]
    - path: "src/app/api/remix-engine/remix/thumbnail/route.ts"
      provides: "POST /api/remix-engine/remix/thumbnail"
      exports: ["POST"]
    - path: "src/app/api/remix-engine/remix/script/route.ts"
      provides: "POST /api/remix-engine/remix/script"
      exports: ["POST"]
    - path: "src/app/api/remix-engine/remix/select/route.ts"
      provides: "POST /api/remix-engine/remix/select (title/thumbnail/script selection)"
      exports: ["POST"]
    - path: "src/app/api/remix-engine/remix/batch/route.ts"
      provides: "POST /api/remix-engine/remix/batch (multi-video project remix)"
      exports: ["POST"]
    - path: "src/worker/handlers/remix.ts"
      provides: "handleRemixJob BullMQ handler"
      exports: ["handleRemixJob", "RemixJobData"]
  key_links:
    - from: "src/app/api/remix-engine/remix/title/route.ts"
      to: "src/lib/queue/queues.ts"
      via: "remixQueue.add()"
      pattern: "remixQueue"
    - from: "src/worker/handlers/remix.ts"
      to: "src/lib/remix/title-remixer.ts"
      via: "generateTitleVariations()"
      pattern: "generateTitleVariations"
    - from: "src/worker/handlers/remix.ts"
      to: "src/lib/supabase/admin.ts"
      via: "supabaseAdmin.from('re_remixed_titles').insert()"
      pattern: "re_remixed_titles"
---

<objective>
Create all remix API routes (title, thumbnail, script, select, batch) and the BullMQ remix worker handler that executes the AI generation and writes results to the database.

Purpose: Connects the remix library (Plans 01-02) to the queue system and database. After this plan, the full backend remix pipeline is operational.

Output: 5 API route files + worker remix handler + updated worker index.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/03-remix-pipeline-4-hours/03-01-SUMMARY.md
@.planning/phases/03-remix-pipeline-4-hours/03-02-SUMMARY.md

Key constraints:
- Worker files MUST use relative imports — no `@/` aliases (tsconfig.worker.json rule)
- Worker uses `supabaseAdmin` (service role) — not the cookie client
- Thumbnail fal.ai URL is temporary — download and upload to Supabase Storage in worker
- Non-fatal remix: title/thumbnail/script failures must not block each other
- Queue concurrency per RESEARCH.md R3.7: title max 5, thumbnail max 3, script max 3
- API routes use `createClient()` (cookie session) for user auth check before queuing
- All job types already defined in `re_jobs` table: 'remix_title' | 'remix_thumbnail' | 'remix_script'
- The select endpoint uses `is_selected` boolean pattern: clear all for video, set one

<interfaces>
<!-- Types and exports from Plans 01-02 and existing codebase -->

From src/lib/remix/title-remixer.ts (Plan 01 output):
```typescript
export async function generateTitleVariations(params: RemixTitleParams): Promise<TitlesResponse>;
// RemixTitleParams: { originalTitle, description, channelName, videoDuration? }
// TitlesResponse: { variations: Array<{ style, title, reasoning }> }
```

From src/lib/remix/script-remixer.ts (Plan 01 output):
```typescript
export async function generateRemixedScript(params: RemixScriptParams): Promise<RemixedScript>;
// RemixScriptParams: { originalTitle, originalTranscript, channelName, targetDurationSeconds? }
// RemixedScript: { scenes: Array<{ scene_number, dialogue_line, duration_seconds, broll_description, on_screen_text? }>, tone?, target_audience? }
```

From src/lib/remix/thumbnail-remixer.ts (Plan 02 output):
```typescript
export async function generateThumbnailVariation(params: ThumbnailGenerationParams, onProgress?): Promise<GeneratedThumbnail>;
// GeneratedThumbnail: { falUrl, prompt, analysis }
// ThumbnailGenerationParams: { videoId, originalThumbnailUrl?, videoTitle, videoDescription, style, stylePromptOverride? }
// style: 'bold-text-overlay' | 'cinematic-scene' | 'face-reaction'
```

From src/lib/queue/queues.ts:
```typescript
export const remixQueue: Queue; // BullMQ Queue named 'remix'
```

From src/lib/supabase/types.ts (DB schema):
```typescript
// re_jobs insert needs: { type: 'remix_title'|'remix_thumbnail'|'remix_script', video_id, project_id, status: 'queued', created_by }
// re_remixed_titles insert: { video_id, style, title, reasoning, is_selected: false }
// re_remixed_thumbnails insert: { video_id, prompt, analysis, file_path, is_selected: false }
// re_remixed_scripts insert: { video_id, full_script, tone, target_audience, total_duration_seconds, is_selected: false }
// re_scenes insert: { script_id, scene_number, dialogue_line, duration_seconds, broll_description, on_screen_text }
// re_videos update: { remix_status: 'processing'|'complete'|'error' }
```

From src/lib/remix-engine/hooks.ts:
```typescript
export function storagePath(...segments: string[]): string;
// Usage: storagePath('videos', projectId, videoId, 'thumbnails', 'thumb-1.jpg')
// Returns: 'remix-engine/videos/{projectId}/{videoId}/thumbnails/thumb-1.jpg'
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create remix API routes (title, thumbnail, script, select, batch)</name>
  <files>
    src/app/api/remix-engine/remix/title/route.ts
    src/app/api/remix-engine/remix/thumbnail/route.ts
    src/app/api/remix-engine/remix/script/route.ts
    src/app/api/remix-engine/remix/select/route.ts
    src/app/api/remix-engine/remix/batch/route.ts
  </files>
  <action>
All 5 API routes follow the same pattern:
1. Auth check via `createClient()` — redirect/401 if unauthenticated
2. Parse + validate request body with Zod
3. Create `re_jobs` record with `status: 'queued'`
4. Enqueue job to `remixQueue`
5. Return `{ jobId, videoId }` with 202 Accepted

**`src/app/api/remix-engine/remix/title/route.ts`**
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createClient } from '@/lib/supabase/server';
import { remixQueue } from '@/lib/queue/queues';

const BodySchema = z.object({
  videoId: z.string().uuid(),
  projectId: z.string().uuid(),
});

export async function POST(req: NextRequest) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const body = BodySchema.safeParse(await req.json());
  if (!body.success) return NextResponse.json({ error: body.error.flatten() }, { status: 400 });

  const { videoId, projectId } = body.data;

  // Fetch video metadata needed for remix
  const { data: video } = await supabase
    .from('re_videos')
    .select('original_title, original_description, channel_name, duration_seconds')
    .eq('id', videoId)
    .single();
  if (!video) return NextResponse.json({ error: 'Video not found' }, { status: 404 });

  // Create job record
  const { data: job } = await supabase
    .from('re_jobs')
    .insert({ type: 'remix_title', video_id: videoId, project_id: projectId, status: 'queued', created_by: user.id })
    .select('id')
    .single();

  // Enqueue
  await remixQueue.add('remix_title', {
    type: 'title',
    jobId: job!.id,
    videoId,
    projectId,
    video: { originalTitle: video.original_title, description: video.original_description, channelName: video.channel_name, durationSeconds: video.duration_seconds },
  });

  return NextResponse.json({ jobId: job!.id, videoId }, { status: 202 });
}
```

**`src/app/api/remix-engine/remix/thumbnail/route.ts`**
Same structure. Body: `{ videoId, projectId }`. Fetch `original_title, original_description, original_thumbnail_url`. Create 3 jobs (one per style: 'bold-text-overlay', 'cinematic-scene', 'face-reaction') — each style is its own BullMQ job:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createClient } from '@/lib/supabase/server';
import { remixQueue } from '@/lib/queue/queues';

const BodySchema = z.object({
  videoId: z.string().uuid(),
  projectId: z.string().uuid(),
  stylePromptOverride: z.string().optional(), // For per-thumbnail regeneration
  style: z.enum(['bold-text-overlay', 'cinematic-scene', 'face-reaction']).optional(), // If omitted, generate all 3
});

export async function POST(req: NextRequest) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const body = BodySchema.safeParse(await req.json());
  if (!body.success) return NextResponse.json({ error: body.error.flatten() }, { status: 400 });

  const { videoId, projectId, style, stylePromptOverride } = body.data;

  const { data: video } = await supabase
    .from('re_videos')
    .select('original_title, original_description, original_thumbnail_url')
    .eq('id', videoId)
    .single();
  if (!video) return NextResponse.json({ error: 'Video not found' }, { status: 404 });

  const stylesToGenerate: Array<'bold-text-overlay' | 'cinematic-scene' | 'face-reaction'> =
    style ? [style] : ['bold-text-overlay', 'cinematic-scene', 'face-reaction'];

  const jobIds: string[] = [];
  for (const s of stylesToGenerate) {
    const { data: job } = await supabase
      .from('re_jobs')
      .insert({ type: 'remix_thumbnail', video_id: videoId, project_id: projectId, status: 'queued', created_by: user.id })
      .select('id')
      .single();

    await remixQueue.add('remix_thumbnail', {
      type: 'thumbnail',
      jobId: job!.id,
      videoId,
      projectId,
      style: s,
      stylePromptOverride,
      video: { originalTitle: video.original_title, originalDescription: video.original_description, originalThumbnailUrl: video.original_thumbnail_url },
    });
    jobIds.push(job!.id);
  }

  return NextResponse.json({ jobIds, videoId }, { status: 202 });
}
```

**`src/app/api/remix-engine/remix/script/route.ts`**
Same structure. Body: `{ videoId, projectId }`. Fetch `original_title, original_description, original_transcript, channel_name, duration_seconds`:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createClient } from '@/lib/supabase/server';
import { remixQueue } from '@/lib/queue/queues';

const BodySchema = z.object({
  videoId: z.string().uuid(),
  projectId: z.string().uuid(),
});

export async function POST(req: NextRequest) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const body = BodySchema.safeParse(await req.json());
  if (!body.success) return NextResponse.json({ error: body.error.flatten() }, { status: 400 });

  const { videoId, projectId } = body.data;

  const { data: video } = await supabase
    .from('re_videos')
    .select('original_title, original_description, original_transcript, channel_name, duration_seconds')
    .eq('id', videoId)
    .single();
  if (!video) return NextResponse.json({ error: 'Video not found' }, { status: 404 });
  if (!video.original_transcript) return NextResponse.json({ error: 'Video has no transcript to remix' }, { status: 422 });

  const { data: job } = await supabase
    .from('re_jobs')
    .insert({ type: 'remix_script', video_id: videoId, project_id: projectId, status: 'queued', created_by: user.id })
    .select('id')
    .single();

  await remixQueue.add('remix_script', {
    type: 'script',
    jobId: job!.id,
    videoId,
    projectId,
    video: { originalTitle: video.original_title, originalTranscript: video.original_transcript, channelName: video.channel_name, durationSeconds: video.duration_seconds },
  });

  return NextResponse.json({ jobId: job!.id, videoId }, { status: 202 });
}
```

**`src/app/api/remix-engine/remix/select/route.ts`**
Handles selection of title, thumbnail, or script. Clears all `is_selected` for that video+type, then sets the chosen one. Also handles text edits (update title content inline):
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createClient } from '@/lib/supabase/server';

const BodySchema = z.object({
  videoId: z.string().uuid(),
  type: z.enum(['title', 'thumbnail', 'script']),
  id: z.string().uuid(), // ID of the item to select
  editedText: z.string().optional(), // For inline title edit — saves text AND marks selected
});

export async function POST(req: NextRequest) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const body = BodySchema.safeParse(await req.json());
  if (!body.success) return NextResponse.json({ error: body.error.flatten() }, { status: 400 });

  const { videoId, type, id, editedText } = body.data;

  const tableMap = {
    title: 're_remixed_titles',
    thumbnail: 're_remixed_thumbnails',
    script: 're_remixed_scripts',
  } as const;
  const table = tableMap[type];

  // Clear all selections for this video+type
  await supabase.from(table).update({ is_selected: false }).eq('video_id', videoId);

  // Set the chosen item as selected, optionally updating text
  const updatePayload: Record<string, unknown> = { is_selected: true };
  if (editedText && type === 'title') updatePayload.title = editedText;

  const { error } = await supabase.from(table).update(updatePayload).eq('id', id);
  if (error) return NextResponse.json({ error: error.message }, { status: 500 });

  return NextResponse.json({ success: true });
}

// Also support inline scene text edit via PATCH
export async function PATCH(req: NextRequest) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const body = z.object({
    sceneId: z.string().uuid(),
    dialogueLine: z.string().min(1),
  }).safeParse(await req.json());
  if (!body.success) return NextResponse.json({ error: body.error.flatten() }, { status: 400 });

  const { error } = await supabase
    .from('re_scenes')
    .update({ dialogue_line: body.data.dialogueLine })
    .eq('id', body.data.sceneId);

  if (error) return NextResponse.json({ error: error.message }, { status: 500 });
  return NextResponse.json({ success: true });
}
```

**`src/app/api/remix-engine/remix/batch/route.ts`**
Queues title+thumbnail+script jobs for ALL videos in a project. Per R3.7 — parallel. Sequential inserts to re_jobs to avoid race conditions (same pattern as batch scrape from STATE.md Phase 02-03 decision):
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createClient } from '@/lib/supabase/server';
import { remixQueue } from '@/lib/queue/queues';

const BodySchema = z.object({
  projectId: z.string().uuid(),
});

export async function POST(req: NextRequest) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const body = BodySchema.safeParse(await req.json());
  if (!body.success) return NextResponse.json({ error: body.error.flatten() }, { status: 400 });

  const { projectId } = body.data;

  // Fetch all scraped videos in project
  const { data: videos } = await supabase
    .from('re_videos')
    .select('id, original_title, original_description, original_transcript, original_thumbnail_url, channel_name, duration_seconds')
    .eq('project_id', projectId)
    .eq('scrape_status', 'complete');

  if (!videos || videos.length === 0) {
    return NextResponse.json({ error: 'No scraped videos found in project' }, { status: 404 });
  }

  const enqueuedJobs: Array<{ videoId: string; jobIds: string[] }> = [];

  for (const video of videos) {
    const videoJobIds: string[] = [];

    // Title job
    const { data: titleJob } = await supabase
      .from('re_jobs')
      .insert({ type: 'remix_title', video_id: video.id, project_id: projectId, status: 'queued', created_by: user.id })
      .select('id').single();
    await remixQueue.add('remix_title', {
      type: 'title', jobId: titleJob!.id, videoId: video.id, projectId,
      video: { originalTitle: video.original_title, description: video.original_description, channelName: video.channel_name, durationSeconds: video.duration_seconds },
    });
    videoJobIds.push(titleJob!.id);

    // Thumbnail jobs (3 styles)
    for (const style of ['bold-text-overlay', 'cinematic-scene', 'face-reaction'] as const) {
      const { data: thumbJob } = await supabase
        .from('re_jobs')
        .insert({ type: 'remix_thumbnail', video_id: video.id, project_id: projectId, status: 'queued', created_by: user.id })
        .select('id').single();
      await remixQueue.add('remix_thumbnail', {
        type: 'thumbnail', jobId: thumbJob!.id, videoId: video.id, projectId, style,
        video: { originalTitle: video.original_title, originalDescription: video.original_description, originalThumbnailUrl: video.original_thumbnail_url },
      });
      videoJobIds.push(thumbJob!.id);
    }

    // Script job (only if transcript available)
    if (video.original_transcript) {
      const { data: scriptJob } = await supabase
        .from('re_jobs')
        .insert({ type: 'remix_script', video_id: video.id, project_id: projectId, status: 'queued', created_by: user.id })
        .select('id').single();
      await remixQueue.add('remix_script', {
        type: 'script', jobId: scriptJob!.id, videoId: video.id, projectId,
        video: { originalTitle: video.original_title, originalTranscript: video.original_transcript, channelName: video.channel_name, durationSeconds: video.duration_seconds },
      });
      videoJobIds.push(scriptJob!.id);
    }

    enqueuedJobs.push({ videoId: video.id, jobIds: videoJobIds });
  }

  return NextResponse.json({ enqueuedJobs, videoCount: videos.length }, { status: 202 });
}
```
  </action>
  <verify>
    <automated>npx tsc --noEmit && npm run test -- src/app/api/remix-engine/remix/__tests__/route.test.ts src/app/api/remix-engine/remix/__tests__/selection.test.ts --watchAll=false</automated>
  </verify>
  <done>
    - All 5 route files exist under `src/app/api/remix-engine/remix/`
    - Each route exports POST (and PATCH for select)
    - Auth check on every route
    - Batch route queues title + 3 thumbnail + script jobs per video
    - TypeScript compiles clean
    - `route.test.ts` passes (401 unauth, 202 enqueue, 422 no transcript)
    - `selection.test.ts` passes (clear+set is_selected, editedText, PATCH scene edit)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create worker remix handler and register in worker index</name>
  <files>
    src/worker/handlers/remix.ts
    src/worker/index.ts
  </files>
  <action>
**CRITICAL: Worker files use relative imports only — no @/ aliases.**

**Create `src/worker/handlers/remix.ts`**

The handler dispatches based on `job.data.type` (title | thumbnail | script). Each operation is wrapped in its own try-catch (non-fatal pattern from RESEARCH.md Pattern 6). The thumbnail operation downloads the fal.ai URL and uploads to Supabase Storage before saving the DB record.

```typescript
// src/worker/handlers/remix.ts
// BullMQ remix job handler — runs OUTSIDE Next.js. Relative imports only.

import { Job } from 'bullmq';
import { supabaseAdmin } from '../../lib/supabase/admin';
import { generateTitleVariations } from '../../lib/remix/title-remixer';
import { generateThumbnailVariation } from '../../lib/remix/thumbnail-remixer';
import { generateRemixedScript } from '../../lib/remix/script-remixer';
import { storagePath } from '../../lib/remix-engine/hooks';

export interface RemixJobData {
  type: 'title' | 'thumbnail' | 'script';
  jobId: string;
  videoId: string;
  projectId: string;
  style?: 'bold-text-overlay' | 'cinematic-scene' | 'face-reaction';
  stylePromptOverride?: string;
  video: {
    originalTitle?: string | null;
    description?: string | null;
    originalDescription?: string | null;
    channelName?: string | null;
    durationSeconds?: number | null;
    originalTranscript?: string | null;
    originalThumbnailUrl?: string | null;
  };
}

const updateJobStatus = async (jobId: string, status: 'processing' | 'complete' | 'error', errorMessage?: string) => {
  await supabaseAdmin.from('re_jobs').update({
    status,
    ...(status === 'processing' ? { started_at: new Date().toISOString() } : {}),
    ...(status !== 'processing' ? { completed_at: new Date().toISOString() } : {}),
    ...(errorMessage ? { error_message: errorMessage } : {}),
  }).eq('id', jobId);
};

export async function handleRemixJob(job: Job<RemixJobData>): Promise<void> {
  const { type, jobId, videoId, projectId } = job.data;

  await updateJobStatus(jobId, 'processing');
  await job.updateProgress(10);

  try {
    if (type === 'title') {
      await handleTitleRemix(job);
    } else if (type === 'thumbnail') {
      await handleThumbnailRemix(job);
    } else if (type === 'script') {
      await handleScriptRemix(job);
    } else {
      throw new Error(`Unknown remix job type: ${type}`);
    }

    await updateJobStatus(jobId, 'complete');
    await job.updateProgress(100);
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    await updateJobStatus(jobId, 'error', message);
    throw err; // Re-throw so BullMQ marks job as failed
  }
}

async function handleTitleRemix(job: Job<RemixJobData>): Promise<void> {
  const { jobId, videoId, video } = job.data;

  const result = await generateTitleVariations({
    originalTitle: video.originalTitle ?? 'Untitled',
    description: video.description ?? video.originalDescription ?? '',
    channelName: video.channelName ?? '',
    videoDuration: video.durationSeconds ?? undefined,
  });

  await job.updateProgress(70);

  // Delete existing titles for this video (idempotent on regeneration)
  await supabaseAdmin.from('re_remixed_titles').delete().eq('video_id', videoId);

  // Insert all 8 variations with is_selected=false
  const inserts = result.variations.map((v) => ({
    video_id: videoId,
    style: v.style,
    title: v.title,
    reasoning: v.reasoning,
    is_selected: false,
  }));
  const { error } = await supabaseAdmin.from('re_remixed_titles').insert(inserts);
  if (error) throw new Error(`Failed to save title variations: ${error.message}`);

  // Update video remix status
  await supabaseAdmin.from('re_videos').update({ remix_status: 'complete' }).eq('id', videoId);
}

async function handleThumbnailRemix(job: Job<RemixJobData>): Promise<void> {
  const { videoId, projectId, style, stylePromptOverride, video } = job.data;

  if (!style) throw new Error('Thumbnail remix job missing style');

  const result = await generateThumbnailVariation(
    {
      videoId,
      originalThumbnailUrl: video.originalThumbnailUrl ?? undefined,
      videoTitle: video.originalTitle ?? 'Untitled',
      videoDescription: video.originalDescription ?? '',
      style,
      stylePromptOverride,
    },
    (status) => { job.updateProgress(50); console.log(`[remix:thumbnail] ${status}`); }
  );

  await job.updateProgress(70);

  // Download fal.ai image and upload to Supabase Storage (fal.ai URLs are temporary)
  const styleSlug = style.replace(/-/g, '_');
  const storageDest = storagePath('videos', projectId, videoId, 'thumbnails', `${styleSlug}.jpg`);

  const imageResponse = await fetch(result.falUrl);
  if (!imageResponse.ok) throw new Error(`Failed to download fal.ai thumbnail: ${imageResponse.status}`);
  const imageBuffer = Buffer.from(await imageResponse.arrayBuffer());

  const { error: uploadError } = await supabaseAdmin.storage
    .from('remix-engine')
    .upload(storageDest, imageBuffer, { contentType: 'image/jpeg', upsert: true });
  if (uploadError) throw new Error(`Failed to upload thumbnail: ${uploadError.message}`);

  await job.updateProgress(90);

  // Delete existing thumbnail for this style (idempotent on regeneration)
  // Match by video_id and style slug in the file_path
  await supabaseAdmin.from('re_remixed_thumbnails')
    .delete()
    .eq('video_id', videoId)
    .like('file_path', `%${styleSlug}%`);

  const { error } = await supabaseAdmin.from('re_remixed_thumbnails').insert({
    video_id: videoId,
    prompt: result.prompt,
    analysis: result.analysis,
    file_path: storageDest,
    is_selected: false,
  });
  if (error) throw new Error(`Failed to save thumbnail record: ${error.message}`);
}

async function handleScriptRemix(job: Job<RemixJobData>): Promise<void> {
  const { videoId, video } = job.data;

  if (!video.originalTranscript) throw new Error('Script remix job missing originalTranscript');

  const result = await generateRemixedScript({
    originalTitle: video.originalTitle ?? 'Untitled',
    originalTranscript: video.originalTranscript,
    channelName: video.channelName ?? '',
    targetDurationSeconds: video.durationSeconds ?? undefined,
  });

  await job.updateProgress(70);

  // Delete existing scripts + scenes for this video (idempotent)
  const { data: existingScripts } = await supabaseAdmin
    .from('re_remixed_scripts')
    .select('id')
    .eq('video_id', videoId);
  if (existingScripts && existingScripts.length > 0) {
    const scriptIds = existingScripts.map((s) => s.id);
    await supabaseAdmin.from('re_scenes').delete().in('script_id', scriptIds);
    await supabaseAdmin.from('re_remixed_scripts').delete().eq('video_id', videoId);
  }

  // Calculate total duration
  const totalDuration = result.scenes.reduce((sum, s) => sum + s.duration_seconds, 0);

  // Insert script record
  const { data: scriptRecord, error: scriptError } = await supabaseAdmin
    .from('re_remixed_scripts')
    .insert({
      video_id: videoId,
      full_script: result.scenes.map((s) => s.dialogue_line).join('\n\n'),
      tone: result.tone ?? null,
      target_audience: result.target_audience ?? null,
      total_duration_seconds: totalDuration,
      is_selected: false,
    })
    .select('id')
    .single();
  if (scriptError) throw new Error(`Failed to save script: ${scriptError.message}`);

  // Insert scenes — sequential for-loop to respect UNIQUE(script_id, scene_number) constraint
  for (const scene of result.scenes) {
    const { error: sceneError } = await supabaseAdmin.from('re_scenes').insert({
      script_id: scriptRecord!.id,
      scene_number: scene.scene_number,
      dialogue_line: scene.dialogue_line,
      duration_seconds: scene.duration_seconds,
      broll_description: scene.broll_description,
      on_screen_text: scene.on_screen_text ?? null,
    });
    if (sceneError) throw new Error(`Failed to save scene ${scene.scene_number}: ${sceneError.message}`);
  }

  await supabaseAdmin.from('re_videos').update({ remix_status: 'complete' }).eq('id', videoId);
}
```

**Update `src/worker/index.ts`**

Register a `remixWorker` using the `remixQueue` name. Concurrency: 5 (title jobs are lightweight; thumbnail jobs are the bottleneck but they run as separate jobs). Read the existing file and append after the scrapeWorker registration:

Add to the existing `src/worker/index.ts`:
1. Import `handleRemixJob` from `./handlers/remix`
2. Create `remixWorker` with `concurrency: 5`
3. Add event handlers for `completed` and `failed`
4. Add `remixWorker.close()` to the shutdown function

The final index.ts should have both scrapeWorker and remixWorker registered. Read the current file first, then make targeted additions — do NOT rewrite the whole file.
  </action>
  <verify>
    <automated>npx tsc -p tsconfig.worker.json && npx tsc --noEmit && npm run test -- src/worker/__tests__/remix-handler.test.ts --watchAll=false</automated>
  </verify>
  <done>
    - `src/worker/handlers/remix.ts` exports `handleRemixJob` and `RemixJobData`
    - Handler dispatches on job.data.type: 'title' | 'thumbnail' | 'script'
    - Thumbnail handler downloads fal.ai URL and uploads to Supabase Storage before DB insert
    - Script handler inserts scenes sequentially to respect UNIQUE constraint
    - `src/worker/index.ts` registers `remixWorker` with concurrency 5
    - `npx tsc -p tsconfig.worker.json` passes (worker TypeScript)
    - `npx tsc --noEmit` passes (Next.js TypeScript)
    - `remix-handler.test.ts` passes (all 5 dispatch/progress tests GREEN)
  </done>
</task>

</tasks>

<verification>
```bash
npx tsc --noEmit
npx tsc -p tsconfig.worker.json
npm run lint
npm run test -- src/app/api/remix-engine/remix/__tests__/route.test.ts src/app/api/remix-engine/remix/__tests__/selection.test.ts src/worker/__tests__/remix-handler.test.ts --watchAll=false
```
All must pass with zero errors.
</verification>

<success_criteria>
- 5 API routes exist: `/api/remix-engine/remix/title`, `/thumbnail`, `/script`, `/select`, `/batch`
- Worker remix handler handles title, thumbnail, and script job types
- Thumbnail worker downloads fal.ai URL and uploads to Supabase Storage (private, never public)
- Script worker inserts scenes with sequential for-loop (UNIQUE constraint safe)
- is_selected=false on all newly inserted remix records
- Both TypeScript configs compile clean
- `route.test.ts`, `selection.test.ts`, `remix-handler.test.ts` all GREEN
</success_criteria>

<output>
After completion, create `.planning/phases/03-remix-pipeline-4-hours/03-03-SUMMARY.md`
</output>

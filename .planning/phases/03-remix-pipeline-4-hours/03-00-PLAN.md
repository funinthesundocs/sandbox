---
phase: 03-remix-pipeline-4-hours
plan: 00
type: execute
wave: 0
depends_on: []
files_modified:
  - src/lib/remix/__tests__/title-remixer.test.ts
  - src/lib/remix/__tests__/script-remixer.test.ts
  - src/lib/remix/__tests__/thumbnail-analyzer.test.ts
  - src/lib/remix/__tests__/thumbnail-remixer.test.ts
  - src/app/api/remix-engine/remix/__tests__/route.test.ts
  - src/app/api/remix-engine/remix/__tests__/selection.test.ts
  - src/app/api/remix-engine/__tests__/gate.test.ts
  - src/worker/__tests__/remix-handler.test.ts
  - src/components/__tests__/RemixReviewPage.test.tsx
autonomous: true
requirements:
  - R3.1
  - R3.2
  - R3.3
  - R3.4
  - R3.5
  - R3.6
  - R3.7

must_haves:
  truths:
    - "All 9 test files exist under their target paths"
    - "Jest can discover and run each test file without import errors"
    - "All tests fail (RED) because source files do not yet exist — this is correct for Wave 0"
    - "Mock modules for @google/generative-ai and @fal-ai/serverless-client are declared at the top of the relevant test files"
  artifacts:
    - path: "src/lib/remix/__tests__/title-remixer.test.ts"
      provides: "R3.1 test scaffold: 8-variation count, Zod schema validation, getServerConfig usage"
      exports: []
    - path: "src/lib/remix/__tests__/script-remixer.test.ts"
      provides: "R3.3 test scaffold: scene duration 15-45s, sequential scene numbers"
      exports: []
    - path: "src/lib/remix/__tests__/thumbnail-analyzer.test.ts"
      provides: "R3.2 test scaffold: Gemini Vision graceful degradation on fetch failure"
      exports: []
    - path: "src/lib/remix/__tests__/thumbnail-remixer.test.ts"
      provides: "R3.2 test scaffold: fal.ai subscribe() returns 1280x720 URL, onQueueUpdate callback"
      exports: []
    - path: "src/app/api/remix-engine/remix/__tests__/route.test.ts"
      provides: "R3.4 test scaffold: POST /title, /thumbnail, /script return 202, re_jobs insert"
      exports: []
    - path: "src/app/api/remix-engine/remix/__tests__/selection.test.ts"
      provides: "R3.5 test scaffold: is_selected toggle, editedText update, PATCH scene edit"
      exports: []
    - path: "src/app/api/remix-engine/__tests__/gate.test.ts"
      provides: "R3.6 test scaffold: approve endpoint rejects 422 when selections missing"
      exports: []
    - path: "src/worker/__tests__/remix-handler.test.ts"
      provides: "R3.7 test scaffold: handleRemixJob dispatches by type, thumbnail downloads+uploads"
      exports: []
    - path: "src/components/__tests__/RemixReviewPage.test.tsx"
      provides: "R3.4/R3.5 UI test scaffold: renders title count, approval gate disabled state"
      exports: []
  key_links:
    - from: "src/lib/remix/__tests__/title-remixer.test.ts"
      to: "src/lib/remix/title-remixer.ts"
      via: "import { generateTitleVariations }"
      pattern: "generateTitleVariations"
    - from: "src/worker/__tests__/remix-handler.test.ts"
      to: "src/worker/handlers/remix.ts"
      via: "import { handleRemixJob }"
      pattern: "handleRemixJob"
---

<objective>
Scaffold all 9 test files for Phase 3 with proper mocks and failing test cases before any source files are written.

Purpose: Establishes the Nyquist test infrastructure that Plans 01-05 verify against. Tests start RED (source files don't exist yet) and go GREEN as each plan implements its target. This is the standard Wave 0 setup for the Nyquist compliance requirement.

Output: 9 test files in place, Jest discovers them, all fail with MODULE_NOT_FOUND (correct for Wave 0).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md

Key constraints:
- Test framework: Jest (via `npm run test`) + Supertest for API routes. Config: `jest.config.js` (established in Phase 1).
- All test files must declare jest.mock() BEFORE imports that depend on the mocked modules.
- Mocking strategy from RESEARCH.md:
  - Gemini API: Mock `@google/generative-ai` with realistic JSON responses; test both success and validation failures
  - fal.ai: Mock `@fal-ai/serverless-client` subscribe() to simulate async queue
  - Supabase: Mock `@/lib/supabase/server`, `@/lib/supabase/admin`, `../../lib/supabase/admin` (worker paths)
  - BullMQ: Mock job object with updateProgress stub
- Wave 0 rule: tests MUST fail initially because source files don't exist yet. Do NOT implement source files here.
- Worker test files use relative paths: `../../lib/supabase/admin` (not @/ aliases)
- Use `jest.fn()` stubs — do not import from unbuilt source modules in mock implementations
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold library unit tests (title-remixer, script-remixer, thumbnail-analyzer, thumbnail-remixer)</name>
  <files>
    src/lib/remix/__tests__/title-remixer.test.ts
    src/lib/remix/__tests__/script-remixer.test.ts
    src/lib/remix/__tests__/thumbnail-analyzer.test.ts
    src/lib/remix/__tests__/thumbnail-remixer.test.ts
  </files>
  <action>
Create the `src/lib/remix/__tests__/` directory and write 4 test files. All tests must fail with MODULE_NOT_FOUND or similar until Plans 01-02 create the source files.

**`src/lib/remix/__tests__/title-remixer.test.ts`** — R3.1

```typescript
// Mock @google/generative-ai BEFORE any imports that use it
jest.mock('@google/generative-ai', () => ({
  GoogleGenerativeAI: jest.fn().mockImplementation(() => ({
    getGenerativeModel: jest.fn().mockReturnValue({
      generateContent: jest.fn(),
    }),
  })),
}));

// Mock getServerConfig to avoid process.env reads
jest.mock('@/lib/remix-engine/config', () => ({
  getServerConfig: jest.fn().mockReturnValue({
    apiKeys: { gemini: 'test-gemini-key', falAi: 'test-fal-key' },
  }),
}));

import { GoogleGenerativeAI } from '@google/generative-ai';
import { generateTitleVariations } from '../title-remixer';

const mockGeminiResponse = {
  variations: [
    { style: 'Curiosity Gap', title: 'What nobody tells you about this topic', reasoning: 'Creates mystery' },
    { style: 'Direct Value', title: 'The complete guide to getting results', reasoning: 'Clear promise' },
    { style: 'Contrarian', title: 'Why conventional wisdom is wrong here', reasoning: 'Challenges norms' },
    { style: 'Listicle', title: '7 ways to improve your results today', reasoning: 'Numbered format' },
    { style: 'Question', title: 'Are you making this common mistake?', reasoning: 'Provocative' },
    { style: 'Emotional Hook', title: 'I almost gave up until I found this', reasoning: 'Emotional journey' },
    { style: 'Tutorial', title: 'How to achieve your goal step by step', reasoning: 'Instructional' },
    { style: 'Story-Driven', title: 'The day everything changed for me', reasoning: 'Narrative hook' },
  ],
};

describe('generateTitleVariations', () => {
  beforeEach(() => {
    const MockGAI = GoogleGenerativeAI as jest.MockedClass<typeof GoogleGenerativeAI>;
    MockGAI.mockImplementation(() => ({
      getGenerativeModel: jest.fn().mockReturnValue({
        generateContent: jest.fn().mockResolvedValue({
          response: { text: () => JSON.stringify(mockGeminiResponse) },
        }),
      }),
    }) as unknown as InstanceType<typeof GoogleGenerativeAI>);
  });

  it('returns exactly 8 title variations', async () => {
    const result = await generateTitleVariations({
      originalTitle: 'Test Video',
      description: 'A test description',
      channelName: 'TestChannel',
    });
    expect(result.variations).toHaveLength(8);
  });

  it('each variation has style, title, and reasoning fields', async () => {
    const result = await generateTitleVariations({
      originalTitle: 'Test Video',
      description: 'A test description',
      channelName: 'TestChannel',
    });
    for (const v of result.variations) {
      expect(v).toHaveProperty('style');
      expect(v).toHaveProperty('title');
      expect(v).toHaveProperty('reasoning');
    }
  });

  it('throws a descriptive error when Gemini returns invalid JSON', async () => {
    const MockGAI = GoogleGenerativeAI as jest.MockedClass<typeof GoogleGenerativeAI>;
    MockGAI.mockImplementation(() => ({
      getGenerativeModel: jest.fn().mockReturnValue({
        generateContent: jest.fn().mockResolvedValue({
          response: { text: () => 'not valid json at all' },
        }),
      }),
    }) as unknown as InstanceType<typeof GoogleGenerativeAI>);

    await expect(
      generateTitleVariations({ originalTitle: 'T', description: '', channelName: '' })
    ).rejects.toThrow(/invalid JSON/i);
  });

  it('throws a descriptive error when Zod schema validation fails (wrong variation count)', async () => {
    const badResponse = { variations: [mockGeminiResponse.variations[0]] }; // Only 1 instead of 8
    const MockGAI = GoogleGenerativeAI as jest.MockedClass<typeof GoogleGenerativeAI>;
    MockGAI.mockImplementation(() => ({
      getGenerativeModel: jest.fn().mockReturnValue({
        generateContent: jest.fn().mockResolvedValue({
          response: { text: () => JSON.stringify(badResponse) },
        }),
      }),
    }) as unknown as InstanceType<typeof GoogleGenerativeAI>);

    await expect(
      generateTitleVariations({ originalTitle: 'T', description: '', channelName: '' })
    ).rejects.toThrow(/schema validation failed/i);
  });

  it('does not call process.env directly (uses getServerConfig)', async () => {
    const getServerConfigMock = jest.requireMock('@/lib/remix-engine/config').getServerConfig;
    await generateTitleVariations({ originalTitle: 'T', description: '', channelName: '' });
    expect(getServerConfigMock).toHaveBeenCalled();
  });
});
```

**`src/lib/remix/__tests__/script-remixer.test.ts`** — R3.3

```typescript
jest.mock('@google/generative-ai', () => ({
  GoogleGenerativeAI: jest.fn().mockImplementation(() => ({
    getGenerativeModel: jest.fn().mockReturnValue({
      generateContent: jest.fn(),
    }),
  })),
}));

jest.mock('@/lib/remix-engine/config', () => ({
  getServerConfig: jest.fn().mockReturnValue({
    apiKeys: { gemini: 'test-key' },
  }),
}));

import { GoogleGenerativeAI } from '@google/generative-ai';
import { generateRemixedScript } from '../script-remixer';

const mockScriptResponse = {
  tone: 'energetic',
  target_audience: 'general',
  scenes: [
    { scene_number: 1, dialogue_line: 'Opening hook here.', duration_seconds: 20, broll_description: 'Wide establishing shot' },
    { scene_number: 2, dialogue_line: 'Main content explained.', duration_seconds: 35, broll_description: 'Close-up detail shot' },
    { scene_number: 3, dialogue_line: 'Call to action.', duration_seconds: 15, broll_description: 'Person looking at camera' },
  ],
};

describe('generateRemixedScript', () => {
  beforeEach(() => {
    const MockGAI = GoogleGenerativeAI as jest.MockedClass<typeof GoogleGenerativeAI>;
    MockGAI.mockImplementation(() => ({
      getGenerativeModel: jest.fn().mockReturnValue({
        generateContent: jest.fn().mockResolvedValue({
          response: { text: () => JSON.stringify(mockScriptResponse) },
        }),
      }),
    }) as unknown as InstanceType<typeof GoogleGenerativeAI>);
  });

  it('returns scenes with duration_seconds between 15 and 45', async () => {
    const result = await generateRemixedScript({
      originalTitle: 'Test',
      originalTranscript: 'Full transcript here for testing purposes.',
      channelName: 'TestChan',
    });
    for (const scene of result.scenes) {
      expect(scene.duration_seconds).toBeGreaterThanOrEqual(15);
      expect(scene.duration_seconds).toBeLessThanOrEqual(45);
    }
  });

  it('returns scenes with sequential scene numbers starting at 1', async () => {
    const result = await generateRemixedScript({
      originalTitle: 'Test',
      originalTranscript: 'Full transcript.',
      channelName: 'TestChan',
    });
    result.scenes.forEach((scene, idx) => {
      expect(scene.scene_number).toBe(idx + 1);
    });
  });

  it('throws when scene numbers are not sequential', async () => {
    const badResponse = {
      ...mockScriptResponse,
      scenes: [
        { scene_number: 1, dialogue_line: 'First.', duration_seconds: 20, broll_description: 'Shot 1' },
        { scene_number: 3, dialogue_line: 'Skip 2.', duration_seconds: 20, broll_description: 'Shot 3' }, // gap
      ],
    };
    const MockGAI = GoogleGenerativeAI as jest.MockedClass<typeof GoogleGenerativeAI>;
    MockGAI.mockImplementation(() => ({
      getGenerativeModel: jest.fn().mockReturnValue({
        generateContent: jest.fn().mockResolvedValue({
          response: { text: () => JSON.stringify(badResponse) },
        }),
      }),
    }) as unknown as InstanceType<typeof GoogleGenerativeAI>);

    await expect(
      generateRemixedScript({ originalTitle: 'T', originalTranscript: 'T', channelName: '' })
    ).rejects.toThrow(/sequential/i);
  });

  it('throws when duration_seconds is outside 15-45 range', async () => {
    const badResponse = {
      ...mockScriptResponse,
      scenes: [
        { scene_number: 1, dialogue_line: 'Too long scene.', duration_seconds: 60, broll_description: 'Shot' },
      ],
    };
    const MockGAI = GoogleGenerativeAI as jest.MockedClass<typeof GoogleGenerativeAI>;
    MockGAI.mockImplementation(() => ({
      getGenerativeModel: jest.fn().mockReturnValue({
        generateContent: jest.fn().mockResolvedValue({
          response: { text: () => JSON.stringify(badResponse) },
        }),
      }),
    }) as unknown as InstanceType<typeof GoogleGenerativeAI>);

    await expect(
      generateRemixedScript({ originalTitle: 'T', originalTranscript: 'T', channelName: '' })
    ).rejects.toThrow(/schema validation failed/i);
  });
});
```

**`src/lib/remix/__tests__/thumbnail-analyzer.test.ts`** — R3.2 (graceful degradation)

```typescript
jest.mock('@google/generative-ai', () => ({
  GoogleGenerativeAI: jest.fn().mockImplementation(() => ({
    getGenerativeModel: jest.fn().mockReturnValue({
      generateContent: jest.fn(),
    }),
  })),
}));

jest.mock('@/lib/remix-engine/config', () => ({
  getServerConfig: jest.fn().mockReturnValue({
    apiKeys: { gemini: 'test-key' },
  }),
}));

// Mock global fetch
global.fetch = jest.fn();

import { analyzeThumbnail } from '../thumbnail-analyzer';

describe('analyzeThumbnail', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('returns a fallback string (does not throw) when fetch fails', async () => {
    (global.fetch as jest.Mock).mockRejectedValue(new Error('Network error'));
    const result = await analyzeThumbnail('https://example.com/thumb.jpg');
    expect(typeof result).toBe('string');
    expect(result.length).toBeGreaterThan(0);
  });

  it('returns a fallback string (does not throw) when HTTP response is not ok', async () => {
    (global.fetch as jest.Mock).mockResolvedValue({ ok: false, status: 404 });
    const result = await analyzeThumbnail('https://example.com/thumb.jpg');
    expect(typeof result).toBe('string');
  });

  it('returns Gemini analysis text on success', async () => {
    const mockBuffer = Buffer.from('fake-image-data');
    (global.fetch as jest.Mock).mockResolvedValue({
      ok: true,
      arrayBuffer: jest.fn().mockResolvedValue(mockBuffer.buffer),
    });

    const { GoogleGenerativeAI } = jest.requireMock('@google/generative-ai');
    GoogleGenerativeAI.mockImplementation(() => ({
      getGenerativeModel: jest.fn().mockReturnValue({
        generateContent: jest.fn().mockResolvedValue({
          response: { text: () => 'Bright thumbnail with bold red text and centered face.' },
        }),
      }),
    }));

    const result = await analyzeThumbnail('https://example.com/thumb.jpg');
    expect(result).toContain('Bright thumbnail');
  });

  it('returns fallback string when Gemini analysis call throws', async () => {
    const mockBuffer = Buffer.from('fake-image-data');
    (global.fetch as jest.Mock).mockResolvedValue({
      ok: true,
      arrayBuffer: jest.fn().mockResolvedValue(mockBuffer.buffer),
    });

    const { GoogleGenerativeAI } = jest.requireMock('@google/generative-ai');
    GoogleGenerativeAI.mockImplementation(() => ({
      getGenerativeModel: jest.fn().mockReturnValue({
        generateContent: jest.fn().mockRejectedValue(new Error('Gemini quota exceeded')),
      }),
    }));

    const result = await analyzeThumbnail('https://example.com/thumb.jpg');
    expect(typeof result).toBe('string');
    expect(result.length).toBeGreaterThan(0);
  });
});
```

**`src/lib/remix/__tests__/thumbnail-remixer.test.ts`** — R3.2 (fal.ai 1280x720)

```typescript
jest.mock('@fal-ai/serverless-client', () => ({
  config: jest.fn(),
  subscribe: jest.fn(),
}));

jest.mock('@/lib/remix-engine/config', () => ({
  getServerConfig: jest.fn().mockReturnValue({
    apiKeys: { gemini: 'test-gemini', falAi: 'test-fal' },
  }),
}));

// analyzeThumbnail is called internally — mock it to avoid needing Gemini
jest.mock('../thumbnail-analyzer', () => ({
  analyzeThumbnail: jest.fn().mockResolvedValue('Mock analysis text.'),
}));

import * as fal from '@fal-ai/serverless-client';
import { generateThumbnailVariation } from '../thumbnail-remixer';

describe('generateThumbnailVariation', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    (fal.subscribe as jest.Mock).mockResolvedValue({
      images: [{ url: 'https://fal.ai/files/test-image.jpg' }],
    });
  });

  it('calls fal.subscribe with fal-ai/flux/dev model', async () => {
    await generateThumbnailVariation({
      videoId: 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
      videoTitle: 'Test Video',
      videoDescription: 'Test description',
      style: 'bold-text-overlay',
    });
    expect(fal.subscribe).toHaveBeenCalledWith(
      'fal-ai/flux/dev',
      expect.objectContaining({ input: expect.any(Object) })
    );
  });

  it('requests 1280x720 image dimensions', async () => {
    await generateThumbnailVariation({
      videoId: 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
      videoTitle: 'Test Video',
      videoDescription: 'Test description',
      style: 'cinematic-scene',
    });
    const callArgs = (fal.subscribe as jest.Mock).mock.calls[0][1];
    expect(callArgs.input.image_size).toEqual({ width: 1280, height: 720 });
  });

  it('returns falUrl, prompt, and analysis from the response', async () => {
    const result = await generateThumbnailVariation({
      videoId: 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
      videoTitle: 'Test Video',
      videoDescription: 'Description',
      style: 'face-reaction',
    });
    expect(result).toHaveProperty('falUrl');
    expect(result).toHaveProperty('prompt');
    expect(result).toHaveProperty('analysis');
    expect(result.falUrl).toBe('https://fal.ai/files/test-image.jpg');
  });

  it('throws when fal.ai returns no images', async () => {
    (fal.subscribe as jest.Mock).mockResolvedValue({ images: [] });
    await expect(
      generateThumbnailVariation({
        videoId: 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
        videoTitle: 'T',
        videoDescription: '',
        style: 'bold-text-overlay',
      })
    ).rejects.toThrow(/no images/i);
  });

  it('calls onProgress callback when provided', async () => {
    const onProgress = jest.fn();
    // Simulate onQueueUpdate being called during subscribe
    (fal.subscribe as jest.Mock).mockImplementation((_model, opts) => {
      opts.onQueueUpdate?.({ status: 'IN_PROGRESS' });
      return Promise.resolve({ images: [{ url: 'https://fal.ai/files/test.jpg' }] });
    });

    await generateThumbnailVariation(
      { videoId: 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', videoTitle: 'T', videoDescription: '', style: 'bold-text-overlay' },
      onProgress
    );
    expect(onProgress).toHaveBeenCalled();
  });
});
```
  </action>
  <verify>
    <automated>npm run test -- --testPathPattern='src/lib/remix/__tests__' --passWithNoTests 2>&1 | grep -E "(PASS|FAIL|Cannot find module|Tests:)" | head -20</automated>
  </verify>
  <done>
    - All 4 test files exist under `src/lib/remix/__tests__/`
    - Jest discovers all 4 files without syntax errors
    - Tests either pass (if source exists) or fail with MODULE_NOT_FOUND / import error (expected in Wave 0)
    - No test file throws a syntax or compilation error at the describe/it level
  </done>
</task>

<task type="auto">
  <name>Task 2: Scaffold API route, worker, and UI tests</name>
  <files>
    src/app/api/remix-engine/remix/__tests__/route.test.ts
    src/app/api/remix-engine/remix/__tests__/selection.test.ts
    src/app/api/remix-engine/__tests__/gate.test.ts
    src/worker/__tests__/remix-handler.test.ts
    src/components/__tests__/RemixReviewPage.test.tsx
  </files>
  <action>
Create the remaining 5 test files. These cover API routes, the worker handler, and the UI component.

**`src/app/api/remix-engine/remix/__tests__/route.test.ts`** — R3.4

```typescript
// Mock Supabase clients
jest.mock('@/lib/supabase/server', () => ({
  createClient: jest.fn(),
}));

jest.mock('@/lib/queue/queues', () => ({
  remixQueue: { add: jest.fn().mockResolvedValue({}) },
}));

import { createClient } from '@/lib/supabase/server';
import { remixQueue } from '@/lib/queue/queues';
import { POST as titlePost } from '../title/route';
import { POST as thumbnailPost } from '../thumbnail/route';
import { POST as scriptPost } from '../script/route';
import { NextRequest } from 'next/server';

const mockUser = { id: 'user-uuid-1234' };
const mockVideo = {
  original_title: 'Test Video',
  original_description: 'Desc',
  channel_name: 'Chan',
  duration_seconds: 120,
  original_thumbnail_url: null,
  original_transcript: 'Full transcript text.',
};
const mockJob = { id: 'job-uuid-5678' };

function makeSupabaseMock(overrides: Record<string, unknown> = {}) {
  return {
    auth: { getUser: jest.fn().mockResolvedValue({ data: { user: mockUser } }) },
    from: jest.fn().mockReturnValue({
      select: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      single: jest.fn().mockResolvedValue({ data: mockVideo }),
      insert: jest.fn().mockReturnThis(),
      ...overrides,
    }),
  };
}

describe('POST /api/remix-engine/remix/title', () => {
  it('returns 401 when unauthenticated', async () => {
    const mockClient = {
      auth: { getUser: jest.fn().mockResolvedValue({ data: { user: null } }) },
    };
    (createClient as jest.Mock).mockResolvedValue(mockClient);

    const req = new NextRequest('http://localhost/api/remix-engine/remix/title', {
      method: 'POST',
      body: JSON.stringify({ videoId: 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', projectId: 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb' }),
      headers: { 'Content-Type': 'application/json' },
    });
    const res = await titlePost(req);
    expect(res.status).toBe(401);
  });

  it('returns 202 and enqueues job when authenticated', async () => {
    const mockClient = makeSupabaseMock();
    // insert chain returns job id
    mockClient.from.mockReturnValue({
      select: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      single: jest.fn()
        .mockResolvedValueOnce({ data: mockVideo })  // video fetch
        .mockResolvedValueOnce({ data: mockJob }),   // job insert
      insert: jest.fn().mockReturnThis(),
    });
    (createClient as jest.Mock).mockResolvedValue(mockClient);

    const req = new NextRequest('http://localhost/api/remix-engine/remix/title', {
      method: 'POST',
      body: JSON.stringify({ videoId: 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', projectId: 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb' }),
      headers: { 'Content-Type': 'application/json' },
    });
    const res = await titlePost(req);
    expect(res.status).toBe(202);
    const json = await res.json();
    expect(json).toHaveProperty('jobId');
    expect(remixQueue.add).toHaveBeenCalledWith('remix_title', expect.objectContaining({ type: 'title' }));
  });
});

describe('POST /api/remix-engine/remix/thumbnail', () => {
  it('returns 202 and enqueues 3 jobs when no style specified', async () => {
    const mockClient = makeSupabaseMock();
    let insertCallCount = 0;
    mockClient.from.mockReturnValue({
      select: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      single: jest.fn().mockImplementation(() => {
        insertCallCount++;
        return Promise.resolve({ data: insertCallCount === 1 ? mockVideo : { id: `job-${insertCallCount}` } });
      }),
      insert: jest.fn().mockReturnThis(),
    });
    (createClient as jest.Mock).mockResolvedValue(mockClient);

    const req = new NextRequest('http://localhost/api/remix-engine/remix/thumbnail', {
      method: 'POST',
      body: JSON.stringify({ videoId: 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', projectId: 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb' }),
      headers: { 'Content-Type': 'application/json' },
    });
    const res = await thumbnailPost(req);
    expect(res.status).toBe(202);
  });
});

describe('POST /api/remix-engine/remix/script', () => {
  it('returns 422 when video has no transcript', async () => {
    const mockClient = makeSupabaseMock();
    mockClient.from.mockReturnValue({
      select: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      single: jest.fn().mockResolvedValue({ data: { ...mockVideo, original_transcript: null } }),
    });
    (createClient as jest.Mock).mockResolvedValue(mockClient);

    const req = new NextRequest('http://localhost/api/remix-engine/remix/script', {
      method: 'POST',
      body: JSON.stringify({ videoId: 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', projectId: 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb' }),
      headers: { 'Content-Type': 'application/json' },
    });
    const res = await scriptPost(req);
    expect(res.status).toBe(422);
  });
});
```

**`src/app/api/remix-engine/remix/__tests__/selection.test.ts`** — R3.5

```typescript
jest.mock('@/lib/supabase/server', () => ({
  createClient: jest.fn(),
}));

import { createClient } from '@/lib/supabase/server';
import { POST, PATCH } from '../select/route';
import { NextRequest } from 'next/server';

const mockUser = { id: 'user-uuid' };

function makeSupabaseMock() {
  return {
    auth: { getUser: jest.fn().mockResolvedValue({ data: { user: mockUser } }) },
    from: jest.fn().mockReturnValue({
      update: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      // Final .eq() in the update chain must resolve
      then: jest.fn().mockResolvedValue({ error: null }),
    }),
  };
}

describe('POST /api/remix-engine/remix/select', () => {
  it('returns 401 when unauthenticated', async () => {
    (createClient as jest.Mock).mockResolvedValue({
      auth: { getUser: jest.fn().mockResolvedValue({ data: { user: null } }) },
    });
    const req = new NextRequest('http://localhost/api/remix-engine/remix/select', {
      method: 'POST',
      body: JSON.stringify({ videoId: 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', type: 'title', id: 'cccccccc-cccc-cccc-cccc-cccccccccccc' }),
      headers: { 'Content-Type': 'application/json' },
    });
    const res = await POST(req);
    expect(res.status).toBe(401);
  });

  it('clears existing selections and sets the chosen one', async () => {
    const updateMock = jest.fn().mockReturnThis();
    const eqMock = jest.fn().mockReturnThis();
    // Last update chain resolves
    eqMock.mockReturnValueOnce({ error: null });

    const mockClient = {
      auth: { getUser: jest.fn().mockResolvedValue({ data: { user: mockUser } }) },
      from: jest.fn().mockReturnValue({ update: updateMock, eq: eqMock }),
    };
    (createClient as jest.Mock).mockResolvedValue(mockClient);

    const req = new NextRequest('http://localhost/api/remix-engine/remix/select', {
      method: 'POST',
      body: JSON.stringify({ videoId: 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', type: 'title', id: 'cccccccc-cccc-cccc-cccc-cccccccccccc' }),
      headers: { 'Content-Type': 'application/json' },
    });
    const res = await POST(req);
    // Expect the route to call update twice: once to clear, once to set
    expect(updateMock).toHaveBeenCalledWith({ is_selected: false });
    expect(updateMock).toHaveBeenCalledWith(expect.objectContaining({ is_selected: true }));
  });

  it('accepts editedText and saves it for title type', async () => {
    const updateMock = jest.fn().mockReturnThis();
    const eqMock = jest.fn().mockReturnThis();
    eqMock.mockReturnValueOnce({ error: null });

    const mockClient = {
      auth: { getUser: jest.fn().mockResolvedValue({ data: { user: mockUser } }) },
      from: jest.fn().mockReturnValue({ update: updateMock, eq: eqMock }),
    };
    (createClient as jest.Mock).mockResolvedValue(mockClient);

    const req = new NextRequest('http://localhost/api/remix-engine/remix/select', {
      method: 'POST',
      body: JSON.stringify({
        videoId: 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
        type: 'title',
        id: 'cccccccc-cccc-cccc-cccc-cccccccccccc',
        editedText: 'My custom title edit',
      }),
      headers: { 'Content-Type': 'application/json' },
    });
    await POST(req);
    expect(updateMock).toHaveBeenCalledWith(expect.objectContaining({ title: 'My custom title edit', is_selected: true }));
  });
});

describe('PATCH /api/remix-engine/remix/select (scene edit)', () => {
  it('updates dialogue_line for the given sceneId', async () => {
    const updateMock = jest.fn().mockReturnThis();
    const eqMock = jest.fn().mockReturnValue({ error: null });

    const mockClient = {
      auth: { getUser: jest.fn().mockResolvedValue({ data: { user: mockUser } }) },
      from: jest.fn().mockReturnValue({ update: updateMock, eq: eqMock }),
    };
    (createClient as jest.Mock).mockResolvedValue(mockClient);

    const req = new NextRequest('http://localhost/api/remix-engine/remix/select', {
      method: 'PATCH',
      body: JSON.stringify({ sceneId: 'dddddddd-dddd-dddd-dddd-dddddddddddd', dialogueLine: 'Edited scene text.' }),
      headers: { 'Content-Type': 'application/json' },
    });
    const res = await PATCH(req);
    expect(res.status).toBe(200);
    expect(updateMock).toHaveBeenCalledWith({ dialogue_line: 'Edited scene text.' });
  });
});
```

**`src/app/api/remix-engine/__tests__/gate.test.ts`** — R3.6

```typescript
jest.mock('@/lib/supabase/server', () => ({
  createClient: jest.fn(),
}));

import { createClient } from '@/lib/supabase/server';
import { POST } from '../videos/[videoId]/approve/route';
import { NextRequest } from 'next/server';

const mockUser = { id: 'user-uuid' };

describe('POST /api/remix-engine/videos/[videoId]/approve', () => {
  it('returns 401 when unauthenticated', async () => {
    (createClient as jest.Mock).mockResolvedValue({
      auth: { getUser: jest.fn().mockResolvedValue({ data: { user: null } }) },
    });
    const req = new NextRequest('http://localhost/api/remix-engine/videos/test-id/approve', { method: 'POST' });
    const res = await POST(req, { params: Promise.resolve({ videoId: 'test-id' }) });
    expect(res.status).toBe(401);
  });

  it('returns 422 when title is not selected', async () => {
    (createClient as jest.Mock).mockResolvedValue({
      auth: { getUser: jest.fn().mockResolvedValue({ data: { user: mockUser } }) },
      from: jest.fn().mockReturnValue({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        // titles: empty, thumbnails: has data, scripts: has data
        then: jest.fn().mockResolvedValue({ data: [] }),
      }),
    });

    const mockClient = {
      auth: { getUser: jest.fn().mockResolvedValue({ data: { user: mockUser } }) },
      from: jest.fn().mockImplementation((table: string) => ({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        // Return empty for titles, data for others
        then: jest.fn().mockImplementation((cb) => {
          if (table === 're_remixed_titles') return Promise.resolve(cb({ data: [] }));
          return Promise.resolve(cb({ data: [{ id: 'some-id' }] }));
        }),
      })),
    };
    (createClient as jest.Mock).mockResolvedValue(mockClient);

    const req = new NextRequest('http://localhost/api/remix-engine/videos/test-id/approve', { method: 'POST' });
    const res = await POST(req, { params: Promise.resolve({ videoId: 'test-id' }) });
    expect(res.status).toBe(422);
  });

  it('returns 200 with success:true when all selections exist', async () => {
    const mockClient = {
      auth: { getUser: jest.fn().mockResolvedValue({ data: { user: mockUser } }) },
      from: jest.fn().mockReturnValue({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        // Always return 1 item (selections exist)
        then: jest.fn().mockImplementation((cb) => Promise.resolve(cb({ data: [{ id: 'item-id' }] }))),
      }),
    };
    (createClient as jest.Mock).mockResolvedValue(mockClient);

    const req = new NextRequest('http://localhost/api/remix-engine/videos/vid-id/approve', { method: 'POST' });
    const res = await POST(req, { params: Promise.resolve({ videoId: 'vid-id' }) });
    expect(res.status).toBe(200);
    const json = await res.json();
    expect(json.success).toBe(true);
  });
});
```

**`src/worker/__tests__/remix-handler.test.ts`** — R3.7

```typescript
// Worker handler uses relative imports — mock accordingly
jest.mock('../../lib/supabase/admin', () => ({
  supabaseAdmin: {
    from: jest.fn().mockReturnValue({
      update: jest.fn().mockReturnThis(),
      delete: jest.fn().mockReturnThis(),
      insert: jest.fn().mockReturnThis(),
      select: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      in: jest.fn().mockReturnThis(),
      like: jest.fn().mockReturnThis(),
      single: jest.fn().mockResolvedValue({ data: { id: 'script-id' }, error: null }),
      then: jest.fn().mockResolvedValue({ error: null }),
    }),
    storage: {
      from: jest.fn().mockReturnValue({
        upload: jest.fn().mockResolvedValue({ error: null }),
      }),
    },
  },
}));

jest.mock('../../lib/remix/title-remixer', () => ({
  generateTitleVariations: jest.fn().mockResolvedValue({
    variations: Array(8).fill({ style: 'Curiosity Gap', title: 'Test', reasoning: 'r' }),
  }),
}));

jest.mock('../../lib/remix/thumbnail-remixer', () => ({
  generateThumbnailVariation: jest.fn().mockResolvedValue({
    falUrl: 'https://fal.ai/files/test.jpg',
    prompt: 'test prompt',
    analysis: 'test analysis',
  }),
}));

jest.mock('../../lib/remix/script-remixer', () => ({
  generateRemixedScript: jest.fn().mockResolvedValue({
    scenes: [
      { scene_number: 1, dialogue_line: 'Scene 1', duration_seconds: 20, broll_description: 'Shot 1' },
    ],
    tone: 'energetic',
    target_audience: 'general',
  }),
}));

jest.mock('../../lib/remix-engine/hooks', () => ({
  storagePath: jest.fn((...args: string[]) => args.join('/')),
}));

// Mock global fetch for thumbnail download
global.fetch = jest.fn().mockResolvedValue({
  ok: true,
  arrayBuffer: jest.fn().mockResolvedValue(Buffer.from('fake-image').buffer),
});

import { handleRemixJob } from '../../worker/handlers/remix';
import type { Job } from 'bullmq';

function makeJob(data: Record<string, unknown>): Job {
  return {
    data,
    updateProgress: jest.fn().mockResolvedValue(undefined),
  } as unknown as Job;
}

describe('handleRemixJob', () => {
  it('dispatches to title handler for type: title', async () => {
    const { generateTitleVariations } = jest.requireMock('../../lib/remix/title-remixer');
    const job = makeJob({
      type: 'title',
      jobId: 'job-1',
      videoId: 'vid-1',
      projectId: 'proj-1',
      video: { originalTitle: 'Test', description: 'Desc', channelName: 'Chan' },
    });
    await handleRemixJob(job);
    expect(generateTitleVariations).toHaveBeenCalled();
  });

  it('dispatches to thumbnail handler for type: thumbnail', async () => {
    const { generateThumbnailVariation } = jest.requireMock('../../lib/remix/thumbnail-remixer');
    const job = makeJob({
      type: 'thumbnail',
      jobId: 'job-2',
      videoId: 'vid-1',
      projectId: 'proj-1',
      style: 'bold-text-overlay',
      video: { originalTitle: 'Test', originalDescription: 'Desc', originalThumbnailUrl: null },
    });
    await handleRemixJob(job);
    expect(generateThumbnailVariation).toHaveBeenCalled();
  });

  it('dispatches to script handler for type: script', async () => {
    const { generateRemixedScript } = jest.requireMock('../../lib/remix/script-remixer');
    const job = makeJob({
      type: 'script',
      jobId: 'job-3',
      videoId: 'vid-1',
      projectId: 'proj-1',
      video: { originalTitle: 'Test', originalTranscript: 'Transcript text', channelName: 'Chan' },
    });
    await handleRemixJob(job);
    expect(generateRemixedScript).toHaveBeenCalled();
  });

  it('throws for unknown job type', async () => {
    const job = makeJob({
      type: 'unknown',
      jobId: 'job-4',
      videoId: 'vid-1',
      projectId: 'proj-1',
      video: {},
    });
    await expect(handleRemixJob(job)).rejects.toThrow(/unknown remix job type/i);
  });

  it('updates job progress to 100 on completion', async () => {
    const job = makeJob({
      type: 'title',
      jobId: 'job-5',
      videoId: 'vid-1',
      projectId: 'proj-1',
      video: { originalTitle: 'Test', description: '', channelName: '' },
    });
    await handleRemixJob(job);
    expect(job.updateProgress).toHaveBeenCalledWith(100);
  });
});
```

**`src/components/__tests__/RemixReviewPage.test.tsx`** — R3.4/R3.5 (UI)

```typescript
import React from 'react';
import { render, screen } from '@testing-library/react';
import { RemixReviewPage } from '../remix/RemixReviewPage';

// Mock Next.js navigation
jest.mock('next/navigation', () => ({
  useRouter: jest.fn().mockReturnValue({ push: jest.fn() }),
}));

// Mock fetch for API calls
global.fetch = jest.fn().mockResolvedValue({
  ok: true,
  json: jest.fn().mockResolvedValue({ success: true }),
});

const mockTitles = Array(8).fill(null).map((_, i) => ({
  id: `title-${i}`,
  style: 'Curiosity Gap',
  title: `Title variation ${i + 1}`,
  reasoning: `Reasoning ${i + 1}`,
  is_selected: i === 0,
}));

const mockThumbnails = [
  { id: 'thumb-1', prompt: 'bold prompt', file_path: 'thumbnails/bold.jpg', is_selected: false, signedUrl: null },
  { id: 'thumb-2', prompt: 'cinematic prompt', file_path: 'thumbnails/cinematic.jpg', is_selected: false, signedUrl: null },
  { id: 'thumb-3', prompt: 'face prompt', file_path: 'thumbnails/face.jpg', is_selected: false, signedUrl: null },
];

const mockScenes = [
  { id: 'scene-1', scene_number: 1, dialogue_line: 'Opening scene dialogue.', duration_seconds: 20, broll_description: 'Wide shot' },
  { id: 'scene-2', scene_number: 2, dialogue_line: 'Main content dialogue.', duration_seconds: 30, broll_description: 'Close-up' },
];

describe('RemixReviewPage', () => {
  it('renders all 8 title variations', () => {
    render(
      <RemixReviewPage
        videoId="vid-1"
        projectId="proj-1"
        titles={mockTitles}
        thumbnails={mockThumbnails}
        scenes={mockScenes}
      />
    );
    expect(screen.getAllByText(/Title variation \d+/)).toHaveLength(8);
  });

  it('renders Approve & Continue button disabled when no thumbnail is selected', () => {
    render(
      <RemixReviewPage
        videoId="vid-1"
        projectId="proj-1"
        titles={mockTitles}
        thumbnails={mockThumbnails}
        scenes={mockScenes}
      />
    );
    const approveButton = screen.getByRole('button', { name: /approve/i });
    // hasThumbnailSelected is false (none selected) → button should be disabled
    expect(approveButton).toBeDisabled();
  });

  it('renders the approval checklist with 3 items', () => {
    render(
      <RemixReviewPage
        videoId="vid-1"
        projectId="proj-1"
        titles={mockTitles}
        thumbnails={mockThumbnails}
        scenes={mockScenes}
      />
    );
    expect(screen.getByText('Title selected')).toBeInTheDocument();
    expect(screen.getByText('Thumbnail selected')).toBeInTheDocument();
    expect(screen.getByText('Script reviewed')).toBeInTheDocument();
  });

  it('renders scene cards for each scene', () => {
    render(
      <RemixReviewPage
        videoId="vid-1"
        projectId="proj-1"
        titles={mockTitles}
        thumbnails={mockThumbnails}
        scenes={mockScenes}
      />
    );
    expect(screen.getByText('Scene 1')).toBeInTheDocument();
    expect(screen.getByText('Scene 2')).toBeInTheDocument();
  });
});
```
  </action>
  <verify>
    <automated>npm run test -- --testPathPattern='(remix/__tests__|api/remix-engine/(remix|__tests__)|worker/__tests__|components/__tests__/RemixReview)' --passWithNoTests 2>&1 | grep -E "(PASS|FAIL|Cannot find module|Test Suites:)" | head -20</automated>
  </verify>
  <done>
    - All 5 test files exist at their target paths
    - `__tests__` directories created as needed
    - Jest discovers all files without syntax errors
    - Tests fail with MODULE_NOT_FOUND or similar (expected — source not yet built)
    - No test file has a TypeScript/syntax error that prevents Jest from loading it
  </done>
</task>

</tasks>

<verification>
```bash
npm run test -- --testPathPattern='remix' --passWithNoTests 2>&1 | tail -20
```
All 9 test files are discovered. Tests may fail with MODULE_NOT_FOUND (Wave 0 state) but must NOT fail due to syntax errors in the test files themselves.
</verification>

<success_criteria>
- 9 test files exist under their specified paths
- `npm run test -- --testPathPattern='remix' --passWithNoTests` exits without crashing Jest (test failures are acceptable, Jest process errors are not)
- All files use jest.mock() declarations before any source imports
- Mock strategies match RESEARCH.md: Gemini mocked via @google/generative-ai, fal.ai via @fal-ai/serverless-client, Supabase via @/lib/supabase/* mocks
- Worker test mocks use relative paths (../../lib/...) not @/ aliases
</success_criteria>

<output>
After completion, create `.planning/phases/03-remix-pipeline-4-hours/03-00-SUMMARY.md`
</output>

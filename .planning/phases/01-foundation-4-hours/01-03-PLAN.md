---
phase: 01-foundation-4-hours
plan: 03
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - supabase/config.toml
  - supabase/migrations/001_initial_schema.sql
  - supabase/migrations/002_rls_policies.sql
  - supabase/migrations/003_storage_setup.sql
  - supabase/migrations/004_realtime_setup.sql
  - supabase/seed.sql
  - src/lib/supabase/types.ts
autonomous: true
requirements:
  - R1.2
  - R1.3
  - RM.4
  - RM.5

must_haves:
  truths:
    - "Supabase project is initialized locally (supabase/ directory with config.toml)"
    - "All four migration files exist and contain valid SQL"
    - "All database tables have re_ prefix (re_users, re_projects, re_videos, re_jobs, re_scenes, re_api_usage)"
    - "RLS policies are defined for all tables using re_ prefixed helper functions"
    - "Storage bucket remix-engine exists with private access policy"
    - "Realtime is enabled for re_jobs table"
    - "handle_new_user trigger creates re_users profile from auth.users on signup"
    - "Types file generated or stubbed for the schema"
  artifacts:
    - path: "supabase/config.toml"
      provides: "Supabase local development configuration"
    - path: "supabase/migrations/001_initial_schema.sql"
      provides: "Core table definitions: re_users, re_projects, re_videos, re_jobs, re_scenes, re_api_usage"
      contains: "CREATE TABLE re_"
    - path: "supabase/migrations/002_rls_policies.sql"
      provides: "RLS helper functions and per-table policies"
      contains: "is_active_user"
    - path: "supabase/migrations/003_storage_setup.sql"
      provides: "remix-engine storage bucket creation and access policies"
      contains: "remix-engine"
    - path: "supabase/migrations/004_realtime_setup.sql"
      provides: "Realtime publication for re_jobs"
      contains: "supabase_realtime"
    - path: "src/lib/supabase/types.ts"
      provides: "TypeScript types for database schema (auto-generated or hand-stubbed)"
  key_links:
    - from: "supabase/migrations/001_initial_schema.sql"
      to: "auth.users"
      via: "handle_new_user trigger on auth.users INSERT creates re_users record"
      pattern: "handle_new_user"
    - from: "supabase/migrations/002_rls_policies.sql"
      to: "re_users"
      via: "is_active_user() checks re_users.status = active"
      pattern: "is_active_user"
---

<objective>
Initialize the Supabase project locally and create all four database migration files covering the complete Phase 1 schema. This establishes the data layer that auth, queue tracking, and all future phases depend on.

Purpose: Auth depends on re_users table existing. Job queue tracking needs re_jobs. Every API route in future phases reads from these tables. The re_ prefix and RLS policies must be correct from day one.
Output: supabase/ directory with config.toml + 4 migration files + seed.sql + TypeScript types.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md

CRITICAL RULES (from CLAUDE.md):
- ALL table names must have re_ prefix — no exceptions
- Storage bucket name: "remix-engine" (with hyphen)
- All storage paths: remix-engine/{type}/{ids}/filename
- Never write bare table names — always use the re_ prefix in migrations
- Business logic uses table() helper, but migrations use the literal re_ prefixed names

SPEC REFERENCE: Read REMIXENGINE_SPEC_v3.md Section 5 for the complete SQL schema. All four migration files are specified there. This is the authoritative source for column names, types, constraints, triggers, and RLS policies. Do NOT invent schema — read it from Section 5.

KEY TABLES (from spec Section 5):
- re_users: id (uuid, refs auth.users), email, full_name, role (admin/editor/viewer), status (active/inactive/invited), created_at, updated_at
- re_projects: id (uuid), user_id (refs re_users), name, description, status, created_at, updated_at
- re_videos: id (uuid), project_id (refs re_projects), youtube_url, title, description, thumbnail_url, duration_seconds, file_size_bytes, status, created_at, updated_at
- re_jobs: id (uuid), video_id (refs re_videos), type (scrape/remix/generate/render), status (pending/processing/completed/failed), progress (0-100), error_message, metadata (jsonb), created_at, updated_at
- re_scenes: id (uuid), video_id, scene_number (unique per video), script_text, on_screen_text, duration_seconds, is_selected (boolean)
- re_api_usage: id (uuid), video_id, service, tokens_used, characters_used, minutes_used, cost_usd, created_at

<interfaces>
<!-- From Plan 01 (already built) — use these helpers in seed.sql and validation, not in migrations -->
<!-- table('users') → 're_users' -->
<!-- storagePath('videos', projectId, videoId, 'original.mp4') → 'remix-engine/videos/.../original.mp4' -->

<!-- Pattern for handle_new_user trigger (from research) -->
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO re_users (id, email, full_name, role, status)
  VALUES (
    NEW.id,
    NEW.email,
    NEW.raw_user_meta_data->>'full_name',
    COALESCE(NEW.raw_user_meta_data->>'role', 'viewer'),
    'active'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user();
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Supabase and write migration 001 (initial schema)</name>
  <files>
    supabase/config.toml
    supabase/migrations/001_initial_schema.sql
    supabase/seed.sql
  </files>
  <action>
First, initialize Supabase local config if supabase/ directory does not exist:
Run: npx supabase init

This creates supabase/config.toml. Leave config.toml at defaults — do not change project_id or ports unless there is a conflict.

Then write supabase/migrations/001_initial_schema.sql. Read REMIXENGINE_SPEC_v3.md Section 5 for the complete schema. The migration must include:

1. Enable pgcrypto for UUID generation: CREATE EXTENSION IF NOT EXISTS "pgcrypto";

2. CREATE TABLE re_users with columns: id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE, email text NOT NULL, full_name text, role text NOT NULL CHECK (role IN ('admin','editor','viewer')) DEFAULT 'viewer', status text NOT NULL CHECK (status IN ('active','inactive','invited')) DEFAULT 'active', created_at timestamptz DEFAULT now(), updated_at timestamptz DEFAULT now()

3. CREATE TABLE re_projects: id uuid PRIMARY KEY DEFAULT gen_random_uuid(), user_id uuid NOT NULL REFERENCES re_users(id) ON DELETE CASCADE, name text NOT NULL CHECK (length(name) BETWEEN 1 AND 100), description text, status text NOT NULL DEFAULT 'active', created_at timestamptz DEFAULT now(), updated_at timestamptz DEFAULT now()

4. CREATE TABLE re_videos: id uuid PRIMARY KEY DEFAULT gen_random_uuid(), project_id uuid NOT NULL REFERENCES re_projects(id) ON DELETE CASCADE, youtube_url text NOT NULL, title text, description text, thumbnail_url text, duration_seconds integer, file_size_bytes bigint, status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending','scraping','scraped','remixing','remixed','generating','generated','rendering','rendered','error')), created_at timestamptz DEFAULT now(), updated_at timestamptz DEFAULT now()

5. CREATE TABLE re_jobs: id uuid PRIMARY KEY DEFAULT gen_random_uuid(), video_id uuid NOT NULL REFERENCES re_videos(id) ON DELETE CASCADE, type text NOT NULL CHECK (type IN ('scrape','remix','generate','render')), status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending','processing','completed','failed','cancelled')), progress integer DEFAULT 0 CHECK (progress BETWEEN 0 AND 100), error_message text, metadata jsonb DEFAULT '{}', created_at timestamptz DEFAULT now(), updated_at timestamptz DEFAULT now()

6. CREATE TABLE re_scenes: id uuid PRIMARY KEY DEFAULT gen_random_uuid(), video_id uuid NOT NULL REFERENCES re_videos(id) ON DELETE CASCADE, scene_number integer NOT NULL, script_text text, on_screen_text text, duration_seconds integer, is_selected boolean DEFAULT false, created_at timestamptz DEFAULT now(), UNIQUE(video_id, scene_number)

7. CREATE TABLE re_api_usage: id uuid PRIMARY KEY DEFAULT gen_random_uuid(), video_id uuid REFERENCES re_videos(id) ON DELETE SET NULL, service text NOT NULL, tokens_used integer, characters_used integer, minutes_used numeric(10,3), cost_usd numeric(10,6), created_at timestamptz DEFAULT now()

8. Add updated_at trigger function that applies to re_users, re_projects, re_videos, re_jobs:
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = now(); RETURN NEW; END; $$ LANGUAGE plpgsql;
CREATE TRIGGER update_re_users_updated_at BEFORE UPDATE ON re_users FOR EACH ROW EXECUTE FUNCTION update_updated_at();
(Same trigger for re_projects, re_videos, re_jobs)

9. handle_new_user trigger (exactly as shown in interfaces block above)

10. supabase/seed.sql — Create one admin user entry for testing (NOTE: this inserts into re_users, not auth.users — actual auth user must be created via Supabase dashboard or CLI):
-- Seed file: run after npx supabase db push for local development
-- The auth user must be created separately via Supabase dashboard
-- This seed is only used if running supabase locally with supabase start
INSERT INTO re_users (id, email, full_name, role, status) VALUES
  ('00000000-0000-0000-0000-000000000001', 'admin@remixengine.dev', 'Admin User', 'admin', 'active')
ON CONFLICT (id) DO NOTHING;

Verify SQL syntax by checking there are no unmatched parens and table references are correct.
  </action>
  <verify>
    <automated>test -f /c/Antigravity/Sandbox/supabase/config.toml && test -f "/c/Antigravity/Sandbox/supabase/migrations/001_initial_schema.sql" && grep "CREATE TABLE re_users" "/c/Antigravity/Sandbox/supabase/migrations/001_initial_schema.sql" && grep "handle_new_user" "/c/Antigravity/Sandbox/supabase/migrations/001_initial_schema.sql" && echo "Migration 001 OK"</automated>
  </verify>
  <done>
    supabase/config.toml exists. 001_initial_schema.sql contains all six re_ prefixed tables. handle_new_user trigger defined. updated_at triggers for all mutable tables. All table names have re_ prefix. UNIQUE constraint on (video_id, scene_number) in re_scenes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write migrations 002-004 (RLS, storage, realtime) and generate types</name>
  <files>
    supabase/migrations/002_rls_policies.sql
    supabase/migrations/003_storage_setup.sql
    supabase/migrations/004_realtime_setup.sql
    src/lib/supabase/types.ts
  </files>
  <action>
Read REMIXENGINE_SPEC_v3.md Section 5 for the exact RLS policies, storage setup, and realtime configuration.

**supabase/migrations/002_rls_policies.sql** — Enable RLS and write policies:

Enable RLS on all tables:
ALTER TABLE re_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE re_projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE re_videos ENABLE ROW LEVEL SECURITY;
ALTER TABLE re_jobs ENABLE ROW LEVEL SECURITY;
ALTER TABLE re_scenes ENABLE ROW LEVEL SECURITY;
ALTER TABLE re_api_usage ENABLE ROW LEVEL SECURITY;

Helper functions (SECURITY DEFINER, search_path = public):
CREATE OR REPLACE FUNCTION is_active_user() RETURNS boolean AS $$
  SELECT EXISTS (
    SELECT 1 FROM re_users WHERE id = auth.uid() AND status = 'active'
  );
$$ LANGUAGE sql SECURITY DEFINER STABLE;

CREATE OR REPLACE FUNCTION is_editor_or_admin() RETURNS boolean AS $$
  SELECT EXISTS (
    SELECT 1 FROM re_users WHERE id = auth.uid() AND role IN ('editor','admin') AND status = 'active'
  );
$$ LANGUAGE sql SECURITY DEFINER STABLE;

CREATE OR REPLACE FUNCTION is_admin() RETURNS boolean AS $$
  SELECT EXISTS (
    SELECT 1 FROM re_users WHERE id = auth.uid() AND role = 'admin' AND status = 'active'
  );
$$ LANGUAGE sql SECURITY DEFINER STABLE;

Policies:
- re_users: SELECT for is_active_user() (own record or admin sees all), UPDATE for own record only, admin can UPDATE all
- re_projects: SELECT for is_active_user(), INSERT for is_editor_or_admin(), UPDATE/DELETE for project owner or admin
- re_videos: SELECT for is_active_user(), INSERT for is_editor_or_admin(), UPDATE/DELETE for video owner (via project) or admin
- re_jobs: SELECT for is_active_user() (own jobs), INSERT denied (worker inserts via service role), UPDATE denied (worker updates via service role)
- re_scenes: SELECT for is_active_user(), UPDATE for is_editor_or_admin() (to mark is_selected)
- re_api_usage: SELECT for is_admin() only

Read spec Section 5 for exact policy SQL. If spec has more granular policies, use those.

**supabase/migrations/003_storage_setup.sql** — Create storage bucket and policies:

INSERT INTO storage.buckets (id, name, public) VALUES ('remix-engine', 'remix-engine', false);

Storage policies for the remix-engine bucket (using storage.objects table):
- SELECT: is_active_user() — authenticated users can read (signed URLs generated server-side)
- INSERT: is_editor_or_admin() — editors and admins can upload
- DELETE: is_admin() — only admins can delete from storage

**supabase/migrations/004_realtime_setup.sql** — Enable realtime for re_jobs:

ALTER PUBLICATION supabase_realtime ADD TABLE re_jobs;

Also add re_videos to realtime (useful for scraping progress):
ALTER PUBLICATION supabase_realtime ADD TABLE re_videos;

**src/lib/supabase/types.ts** — After writing all migrations, attempt to generate types:

If supabase CLI is available and project is linked:
Run: npx supabase gen types typescript --local > src/lib/supabase/types.ts

If not available (no local Supabase running), create a hand-written stub that exports the correct TypeScript types matching the schema. The stub must export a Database interface following Supabase's generated type structure. Include at minimum:
- Tables: re_users, re_projects, re_videos, re_jobs, re_scenes, re_api_usage
- For each table: Row type (select result), Insert type, Update type

Stub example structure:
export interface Database {
  public: {
    Tables: {
      re_users: {
        Row: { id: string; email: string; full_name: string | null; role: 'admin' | 'editor' | 'viewer'; status: 'active' | 'inactive' | 'invited'; created_at: string; updated_at: string; }
        Insert: { id: string; email: string; full_name?: string | null; role?: 'admin' | 'editor' | 'viewer'; status?: 'active' | 'inactive' | 'invited'; }
        Update: { email?: string; full_name?: string | null; role?: 'admin' | 'editor' | 'viewer'; status?: 'active' | 'inactive' | 'invited'; updated_at?: string; }
      }
      // ... repeat for other tables
    }
  }
}
  </action>
  <verify>
    <automated>test -f "/c/Antigravity/Sandbox/supabase/migrations/002_rls_policies.sql" && test -f "/c/Antigravity/Sandbox/supabase/migrations/003_storage_setup.sql" && test -f "/c/Antigravity/Sandbox/supabase/migrations/004_realtime_setup.sql" && grep "is_active_user" "/c/Antigravity/Sandbox/supabase/migrations/002_rls_policies.sql" && grep "remix-engine" "/c/Antigravity/Sandbox/supabase/migrations/003_storage_setup.sql" && grep "supabase_realtime" "/c/Antigravity/Sandbox/supabase/migrations/004_realtime_setup.sql" && test -f /c/Antigravity/Sandbox/src/lib/supabase/types.ts && echo "All migrations OK"</automated>
  </verify>
  <done>
    002 contains RLS enabled for all re_ tables, three helper functions (is_active_user, is_editor_or_admin, is_admin), and policies for all tables. 003 creates remix-engine bucket (public: false) with SELECT/INSERT/DELETE policies. 004 adds re_jobs and re_videos to supabase_realtime publication. types.ts exports Database interface with all table types.
  </done>
</task>

</tasks>

<verification>
Check: supabase/migrations/ contains exactly 4 migration files numbered 001-004.
Check: grep -r "CREATE TABLE" supabase/migrations/001_initial_schema.sql | grep -v "re_" returns empty (all tables prefixed).
Check: grep "public.*true" supabase/migrations/003_storage_setup.sql returns empty (bucket must be private: false).
Check: src/lib/supabase/types.ts exports Database interface.
Run: npx tsc --noEmit — must pass.
</verification>

<success_criteria>
- Six re_ prefixed tables defined in SQL with correct column types and constraints
- UNIQUE constraint on re_scenes(video_id, scene_number) — required by spec
- handle_new_user trigger populates re_users from auth.users on signup with role from metadata
- RLS enabled on all tables with is_active_user/is_editor_or_admin/is_admin helpers
- Storage bucket "remix-engine" is private (not public)
- re_jobs (and re_videos) enabled for Supabase Realtime
- TypeScript types available for the schema
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-4-hours/01-03-SUMMARY.md` following the summary template.
</output>

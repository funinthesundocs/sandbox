---
phase: 01-foundation-4-hours
plan: 05
type: execute
wave: 2
depends_on:
  - "01-01"
  - "01-02"
files_modified:
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/signup/page.tsx
  - src/app/(auth)/layout.tsx
  - src/middleware.ts
  - src/app/api/remix-engine/auth/invite/route.ts
  - src/app/api/remix-engine/health/route.ts
autonomous: true
requirements:
  - R1.4
  - RM.8

must_haves:
  truths:
    - "Login page exists at /login with email/password form using shadcn/ui components"
    - "Signup page only renders a form when a valid invite token is present in the URL (?token=...)"
    - "Signup page without token shows Invite Required message and link to login"
    - "After successful login, user is redirected to /dashboard"
    - "Middleware protects all /dashboard/* routes — unauthenticated users redirect to /login"
    - "Middleware allows /login, /signup, and /api/* routes without auth check"
    - "POST /api/remix-engine/auth/invite accepts email + role, calls Supabase inviteUserByEmail (admin only)"
    - "GET /api/remix-engine/health returns JSON { status: ok, mode: standalone, timestamp }"
    - "Auth pages (login/signup) only exist in standalone mode (RM.8 — checked via config)"
    - "All colors in auth pages use --re-* CSS variables, no hardcoded hex"
  artifacts:
    - path: "src/app/(auth)/login/page.tsx"
      provides: "Login page with email/password form, error display, link to signup"
      contains: "signInWithPassword"
    - path: "src/app/(auth)/signup/page.tsx"
      provides: "Signup page — invite token check, user registration form or invite-required message"
      contains: "searchParams"
    - path: "src/middleware.ts"
      provides: "Next.js middleware — auth guard for dashboard routes, redirect to login if unauthenticated"
      contains: "matcher"
    - path: "src/app/api/remix-engine/auth/invite/route.ts"
      provides: "Invite user endpoint — admin only, calls supabase.auth.admin.inviteUserByEmail"
    - path: "src/app/api/remix-engine/health/route.ts"
      provides: "Health check endpoint returning status JSON"
  key_links:
    - from: "src/middleware.ts"
      to: "src/lib/supabase/server.ts"
      via: "Creates Supabase server client to check session"
      pattern: "createClient"
    - from: "src/app/(auth)/login/page.tsx"
      to: "src/lib/supabase/client.ts"
      via: "signInWithPassword on form submit"
      pattern: "signInWithPassword"
---

<objective>
Build the auth flow — login page, invite-only signup page, Next.js middleware for route protection, admin invite endpoint, and health check route. This completes the auth requirements (R1.4, RM.8) and makes the standalone dashboard actually secured.

Purpose: Without this, anyone can access /dashboard. Auth pages and middleware are Phase 1 requirements. The invite-only model is locked in CONTEXT.md.
Output: Secure auth flow — protected dashboard routes, login/signup pages, invite API.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-foundation-4-hours/01-CONTEXT.md
@.planning/phases/01-foundation-4-hours/01-RESEARCH.md

LOCKED DECISIONS (from CONTEXT.md — implement EXACTLY):
- Invite-only: only admins can send invites via Admin panel → Supabase inviteUserByEmail
- Invite link is a one-time email link with token in URL (?token=...)
- /signup without valid invite token → show "Invite Required" message, link to /login
- After successful login → redirect to /dashboard
- Role stored in Supabase user_metadata, checked by middleware
- Auth pages (login, signup) ONLY exist in standalone mode (RM.8)

STACK (from research):
- Next.js 16 App Router with server actions or client-side auth
- @supabase/ssr for SSR-compatible auth (already installed)
- shadcn/ui components: Button, Input, Label (installed in Plan 02)
- Tailwind v4 with --re-* CSS variables only

CRITICAL RULES:
- No hardcoded hex colors — use --re-* variables
- Auth pages must check config.mode — if module mode, return null or redirect
- Middleware uses @supabase/ssr createServerClient with cookie handling
- The supabase.auth.admin.inviteUserByEmail requires service role key (use supabaseAdmin from admin.ts)

<interfaces>
<!-- From Plan 01 (01-01) -->
import { createClient } from '@/lib/supabase/client';   // browser auth
import { createClient } from '@/lib/supabase/server';   // server auth (async)
import { supabaseAdmin } from '@/lib/supabase/admin';   // service role — for invite endpoint only
import { getServerConfig } from '@/lib/remix-engine/config';

<!-- shadcn/ui available from Plan 02 -->
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Middleware and auth layout</name>
  <files>
    src/middleware.ts
    src/app/(auth)/layout.tsx
  </files>
  <action>
**src/middleware.ts** — Next.js middleware for route protection.

Import createServerClient from '@supabase/ssr'. Import NextResponse from 'next/server'. Import type NextRequest from 'next/server'.

The middleware must:
1. Create a Supabase server client using cookies from the request (following @supabase/ssr middleware pattern)
2. Refresh the session (call supabase.auth.getUser() — this updates cookies)
3. If the route starts with /dashboard and user is NOT authenticated → redirect to /login
4. If the route is /login or /signup and user IS authenticated → redirect to /dashboard (prevent double login)
5. Always return the response (with updated cookies)

Use NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY from process.env IN MIDDLEWARE ONLY — middleware runs at the edge and cannot use getServerConfig(). This is the ONE exception to the "no process.env" rule, and it must be documented with a comment.

Matcher config (export const config):
{
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}

Pattern (from official Supabase SSR docs for Next.js middleware):
```typescript
export async function middleware(request: NextRequest) {
  let supabaseResponse = NextResponse.next({ request })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return request.cookies.getAll() },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({ request })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  const { data: { user } } = await supabase.auth.getUser()

  const isDashboardRoute = request.nextUrl.pathname.startsWith('/dashboard')
  const isAuthRoute = request.nextUrl.pathname.startsWith('/login') || request.nextUrl.pathname.startsWith('/signup')

  if (isDashboardRoute && !user) {
    const url = request.nextUrl.clone()
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }

  if (isAuthRoute && user) {
    const url = request.nextUrl.clone()
    url.pathname = '/dashboard'
    return NextResponse.redirect(url)
  }

  return supabaseResponse
}
```

**src/app/(auth)/layout.tsx** — Server component. Import getServerConfig. Check if config.mode === 'module' → return null (auth pages don't exist in module mode, per RM.8). Otherwise render children in a centered full-screen layout:

A div with min-h-screen flex items-center justify-center bg-[--re-bg-primary]. Children wrapped in a centered card-like container: w-full max-w-md px-6 py-8. This gives the auth pages their centered card appearance.
  </action>
  <verify>
    <automated>cd /c/Antigravity/Sandbox && npx tsc --noEmit 2>&1 | head -20 && test -f src/middleware.ts && grep "matcher" src/middleware.ts && echo "Middleware OK"</automated>
  </verify>
  <done>
    src/middleware.ts exists with matcher config, session refresh, and route protection logic. Auth layout checks config.mode. npx tsc --noEmit passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Login page, signup page, invite API, health route</name>
  <files>
    src/app/(auth)/login/page.tsx
    src/app/(auth)/signup/page.tsx
    src/app/api/remix-engine/auth/invite/route.ts
    src/app/api/remix-engine/health/route.ts
  </files>
  <action>
**src/app/(auth)/login/page.tsx** — 'use client'. Email/password login form.

State: email (string), password (string), error (string | null), loading (boolean).

On submit (handleSubmit):
- Set loading = true
- Call const supabase = createClient() (browser client from @/lib/supabase/client)
- const { error } = await supabase.auth.signInWithPassword({ email, password })
- If error: set error = error.message, loading = false
- If success: window.location.href = '/dashboard' (hard redirect to ensure middleware runs)

UI structure:
- Page title: "Sign in to RemixEngine" (text-[--re-text-primary] text-2xl font-semibold)
- Subtitle: "Internal tool — invite only" (text-[--re-text-muted] text-sm mt-1 mb-6)
- Form with Label + Input for email, Label + Input type="password" for password
- Error display: if error, show in a div with text-[--re-destructive] text-sm
- Submit Button (full width, bg-[--re-accent-primary])
- Footer text: "Don't have an account? " + Link to /signup with "Request access" (text-[--re-accent-primary])

All shadcn/ui components: Button, Input, Label. No hardcoded hex colors.

**src/app/(auth)/signup/page.tsx** — Signup page with invite token check.

This is a server component (to read searchParams). Accept searchParams prop: { token?: string }.

If no token (or token is empty string):
  Render "Invite Required" screen:
  - Heading: "Invite Required" (text-[--re-text-primary] text-2xl font-semibold)
  - Body: "RemixEngine is an invite-only tool. Ask an admin to send you an invite." (text-[--re-text-muted])
  - Link back to /login: "Back to sign in" (text-[--re-accent-primary])
  - Do NOT render any form

If token present:
  Render client component SignupForm (create inline or as separate 'use client' component in same file):
  - State: fullName, password, confirmPassword, error, loading
  - On submit: call supabase.auth.exchangeCodeForSession(token) — OR use supabase.auth.verifyOtp({ token_hash: token, type: 'invite' }) to accept the invite
  - Actually for Supabase invite flow: the invite link contains a token in the URL. The user clicks the link → arrives at /signup?token=XXX. The frontend calls supabase.auth.verifyOtp({ token_hash: token, type: 'invite' }) which creates the session. Then update the user's password and full_name via supabase.auth.updateUser().

  Simplified flow for Phase 1:
  1. User arrives at /signup?token=XXX
  2. Show form: Full Name input + Password input + Confirm Password input
  3. On submit:
     a. Validate passwords match
     b. Call supabase.auth.verifyOtp({ token_hash: token, type: 'invite' }) to establish session
     c. Call supabase.auth.updateUser({ password, data: { full_name: fullName } }) to set password + name
     d. Redirect to /dashboard

**src/app/api/remix-engine/auth/invite/route.ts** — POST endpoint to invite users. Admin only.

Import { NextResponse } from 'next/server'. Import { createClient } from '@/lib/supabase/server'. Import { supabaseAdmin } from '@/lib/supabase/admin'. Import InviteUserSchema from '@/lib/validators/schemas'.

export async function POST(request: Request):
1. const supabase = await createClient()
2. const { data: { user } } = await supabase.auth.getUser()
3. If no user → return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
4. Check user role from user.user_metadata.role — if not 'admin' → return 403
5. Parse request body with InviteUserSchema.safeParse(await request.json())
6. If parse fails → return 400 with validation errors
7. const { data, error } = await supabaseAdmin.auth.admin.inviteUserByEmail(body.email, {
     data: { role: body.role, full_name: body.fullName }
   })
8. If error → return 500 with error message
9. Return 200 with { success: true, email: body.email }

**src/app/api/remix-engine/health/route.ts** — Simple health check.

Import { NextResponse } from 'next/server'. Import { getServerConfig } from '@/lib/remix-engine/config'.

export async function GET():
  const config = getServerConfig()
  return NextResponse.json({
    status: 'ok',
    mode: config.mode,
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  })
  </action>
  <verify>
    <automated>cd /c/Antigravity/Sandbox && npx tsc --noEmit 2>&1 | head -30 && test -f src/app/api/remix-engine/health/route.ts && echo "Auth + health OK"</automated>
  </verify>
  <done>
    Login page has email/password form with error handling and redirect to /dashboard. Signup page shows invite-required message when no token. Signup form accepts token from searchParams and completes invite flow. POST /api/remix-engine/auth/invite is admin-protected. GET /api/remix-engine/health returns status JSON. npx tsc --noEmit passes. No hardcoded hex colors.
  </done>
</task>

</tasks>

<verification>
Run: npx tsc --noEmit — must pass with zero errors.
Check: src/middleware.ts has 'matcher' export and /dashboard protection.
Check: src/app/(auth)/signup/page.tsx checks for token in searchParams.
Check: src/app/api/remix-engine/auth/invite/route.ts checks admin role before inviting.
Check: grep -r "#[0-9a-fA-F]\{6\}" src/app/\(auth\)/ returns empty (no hex colors in auth pages).
</verification>

<success_criteria>
- /dashboard/* routes are protected — unauthenticated users redirected to /login
- Login page works with email/password via Supabase signInWithPassword
- Signup without token shows invite-required message (no form rendered)
- Signup with valid token completes the invite flow and redirects to /dashboard
- POST /api/remix-engine/auth/invite is admin-only and calls inviteUserByEmail
- GET /api/remix-engine/health returns { status: ok, mode, timestamp }
- Auth pages check config.mode — invisible in module mode
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-4-hours/01-05-SUMMARY.md` following the summary template.
</output>

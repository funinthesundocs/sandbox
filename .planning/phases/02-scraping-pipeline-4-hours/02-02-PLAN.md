---
phase: 02-scraping-pipeline-4-hours
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/youtube-api/client.ts
  - src/lib/youtube-api/metadata.ts
  - src/lib/youtube-api/channel.ts
  - src/lib/youtube-api/url-parser.ts
autonomous: true
requirements:
  - R2.2
  - R2.6
  - R2.9

must_haves:
  truths:
    - "fetchVideoMetadata(youtubeId) returns VideoMetadata with title, description, channelName, channelId, duration, viewCount, publishedAt, thumbnailUrl"
    - "fetchChannelVideos(channelId, pageToken?) returns ChannelVideosPage with items[], nextPageToken, totalResults"
    - "parseYouTubeUrl(url) returns { type: 'video'|'channel'|'handle', id: string } for all supported URL formats"
    - "All API calls use getServerConfig().apiKeys.youtube — never process.env"
    - "Private/unavailable videos detected from YouTube API response (items array empty = unavailable)"
    - "resolveChannelId(urlOrHandle) resolves @handle and /c/ slugs to channelId via YouTube API"
  artifacts:
    - path: "src/lib/youtube-api/client.ts"
      provides: "youtubeGet(endpoint, params) — authenticated fetch wrapper with error handling"
      exports: ["youtubeGet"]
    - path: "src/lib/youtube-api/metadata.ts"
      provides: "fetchVideoMetadata(youtubeId) → VideoMetadata, VideoMetadata interface"
      exports: ["fetchVideoMetadata", "VideoMetadata"]
    - path: "src/lib/youtube-api/channel.ts"
      provides: "fetchChannelVideos(channelId, pageToken?) → ChannelVideosPage, resolveChannelId(urlOrHandle) → string"
      exports: ["fetchChannelVideos", "resolveChannelId", "ChannelVideo", "ChannelVideosPage"]
    - path: "src/lib/youtube-api/url-parser.ts"
      provides: "parseYouTubeUrl(url) → ParsedYouTubeUrl, extractYouTubeId(url) → string"
      exports: ["parseYouTubeUrl", "extractYouTubeId", "ParsedYouTubeUrl"]
  key_links:
    - from: "src/lib/youtube-api/metadata.ts"
      to: "src/lib/youtube-api/client.ts"
      via: "youtubeGet() for all API calls"
      pattern: "youtubeGet"
    - from: "src/lib/youtube-api/channel.ts"
      to: "src/lib/youtube-api/client.ts"
      via: "youtubeGet() for search.list and channels.list"
      pattern: "youtubeGet"
    - from: "src/lib/youtube-api/metadata.ts"
      to: "src/lib/remix-engine/config.ts"
      via: "getServerConfig().apiKeys.youtube"
      pattern: "getServerConfig"
---

<objective>
Build the YouTube Data API v3 client library — metadata fetch, channel video listing, and URL parsing. This is the second Wave 1 plan, running in parallel with Plan 01 (scraper library). The worker handler in Plan 03 imports from both.

Purpose: Metadata fetch runs in parallel with yt-dlp download (both I/O-bound). Channel browse for batch scraping requires the channel.ts functions. URL parsing normalizes all YouTube URL formats into a consistent shape for the API route.
Output: Four files covering YouTube API integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/phases/02-scraping-pipeline-4-hours/02-RESEARCH.md

CRITICAL RULES:
- getServerConfig() is the ONLY way to read API keys — never process.env
- All API calls are key-authenticated (no OAuth ever — YouTube Captions API is out of scope)
- Batch scraping: YouTube Data API search.list with channelId param, max 50 results per page
- NEVER use the YouTube Captions API (requires OAuth — not this phase's scope)

YOUTUBE API ENDPOINTS:
- Video metadata: GET https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails,statistics&id={videoId}&key={apiKey}
- Channel search: GET https://www.googleapis.com/youtube/v3/search?part=snippet&channelId={channelId}&type=video&order=date&maxResults=50&key={apiKey}
- Channel info (resolve handle): GET https://www.googleapis.com/youtube/v3/channels?part=snippet&forHandle={handle}&key={apiKey}
  OR: GET https://www.googleapis.com/youtube/v3/channels?part=snippet&forUsername={username}&key={apiKey}

ISO 8601 DURATION PARSING: YouTube returns "PT5M30S", "PT1H2M3S", "PT45S" — must parse to seconds.
</context>

<tasks>

<task type="auto">
  <name>Task 1: URL parser and YouTube API base client</name>
  <files>
    src/lib/youtube-api/url-parser.ts
    src/lib/youtube-api/client.ts
  </files>
  <action>
**src/lib/youtube-api/url-parser.ts** — Parse all YouTube URL formats into a normalized shape.

Export interface ParsedYouTubeUrl:
```typescript
export interface ParsedYouTubeUrl {
  type: 'video' | 'channel' | 'handle' | 'playlist';
  id: string;         // videoId, channelId, @handle, or playlistId
  rawUrl: string;     // Original URL
}
```

Export `parseYouTubeUrl(url: string): ParsedYouTubeUrl`:

Handle all these URL formats:
- `https://www.youtube.com/watch?v=dQw4w9WgXcQ` → { type: 'video', id: 'dQw4w9WgXcQ' }
- `https://youtu.be/dQw4w9WgXcQ` → { type: 'video', id: 'dQw4w9WgXcQ' }
- `https://m.youtube.com/watch?v=dQw4w9WgXcQ` → { type: 'video', id: 'dQw4w9WgXcQ' }
- `https://www.youtube.com/shorts/dQw4w9WgXcQ` → { type: 'video', id: 'dQw4w9WgXcQ' }
- `https://www.youtube.com/channel/UCxxxxxxxx` → { type: 'channel', id: 'UCxxxxxxxx' }
- `https://www.youtube.com/c/ChannelName` → { type: 'channel', id: 'ChannelName' } (slug — needs resolve)
- `https://www.youtube.com/@HandleName` → { type: 'handle', id: '@HandleName' } (keep @ prefix)
- `https://www.youtube.com/playlist?list=PLxxxxxxxx` → { type: 'playlist', id: 'PLxxxxxxxx' }

Use URL constructor for parsing: `const parsed = new URL(url)`. Throw if URL constructor throws (invalid URL).

Implementation approach:
- Check hostname: if 'youtu.be' → video, get id from pathname
- If pathname starts with '/watch' → video, get 'v' searchParam
- If pathname starts with '/shorts/' → video, get id from pathname segment
- If pathname starts with '/channel/' → channel, get id from pathname segment
- If pathname starts with '/c/' → channel (slug), get slug from pathname
- If pathname starts with '/@') → handle, return with '@' prefix
- If pathname starts with '/playlist' → playlist, get 'list' searchParam
- Throw new Error(`Unsupported YouTube URL format: ${url}`) for unrecognized patterns

Export `extractYouTubeId(url: string): string` — convenience function. Calls parseYouTubeUrl, throws if type !== 'video'. Returns the video ID. Used by scrape API route to get the canonical YouTube video ID before enqueueing.

Export `isVideoUrl(url: string): boolean` — try/catch parseYouTubeUrl, return type === 'video'
Export `isChannelUrl(url: string): boolean` — try/catch parseYouTubeUrl, return type === 'channel' || type === 'handle'

**src/lib/youtube-api/client.ts** — Authenticated fetch wrapper.

Import { getServerConfig } from '@/lib/remix-engine/config'.

const YOUTUBE_API_BASE = 'https://www.googleapis.com/youtube/v3';

Export `youtubeGet<T = unknown>(endpoint: string, params: Record<string, string>): Promise<T>`:
1. Get apiKey = getServerConfig().apiKeys.youtube
2. Build URL: `${YOUTUBE_API_BASE}/${endpoint}?${new URLSearchParams({ ...params, key: apiKey })}`
3. const response = await fetch(url, { headers: { 'Accept': 'application/json' } })
4. If !response.ok: const errorBody = await response.text(); throw new Error(`YouTube API ${response.status}: ${errorBody}`)
5. Special case: 403 containing 'quotaExceeded' → throw new Error('YouTube API quota exceeded. Try again tomorrow.')
6. return await response.json() as T

Export `parseIsoDuration(iso: string): number` — Parse ISO 8601 duration to seconds:
- Regex: /PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/
- Extract h, m, s groups (default 0 if missing)
- Return h * 3600 + m * 60 + s
- Test cases: "PT5M30S" → 330, "PT1H2M3S" → 3723, "PT45S" → 45, "P0D" → 0

This function is used by metadata.ts to convert YouTube's duration format.
  </action>
  <verify>
    <automated>cd /c/Antigravity/Sandbox && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    TypeScript compiles cleanly. parseYouTubeUrl handles all listed URL formats. extractYouTubeId throws for non-video URLs. youtubeGet exported with generic return type. parseIsoDuration('PT5M30S') returns 330.
  </done>
</task>

<task type="auto">
  <name>Task 2: Video metadata fetcher and channel search</name>
  <files>
    src/lib/youtube-api/metadata.ts
    src/lib/youtube-api/channel.ts
  </files>
  <action>
**src/lib/youtube-api/metadata.ts** — YouTube video metadata fetch.

Import { youtubeGet, parseIsoDuration } from './client'.

Export interface VideoMetadata:
```typescript
export interface VideoMetadata {
  youtubeId: string;
  title: string;
  description: string;
  channelName: string;
  channelId: string;
  durationSeconds: number;
  viewCount: number;
  likeCount: number;
  publishedAt: string;        // ISO timestamp from YouTube
  thumbnailUrl: string;       // Highest quality available
  isLiveBroadcast: boolean;   // true for live streams
}
```

Export `fetchVideoMetadata(youtubeId: string): Promise<VideoMetadata>`:
1. Call: const data = await youtubeGet<{ items: YoutubeVideoItem[] }>('videos', { part: 'snippet,contentDetails,statistics', id: youtubeId })
2. If !data.items?.length → throw new Error('VIDEO_NOT_FOUND') — video is private or deleted
3. const item = data.items[0]
4. Extract and return:
   - youtubeId: item.id
   - title: item.snippet.title
   - description: item.snippet.description || ''
   - channelName: item.snippet.channelTitle
   - channelId: item.snippet.channelId
   - durationSeconds: parseIsoDuration(item.contentDetails.duration)
   - viewCount: parseInt(item.statistics.viewCount || '0', 10)
   - likeCount: parseInt(item.statistics.likeCount || '0', 10)
   - publishedAt: item.snippet.publishedAt
   - thumbnailUrl: item.snippet.thumbnails.maxres?.url || item.snippet.thumbnails.high?.url || item.snippet.thumbnails.medium?.url || item.snippet.thumbnails.default.url
   - isLiveBroadcast: item.snippet.liveBroadcastContent === 'live'

Define a local type YoutubeVideoItem (not exported) with the raw YouTube API shape for type safety.

**src/lib/youtube-api/channel.ts** — Channel video listing and handle resolution.

Import { youtubeGet } from './client'.

Export interface ChannelVideo:
```typescript
export interface ChannelVideo {
  youtubeId: string;
  title: string;
  thumbnailUrl: string;
  durationSeconds: number | null;  // null — search.list doesn't return duration; populated by separate metadata call if needed
  publishedAt: string;
  channelName: string;
  channelId: string;
}
```

Export interface ChannelVideosPage:
```typescript
export interface ChannelVideosPage {
  items: ChannelVideo[];
  nextPageToken: string | null;
  totalResults: number;
}
```

Export `fetchChannelVideos(channelId: string, pageToken?: string): Promise<ChannelVideosPage>`:
1. Params: { part: 'snippet', channelId, type: 'video', order: 'date', maxResults: '50', ...(pageToken ? { pageToken } : {}) }
2. Call youtubeGet<{ items: YoutubeSearchItem[]; nextPageToken?: string; pageInfo: { totalResults: number } }>('search', params)
3. Map items to ChannelVideo[]:
   - youtubeId: item.id.videoId
   - title: item.snippet.title
   - thumbnailUrl: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.medium?.url || item.snippet.thumbnails.default.url
   - durationSeconds: null (search.list doesn't include contentDetails)
   - publishedAt: item.snippet.publishedAt
   - channelName: item.snippet.channelTitle
   - channelId: item.snippet.channelId
4. Return { items, nextPageToken: data.nextPageToken || null, totalResults: data.pageInfo.totalResults }

Export `resolveChannelId(urlOrHandle: string): Promise<string>`:
- If urlOrHandle starts with 'UC' (already a channelId): return it directly
- If starts with '@' (handle): call youtubeGet('channels', { part: 'snippet', forHandle: urlOrHandle.slice(1) })
- If it's a slug (no '@', no 'UC'): call youtubeGet('channels', { part: 'snippet', forUsername: urlOrHandle })
- Extract items[0].id from the response
- If no items: throw new Error(`Channel not found: ${urlOrHandle}`)

Export `fetchChannelInfo(channelId: string): Promise<{ name: string; thumbnailUrl: string }>`:
- Call youtubeGet('channels', { part: 'snippet', id: channelId })
- Return { name: items[0].snippet.title, thumbnailUrl: items[0].snippet.thumbnails.high?.url || items[0].snippet.thumbnails.default.url }
  </action>
  <verify>
    <automated>cd /c/Antigravity/Sandbox && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    TypeScript compiles cleanly. fetchVideoMetadata exported with VideoMetadata interface. fetchChannelVideos returns ChannelVideosPage with nextPageToken. resolveChannelId handles @handle and channelId formats. No process.env in any youtube-api file.
  </done>
</task>

</tasks>

<verification>
Run: npx tsc --noEmit — must pass with zero errors.
Check: grep -r "process\.env" src/lib/youtube-api/ — must return empty.
Check: src/lib/youtube-api/client.ts contains "getServerConfig" import.
Check: parseIsoDuration is exported from client.ts.
Check: ChannelVideosPage interface has nextPageToken field.
</verification>

<success_criteria>
- All YouTube URL formats parsed correctly (video, channel, handle, playlist)
- fetchVideoMetadata detects VIDEO_NOT_FOUND when items array empty
- fetchChannelVideos returns max 50 items per page with pagination token
- resolveChannelId handles @handles, /c/ slugs, and direct UCxxxxxx IDs
- API key read only from getServerConfig().apiKeys.youtube
- parseIsoDuration correctly converts all ISO 8601 duration variants
</success_criteria>

<output>
After completion, create `.planning/phases/02-scraping-pipeline-4-hours/02-02-SUMMARY.md` following the summary template.
</output>

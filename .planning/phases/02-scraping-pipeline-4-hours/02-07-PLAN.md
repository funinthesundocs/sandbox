---
phase: 02-scraping-pipeline-4-hours
plan: 07
type: execute
wave: 4
depends_on:
  - "02-05"
  - "02-06"
files_modified:
  - src/components/scraper/ScrapeProgressSteps.tsx
  - src/components/scraper/JobProgressSubscriber.tsx
  - src/hooks/useJobProgress.ts
  - src/app/(dashboard)/projects/[id]/page.tsx
  - src/components/layout/Header.tsx
  - src/app/api/remix-engine/scrape/[jobId]/cancel/route.ts
autonomous: true
requirements:
  - R2.7
  - R2.8
  - R2.9

must_haves:
  truths:
    - "useJobProgress(jobId) subscribes to Supabase Realtime on re_jobs and returns live { status, progress, errorMessage }"
    - "ScrapeProgressSteps shows discrete step indicators: Downloading → Extracting transcript → Uploading — steps light up as progress milestones are reached"
    - "After scrape completes (status=complete), page auto-navigates to /dashboard/projects/{projectId}/videos/{videoId}"
    - "Header quick-add button opens a floating ScrapeInput modal so users can scrape from any page"
    - "POST /api/remix-engine/scrape/[jobId]/cancel marks re_jobs as cancelled"
    - "VideoGrid on project detail page subscribes to re_videos Realtime to update card statuses live without page refresh"
  artifacts:
    - path: "src/hooks/useJobProgress.ts"
      provides: "useJobProgress(jobId) React hook — Supabase Realtime subscription on re_jobs"
      exports: ["useJobProgress", "JobProgress"]
    - path: "src/components/scraper/ScrapeProgressSteps.tsx"
      provides: "Step indicator component: Downloading → Extracting → Uploading"
      exports: ["ScrapeProgressSteps"]
    - path: "src/components/scraper/JobProgressSubscriber.tsx"
      provides: "Wrapper that uses useJobProgress and renders ScrapeProgressSteps + auto-navigation"
      exports: ["JobProgressSubscriber"]
    - path: "src/app/(dashboard)/projects/[id]/page.tsx"
      provides: "Updated project detail page: shows JobProgressSubscriber when scrape is in progress"
    - path: "src/components/layout/Header.tsx"
      provides: "Updated header with quick-add scrape button opening floating input"
    - path: "src/app/api/remix-engine/scrape/[jobId]/cancel/route.ts"
      provides: "POST handler — cancel a scrape job"
  key_links:
    - from: "src/components/scraper/JobProgressSubscriber.tsx"
      to: "src/hooks/useJobProgress.ts"
      via: "useJobProgress(jobId) for live progress updates"
      pattern: "useJobProgress"
    - from: "src/hooks/useJobProgress.ts"
      to: "src/lib/remix-engine/hooks.ts"
      via: "useRemixEngine() to get supabaseClient for Realtime subscription"
      pattern: "useRemixEngine"
    - from: "src/app/(dashboard)/projects/[id]/page.tsx"
      to: "src/components/scraper/JobProgressSubscriber.tsx"
      via: "Pass jobId + videoId when ScrapeInput reports scrape started"
      pattern: "JobProgressSubscriber"
---

<objective>
Wire the Supabase Realtime progress updates into the UI and add the polish layer: step-based progress indicator, auto-navigation after completion, header quick-add button, and cancel endpoint. This is the final integration wave for Phase 2.

Purpose: The backend (Plans 01-03) and UI (Plans 04-06) are complete. This plan adds the live progress feedback that ties them together — users see discrete steps lighting up in real-time, then automatically land on the video detail page when done.
Output: Realtime hook, progress step component, auto-navigation, header quick-add, cancel endpoint.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-scraping-pipeline-4-hours/02-CONTEXT.md
@design-system/MASTER.md

LOCKED DECISIONS (from CONTEXT.md — implement EXACTLY):
- Step-based progress: discrete steps light up as they complete (Downloading → Extracting transcript → Uploading to storage)
- Post-scrape: auto-navigate to the new video's detail page showing thumbnail, metadata, and transcript
- Entry points: URL input on the project page AND a top-level quick-add from sidebar/header

PROGRESS → STEP MAPPING (from Plan 03 worker handler):
- 0-9: Pending/starting
- 10-39: Downloading (step 1 = in progress)
- 40-59: Download complete (step 1 = done); Extracting transcript (step 2 = in progress)
- 60-84: Transcript done (step 2 = done); Uploading (step 3 = in progress)
- 85-99: Upload done (step 3 = done); Finalizing
- 100 / status=complete: All steps done

SUPABASE REALTIME SUBSCRIPTION PATTERN:
```typescript
const subscription = supabaseClient
  .channel(`re_jobs:${jobId}`)
  .on('postgres_changes', {
    event: 'UPDATE',
    schema: 'public',
    table: 're_jobs',
    filter: `id=eq.${jobId}`,
  }, (payload) => {
    // payload.new contains the updated row
  })
  .subscribe();
// Cleanup: subscription.unsubscribe()
```

CLAUDE'S DISCRETION:
- Progress step animation style (recommend CSS transition on border/fill)
- Loading indicator between steps
- Exact glow intensity on active step
- Header modal/popover styling for quick-add
</context>

<tasks>

<task type="auto">
  <name>Task 1: Realtime progress hook, step component, and cancel endpoint</name>
  <files>
    src/hooks/useJobProgress.ts
    src/components/scraper/ScrapeProgressSteps.tsx
    src/app/api/remix-engine/scrape/[jobId]/cancel/route.ts
  </files>
  <action>
**src/hooks/useJobProgress.ts** — 'use client' React hook.

Import { useState, useEffect } from 'react'. Import { useRemixEngine } from '@/lib/remix-engine/hooks'.

Export interface JobProgress:
```typescript
export interface JobProgress {
  jobId: string;
  status: 'queued' | 'processing' | 'complete' | 'error' | 'cancelled';
  progress: number;           // 0-100
  errorMessage: string | null;
  result: { videoId?: string; transcriptSegmentCount?: number } | null;
}
```

Export `useJobProgress(jobId: string | null): JobProgress | null`:
1. `const { supabaseClient } = useRemixEngine()` — get client from context
2. `const [data, setData] = useState<JobProgress | null>(null)`
3. useEffect runs when jobId changes:
   - If !jobId: return
   - First, do an initial fetch to get current state:
     ```typescript
     supabaseClient
       .from('re_jobs')
       .select('id, status, progress, error_message, result')
       .eq('id', jobId)
       .single()
       .then(({ data: row }) => {
         if (row) setData({ jobId, status: row.status, progress: row.progress, errorMessage: row.error_message, result: row.result });
       });
     ```
   - Then subscribe to Realtime updates:
     ```typescript
     const subscription = supabaseClient
       .channel(`re_jobs_${jobId}`)
       .on('postgres_changes', {
         event: 'UPDATE',
         schema: 'public',
         table: 're_jobs',
         filter: `id=eq.${jobId}`,
       }, (payload: any) => {
         const row = payload.new;
         setData({ jobId, status: row.status, progress: row.progress, errorMessage: row.error_message, result: row.result });
       })
       .subscribe();
     return () => { subscription.unsubscribe(); };
   ```
4. Return data

Note: useRemixEngine() provides supabaseClient — this is the browser Supabase client from RemixEngineProvider. It must have anon key and cookie session for Realtime to work.

**src/components/scraper/ScrapeProgressSteps.tsx** — 'use client'. Visual step indicator.

Props:
```typescript
interface ScrapeProgressStepsProps {
  progress: number;   // 0-100
  status: 'queued' | 'processing' | 'complete' | 'error' | 'cancelled';
  errorMessage?: string | null;
}
```

Steps definition:
```typescript
const STEPS = [
  { label: 'Downloading', completeAt: 40, startAt: 10 },
  { label: 'Extracting transcript', completeAt: 60, startAt: 40 },
  { label: 'Uploading to storage', completeAt: 100, startAt: 60 },
];
```

Step state for a given progress value:
```typescript
function getStepState(step: typeof STEPS[0], progress: number, status: string): 'pending' | 'active' | 'complete' | 'error' {
  if (status === 'error') return progress >= step.startAt ? 'error' : 'pending';
  if (progress >= step.completeAt) return 'complete';
  if (progress >= step.startAt) return 'active';
  return 'pending';
}
```

Step visual:
```jsx
<div className="flex items-center gap-3">
  {STEPS.map((step, i) => {
    const stepState = getStepState(step, progress, status);
    return (
      <React.Fragment key={step.label}>
        {/* Step indicator */}
        <div className="flex items-center gap-2">
          <div className={`w-6 h-6 rounded-full flex items-center justify-center transition-all duration-300 ${
            stepState === 'complete' ? 'bg-[--re-success] shadow-[0_0_8px_hsl(142_71%_45%/0.5)]' :
            stepState === 'active' ? 'bg-[--re-accent-primary] shadow-[0_0_10px_hsl(217_91%_60%/0.5)] animate-pulse' :
            stepState === 'error' ? 'bg-[--re-destructive]' :
            'bg-[--re-bg-hover] border border-[--re-border]'
          }`}>
            {stepState === 'complete' && <Check className="w-3 h-3 text-white" />}
            {stepState === 'active' && <Loader2 className="w-3 h-3 text-white animate-spin" />}
            {stepState === 'error' && <X className="w-3 h-3 text-white" />}
            {stepState === 'pending' && <span className="w-2 h-2 rounded-full bg-[--re-border]" />}
          </div>
          <span className={`text-sm ${
            stepState === 'complete' ? 'text-[--re-success]' :
            stepState === 'active' ? 'text-[--re-accent-primary] font-medium' :
            stepState === 'error' ? 'text-[--re-destructive]' :
            'text-[--re-text-disabled]'
          }`}>{step.label}</span>
        </div>
        {/* Connector line */}
        {i < STEPS.length - 1 && (
          <div className={`flex-1 h-px transition-all duration-500 ${progress >= STEPS[i].completeAt ? 'bg-[--re-success]' : 'bg-[--re-border-subtle]'}`} />
        )}
      </React.Fragment>
    );
  })}
</div>
```

If status === 'error': show error message below steps:
```jsx
{status === 'error' && errorMessage && (
  <p className="text-[--re-destructive] text-sm mt-3">{errorMessage}</p>
)}
```

Import Check, Loader2, X from lucide-react.

**src/app/api/remix-engine/scrape/[jobId]/cancel/route.ts**

POST handler:
1. Auth check
2. const { jobId } = await params
3. Import supabaseAdmin. Update re_jobs: status = 'cancelled', completed_at = now()
4. Also update re_videos.scrape_status = 'error', error_message = 'Scrape was cancelled' for the video linked to this job
5. Note: This does NOT actually stop the BullMQ worker mid-execution. It marks the DB record as cancelled. The worker will still complete (or fail) and write its final state. This is acceptable for Phase 2 — true worker cancellation is a Phase 6 polish item.
6. Return NextResponse.json({ success: true })
  </action>
  <verify>
    <automated>cd /c/Antigravity/Sandbox && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    TypeScript compiles cleanly. useJobProgress subscribes to Supabase Realtime on re_jobs table filtered by jobId. ScrapeProgressSteps shows three steps with visual state (pending/active/complete/error). Cancel endpoint updates job status to cancelled.
  </done>
</task>

<task type="auto">
  <name>Task 2: JobProgressSubscriber, project page integration, header quick-add</name>
  <files>
    src/components/scraper/JobProgressSubscriber.tsx
    src/app/(dashboard)/projects/[id]/page.tsx
    src/components/layout/Header.tsx
  </files>
  <action>
**src/components/scraper/JobProgressSubscriber.tsx** — 'use client'. Orchestrates progress display and auto-navigation.

Props:
```typescript
interface JobProgressSubscriberProps {
  jobId: string;
  videoId: string;
  projectId: string;
  videoTitle?: string;
  onDismiss?: () => void;
}
```

Implementation:
```typescript
'use client';
import { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useJobProgress } from '@/hooks/useJobProgress';
import { ScrapeProgressSteps } from './ScrapeProgressSteps';
import { Button } from '@/components/ui/button';
import { X } from 'lucide-react';

export function JobProgressSubscriber({ jobId, videoId, projectId, videoTitle, onDismiss }: JobProgressSubscriberProps) {
  const router = useRouter();
  const progress = useJobProgress(jobId);

  // Auto-navigate when complete
  useEffect(() => {
    if (progress?.status === 'complete') {
      const timer = setTimeout(() => {
        router.push(`/dashboard/projects/${projectId}/videos/${videoId}`);
      }, 800); // Brief delay so user sees the complete state
      return () => clearTimeout(timer);
    }
  }, [progress?.status, projectId, videoId, router]);

  if (!progress) return null;

  return (
    <div className="p-4 rounded-[--re-border-radius] bg-[--re-bg-secondary]/80 backdrop-blur-md border border-[--re-border]/60 relative">
      {/* Dismiss button (only when not actively processing) */}
      {(progress.status === 'error' || progress.status === 'cancelled') && onDismiss && (
        <Button variant="ghost" size="icon" className="absolute top-2 right-2 w-6 h-6" onClick={onDismiss}>
          <X className="w-3 h-3" />
        </Button>
      )}
      {/* Video title */}
      {videoTitle && (
        <p className="text-[--re-text-primary] text-sm font-medium mb-3 truncate pr-8">{videoTitle}</p>
      )}
      {/* Step progress */}
      <ScrapeProgressSteps
        progress={progress.progress}
        status={progress.status}
        errorMessage={progress.errorMessage}
      />
      {/* Completion state */}
      {progress.status === 'complete' && (
        <p className="text-[--re-success] text-sm mt-3">
          Scrape complete! Navigating to video...
        </p>
      )}
    </div>
  );
}
```

**src/app/(dashboard)/projects/[id]/page.tsx** — UPDATE the project detail page from Plan 04.

The project page is a server component, but it needs to track in-flight scrape jobs. The bridge: ScrapeInput is a client component. After scrape starts, it calls `onScrapeStarted(jobId, videoId)`. This triggers showing JobProgressSubscriber.

Create a new client wrapper component in the same directory or inline: `ProjectDetailClient.tsx` (or add as an internal component at the bottom of the page.tsx):

The server component renders a client wrapper `ProjectDetailClient` that manages the active scrape job state.

Add `src/app/(dashboard)/projects/[id]/ProjectDetailClient.tsx`:

```typescript
'use client';
import { useState } from 'react';
import { ScrapeInput } from '@/components/scraper/ScrapeInput';
import { VideoGrid } from '@/components/scraper/VideoGrid';
import { JobProgressSubscriber } from '@/components/scraper/JobProgressSubscriber';
import Link from 'next/link';
import { Network } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface ActiveJob {
  jobId: string;
  videoId: string;
  title?: string;
}

interface ProjectDetailClientProps {
  projectId: string;
  projectName: string;
  initialVideos: Array<{
    id: string;
    youtube_id: string;
    original_title: string | null;
    original_thumbnail_url: string | null;
    channel_name: string | null;
    duration_seconds: number | null;
    scrape_status: 'pending' | 'processing' | 'complete' | 'error';
    view_count: number | null;
  }>;
}

export function ProjectDetailClient({ projectId, projectName, initialVideos }: ProjectDetailClientProps) {
  const [activeJobs, setActiveJobs] = useState<ActiveJob[]>([]);

  const handleScrapeStarted = (jobId: string, videoId: string) => {
    setActiveJobs(prev => [...prev, { jobId, videoId }]);
  };

  const handleJobDismiss = (jobId: string) => {
    setActiveJobs(prev => prev.filter(j => j.jobId !== jobId));
  };

  return (
    <div>
      <div className="mb-8 space-y-3">
        <ScrapeInput
          projectId={projectId}
          onScrapeStarted={handleScrapeStarted}
        />
        {/* Channel batch scrape entry point */}
        <div className="flex justify-end">
          <Link href={`/dashboard/projects/${projectId}/channel`}>
            <Button variant="outline" size="sm">
              <Network className="w-4 h-4 mr-2" /> Scrape from Channel
            </Button>
          </Link>
        </div>
        {/* Active job progress subscribers */}
        {activeJobs.map(job => (
          <JobProgressSubscriber
            key={job.jobId}
            jobId={job.jobId}
            videoId={job.videoId}
            projectId={projectId}
            onDismiss={() => handleJobDismiss(job.jobId)}
          />
        ))}
      </div>
      <VideoGrid videos={initialVideos} projectId={projectId} />
    </div>
  );
}
```

Update `src/app/(dashboard)/projects/[id]/page.tsx` to import and use ProjectDetailClient instead of the direct ScrapeInput + VideoGrid rendering from Plan 04:

```typescript
export default async function ProjectDetailPage({ params }: { params: Promise<{ id: string }> }) {
  const { id } = await params;
  // ... auth + fetch project + fetch videos same as Plan 04 ...

  return (
    <div>
      <div className="mb-6">
        <h1 ...>{project.name}</h1>
      </div>
      <ProjectDetailClient
        projectId={id}
        projectName={project.name}
        initialVideos={videos ?? []}
      />
    </div>
  );
}
```

**src/components/layout/Header.tsx** — UPDATE to add the quick-add scrape button.

The header is a 'use client' component. Add state:
- `quickAddOpen: boolean`
- `quickAddProjectId: string | null`

Add a Plus button next to the avatar dropdown:
```jsx
<Button
  variant="ghost"
  size="icon"
  className="w-8 h-8 text-[--re-text-muted] hover:text-[--re-text-primary]"
  onClick={() => setQuickAddOpen(true)}
  title="Quick scrape"
>
  <Plus className="w-4 h-4" />
</Button>
```

When quickAddOpen=true: render a floating overlay (position fixed, centered, backdrop):
```jsx
{quickAddOpen && (
  <div
    className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm"
    onClick={e => { if (e.target === e.currentTarget) setQuickAddOpen(false); }}
  >
    <div className="w-full max-w-xl mx-4 p-4 rounded-[--re-border-radius-lg] bg-[--re-bg-secondary] border border-[--re-border] shadow-[--re-shadow-lg]">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-[--re-text-primary] font-medium">Quick Scrape</h3>
        <Button variant="ghost" size="icon" className="w-6 h-6" onClick={() => setQuickAddOpen(false)}>
          <X className="w-4 h-4" />
        </Button>
      </div>
      {/* Project selector — simple select if user has projects */}
      <ProjectSelector onProjectSelected={setQuickAddProjectId} />
      {quickAddProjectId && (
        <div className="mt-3">
          <ScrapeInput
            projectId={quickAddProjectId}
            onScrapeStarted={(jobId, videoId) => {
              setQuickAddOpen(false);
              // navigate to the project page — user will see progress there
              router.push(`/dashboard/projects/${quickAddProjectId}`);
            }}
          />
        </div>
      )}
    </div>
  </div>
)}
```

Create a simple inline `ProjectSelector` client component within Header.tsx (or a separate file) that fetches projects from `/api/remix-engine/projects` (or directly from a prop). For simplicity: accept a prop `userProjects?: { id: string; name: string }[]` from the server layout, or fetch client-side on first render. Use a `<select>` element styled with --re-* variables:

```tsx
function ProjectSelector({ onProjectSelected }: { onProjectSelected: (id: string) => void }) {
  const [projects, setProjects] = useState<{ id: string; name: string }[]>([]);

  useEffect(() => {
    fetch('/api/remix-engine/projects')
      .then(r => r.json())
      .then(d => setProjects(d.projects || []))
      .catch(() => {});
  }, []);

  if (projects.length === 0) return <p className="text-[--re-text-muted] text-sm">No projects found. Create a project first.</p>;

  return (
    <select
      onChange={e => onProjectSelected(e.target.value)}
      defaultValue=""
      className="w-full h-9 px-3 rounded-[--re-border-radius] bg-[--re-bg-input] border border-[--re-border] text-[--re-text-primary] text-sm outline-none focus:border-[--re-accent-primary]"
    >
      <option value="" disabled>Select a project...</option>
      {projects.map(p => <option key={p.id} value={p.id}>{p.name}</option>)}
    </select>
  );
}
```

Also add a minimal `/api/remix-engine/projects/route.ts` GET endpoint that returns the user's projects (needed by Header's ProjectSelector):

Add to files_modified if needed, or note that this should be created as part of this task.

Create `src/app/api/remix-engine/projects/route.ts`:
```typescript
export async function GET() {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const { data: projects } = await supabase
    .from('re_projects')
    .select('id, name')
    .order('created_at', { ascending: false });

  return NextResponse.json({ projects: projects || [] });
}
```

Import useRouter from 'next/navigation', Plus, X from lucide-react into Header.tsx. Import ScrapeInput from '@/components/scraper/ScrapeInput'.
  </action>
  <verify>
    <automated>cd /c/Antigravity/Sandbox && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    TypeScript compiles cleanly. useJobProgress subscribes to Realtime and returns live progress. JobProgressSubscriber shows ScrapeProgressSteps and auto-navigates on complete. Project detail page shows JobProgressSubscriber for active scrapes. Header has Plus button that opens quick-add modal with project selector. /api/remix-engine/projects endpoint returns user's projects.
  </done>
</task>

</tasks>

<verification>
Run: npx tsc --noEmit — must pass with zero errors.
Run: npm run build 2>&1 | tail -20 — must succeed.
Check: src/hooks/useJobProgress.ts contains 'postgres_changes' Realtime subscription.
Check: src/components/scraper/JobProgressSubscriber.tsx contains router.push auto-navigation on complete status.
Check: src/components/scraper/ScrapeProgressSteps.tsx contains three steps: 'Downloading', 'Extracting transcript', 'Uploading to storage'.
Check: src/components/layout/Header.tsx contains quickAddOpen state and ScrapeInput import.
Check: src/app/api/remix-engine/scrape/[jobId]/cancel/route.ts exports POST function.
</verification>

<success_criteria>
- Supabase Realtime subscription fires on re_jobs UPDATE and updates progress live
- ScrapeProgressSteps shows three discrete steps that light up as progress milestones hit
- After status=complete, router.push navigates to video detail page (800ms delay)
- Header Plus button opens quick-add modal with project selector and ScrapeInput
- Project detail page shows JobProgressSubscriber cards for all active scrapes
- Cancel endpoint marks job as cancelled in DB
- npm run build succeeds with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-scraping-pipeline-4-hours/02-07-SUMMARY.md` following the summary template.
</output>

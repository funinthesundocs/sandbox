---
phase: 02-scraping-pipeline-4-hours
plan: 05
type: execute
wave: 3
depends_on:
  - "02-03"
  - "02-04"
files_modified:
  - src/app/(dashboard)/projects/[id]/videos/[videoId]/page.tsx
  - src/app/api/remix-engine/videos/[videoId]/route.ts
  - src/app/api/remix-engine/videos/[videoId]/transcript/route.ts
  - src/app/api/remix-engine/videos/[videoId]/signed-url/route.ts
  - src/components/scraper/VideoPlayer.tsx
  - src/components/scraper/TranscriptViewer.tsx
autonomous: true
requirements:
  - R2.5
  - R2.7

must_haves:
  truths:
    - "Video detail page shows YouTube embed player by default, falls back to Supabase signed URL player if embed fails"
    - "Metadata header bar shows: title, duration chip, view count, channel name, publish date, scrape date"
    - "TranscriptViewer shows timestamped segments in fixed-width gutter, clean selectable text in main column"
    - "Each transcript segment timestamp is clickable and seeks the embedded YouTube player to that time"
    - "Transcript segments are inline-editable — click text to edit in place, save on blur/Enter"
    - "PATCH /api/remix-engine/videos/[videoId]/transcript saves edited transcript segments to re_videos.original_transcript"
    - "GET /api/remix-engine/videos/[videoId]/signed-url returns 1-hour signed URL for video playback"
    - "Action buttons on detail page: Start Remix (stub), Re-scrape, Delete, Download Original"
  artifacts:
    - path: "src/app/(dashboard)/projects/[id]/videos/[videoId]/page.tsx"
      provides: "Video detail page — server component fetching video + transcript + signed URL"
    - path: "src/app/api/remix-engine/videos/[videoId]/route.ts"
      provides: "GET (video detail), DELETE (remove video + storage)"
    - path: "src/app/api/remix-engine/videos/[videoId]/transcript/route.ts"
      provides: "PATCH (save edited transcript segments)"
    - path: "src/app/api/remix-engine/videos/[videoId]/signed-url/route.ts"
      provides: "GET (1-hour signed URL for video_file_path)"
    - path: "src/components/scraper/VideoPlayer.tsx"
      provides: "YouTube embed player with seek capability + Supabase fallback"
    - path: "src/components/scraper/TranscriptViewer.tsx"
      provides: "Timestamped transcript with inline editing and player seek"
  key_links:
    - from: "src/components/scraper/TranscriptViewer.tsx"
      to: "src/app/api/remix-engine/videos/[videoId]/transcript/route.ts"
      via: "PATCH request on segment edit auto-save"
      pattern: "transcript"
    - from: "src/components/scraper/VideoPlayer.tsx"
      to: "src/app/api/remix-engine/videos/[videoId]/signed-url/route.ts"
      via: "Fetch signed URL as fallback when YouTube embed fails"
      pattern: "signed-url"
    - from: "src/app/(dashboard)/projects/[id]/videos/[videoId]/page.tsx"
      to: "src/components/scraper/VideoPlayer.tsx"
      via: "Pass youtubeId and videoId as props"
      pattern: "VideoPlayer"
    - from: "src/app/(dashboard)/projects/[id]/videos/[videoId]/page.tsx"
      to: "src/components/scraper/TranscriptViewer.tsx"
      via: "Pass transcript segments and videoId as props"
      pattern: "TranscriptViewer"
---

<objective>
Build the video detail page — the media-focused view users navigate to after a successful scrape. It features a large YouTube embed player, metadata header, and a scrollable transcript panel with clickable timestamps and inline editing.

Purpose: This is the core content consumption view. After scraping, users land here automatically (auto-navigate wired in Plan 07). The inline transcript editing is a locked UX decision.
Output: Video detail page, four API routes (video CRUD, transcript save, signed URL), VideoPlayer, TranscriptViewer.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-scraping-pipeline-4-hours/02-CONTEXT.md
@design-system/MASTER.md

LOCKED DECISIONS (from CONTEXT.md — implement EXACTLY):
- Media-focused detail page: large video player on top, transcript below in scrollable panel, metadata in header bar
- Video player: YouTube embed by default, fall back to downloaded copy from Supabase Storage (signed URL) if YouTube unavailable
- Action buttons: Start Remix, Re-scrape, Delete, Download Original
- Transcript presentation: timestamps in fixed-width gutter on left — never interfere with text selection
- Each segment displays timestamp (e.g., [0:42]), clickable to jump video player to that moment
- Transcript is editable at scrape stage: inline editing — click text to edit in place, auto-save

TRANSCRIPT DATA FORMAT (from Plan 01 output):
- Stored in Supabase Storage as transcript.json: array of { timestamp: string, startMs: number, text: string }
- Also stored as transcript.txt: plain text (for remix pipeline)
- original_transcript field in re_videos: plain text version
- For display: load from transcript_file_path (transcript.json) via signed URL OR from original_transcript field

SIGNED URL SPEC:
- Supabase Storage signed URLs: 1-hour expiry for video playback (security requirement from CLAUDE.md)
- Use supabaseAdmin.storage.from('remix-engine').createSignedUrl(path, 3600)

YOUTUBE EMBED SEEK:
- YouTube iframe player API allows seeking via postMessage
- Use YouTube IFrame API: player.seekTo(seconds, true)
- OR simpler: update the iframe src with &t={seconds} and reload
- Recommended: Use YouTube IFrame API (load via script tag, create YT.Player instance with onReady callback)

CLAUDE'S DISCRETION:
- Loading skeleton for video player
- Transcript segment granularity display
- Auto-save debounce timing (recommend 1 second)
- Exact layout proportions (player height, transcript panel height)
</context>

<tasks>

<task type="auto">
  <name>Task 1: API routes for video detail, transcript save, and signed URL</name>
  <files>
    src/app/api/remix-engine/videos/[videoId]/route.ts
    src/app/api/remix-engine/videos/[videoId]/transcript/route.ts
    src/app/api/remix-engine/videos/[videoId]/signed-url/route.ts
  </files>
  <action>
All routes are Next.js API routes using @/ imports. All require auth. Use supabaseAdmin from '@/lib/supabase/admin' for writes. Use server supabase client for reads (RLS enforcement).

**src/app/api/remix-engine/videos/[videoId]/route.ts**

GET handler:
1. Auth check
2. const { videoId } = await params
3. Fetch from re_videos: all columns
4. Return NextResponse.json({ video })

DELETE handler:
1. Auth check (require editor or admin role — check re_users.role)
2. Fetch video to get file paths
3. Delete from Supabase Storage: video_file_path, thumbnail_file_path, transcript_file_path (all three, even if null — guard with if check)
   ```typescript
   const paths = [video.video_file_path, video.thumbnail_file_path, video.transcript_file_path]
     .filter(Boolean) as string[];
   if (paths.length > 0) {
     await supabaseAdmin.storage.from('remix-engine').remove(paths);
   }
   ```
4. Delete from re_videos (CASCADE deletes re_jobs, re_scenes related to this video)
5. Return NextResponse.json({ success: true })

**src/app/api/remix-engine/videos/[videoId]/transcript/route.ts**

PATCH handler — save edited transcript:
1. Auth check
2. const { videoId } = await params
3. Body: { segments: Array<{ timestamp: string; startMs: number; text: string }> }
4. Validate: segments must be array, max 1000 items
5. Build transcriptText = segments.map(s => s.text).join(' ')
6. Upload updated transcript.json to Supabase Storage (upsert: true):
   ```typescript
   const transcriptPath = storagePath('videos', video.project_id, videoId, 'transcript.json');
   await supabaseAdmin.storage.from('remix-engine').upload(
     transcriptPath,
     Buffer.from(JSON.stringify(segments)),
     { contentType: 'application/json', upsert: true }
   );
   ```
7. Update re_videos.original_transcript with new plain text
8. Return NextResponse.json({ success: true })

Need to fetch project_id from re_videos first to construct the storage path. Use supabaseAdmin.from('re_videos').select('project_id').eq('id', videoId).single().

**src/app/api/remix-engine/videos/[videoId]/signed-url/route.ts**

GET handler — generate signed URL for video playback:
1. Auth check
2. const { videoId } = await params
3. Fetch re_videos to get video_file_path
4. If !video_file_path: return 404 { error: 'Video not yet downloaded' }
5. const { data, error } = await supabaseAdmin.storage
     .from('remix-engine')
     .createSignedUrl(video.video_file_path, 3600) // 1 hour
6. If error: return 500
7. Return NextResponse.json({ signedUrl: data.signedUrl, expiresIn: 3600 })
  </action>
  <verify>
    <automated>cd /c/Antigravity/Sandbox && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    TypeScript compiles cleanly. GET /videos/[videoId] returns video data. DELETE removes storage files then DB record. PATCH /transcript saves edited segments to storage and DB. GET /signed-url returns signed URL with 3600 expiry.
  </done>
</task>

<task type="auto">
  <name>Task 2: VideoPlayer, TranscriptViewer, and video detail page</name>
  <files>
    src/components/scraper/VideoPlayer.tsx
    src/components/scraper/TranscriptViewer.tsx
    src/app/(dashboard)/projects/[id]/videos/[videoId]/page.tsx
  </files>
  <action>
**src/components/scraper/VideoPlayer.tsx** — 'use client'. YouTube embed with seek capability and Supabase fallback.

Props:
```typescript
interface VideoPlayerProps {
  youtubeId: string;
  videoId: string;         // DB video ID — for fetching signed URL fallback
  className?: string;
}

// Expose seekTo method to parent via ref
export interface VideoPlayerRef {
  seekTo: (seconds: number) => void;
}
```

Use forwardRef pattern — NO wait. CLAUDE.md says React 19, no forwardRef. Instead, expose seekTo via a callback prop:

```typescript
interface VideoPlayerProps {
  youtubeId: string;
  videoId: string;
  onPlayerReady?: (seekTo: (seconds: number) => void) => void;
  className?: string;
}
```

Implementation approach — YouTube IFrame API:
1. Load YouTube IFrame API via script tag (check if already loaded: window.YT)
2. Create YT.Player instance in the div container
3. In onReady callback: call onPlayerReady?.((s) => player.seekTo(s, true))
4. Handle onError: if error code 100/101/150 (video unavailable/private/embed disabled): fetch signed URL and switch to <video> element

```typescript
const [useFallback, setUseFallback] = useState(false);
const [signedUrl, setSignedUrl] = useState<string | null>(null);
const playerDivRef = useRef<HTMLDivElement>(null);
const playerRef = useRef<any>(null);

useEffect(() => {
  // Load YT IFrame API
  if (!window.YT) {
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    document.head.appendChild(tag);
  }
  // Wait for API ready
  const onReady = () => {
    playerRef.current = new window.YT.Player(playerDivRef.current, {
      videoId: youtubeId,
      playerVars: { rel: 0, modestbranding: 1 },
      events: {
        onReady: (e: any) => {
          onPlayerReady?.((s: number) => e.target.seekTo(s, true));
        },
        onError: () => setUseFallback(true),
      },
    });
  };
  if (window.YT?.Player) onReady();
  else (window as any).onYouTubeIframeAPIReady = onReady;
  // No cleanup needed — player persists until component unmounts
  return () => { playerRef.current?.destroy?.(); };
}, [youtubeId]);

// Fetch signed URL when switching to fallback
useEffect(() => {
  if (!useFallback) return;
  fetch(`/api/remix-engine/videos/${videoId}/signed-url`)
    .then(r => r.json())
    .then(d => setSignedUrl(d.signedUrl))
    .catch(() => {});
}, [useFallback, videoId]);
```

UI:
```jsx
<div className={`relative aspect-video bg-[--re-bg-secondary] rounded-[--re-border-radius] overflow-hidden ${className}`}>
  {!useFallback && <div ref={playerDivRef} className="w-full h-full" />}
  {useFallback && signedUrl && (
    <video src={signedUrl} controls className="w-full h-full" />
  )}
  {useFallback && !signedUrl && (
    <div className="w-full h-full flex items-center justify-center">
      <Loader2 className="w-8 h-8 animate-spin text-[--re-text-muted]" />
    </div>
  )}
</div>
```

Declare window.YT as `any` to avoid TypeScript errors with the YouTube API.

**src/components/scraper/TranscriptViewer.tsx** — 'use client'. Timestamped transcript with inline editing.

Props:
```typescript
interface TranscriptViewerProps {
  segments: Array<{ timestamp: string; startMs: number; text: string }>;
  videoId: string;
  onSeek?: (seconds: number) => void;  // Called when timestamp clicked
}
```

State:
- `editingIndex: number | null` — which segment is being edited
- `localSegments: typeof segments` — local copy for optimistic edit
- `saveStatus: 'idle' | 'saving' | 'saved' | 'error'`

Auto-save debounce: use useRef for timeout, on segment text change → clearTimeout, setTimeout(1000, saveFn).

**Save function** (debounced):
```typescript
const saveTranscript = async (segments: typeof localSegments) => {
  setSaveStatus('saving');
  try {
    await fetch(`/api/remix-engine/videos/${videoId}/transcript`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ segments }),
    });
    setSaveStatus('saved');
    setTimeout(() => setSaveStatus('idle'), 2000);
  } catch {
    setSaveStatus('error');
  }
};
```

**Timestamp gutter + text layout** — fixed-width gutter on left, text column on right. CRITICAL: timestamps must NEVER interfere with text selection.

```jsx
<div className="h-96 overflow-y-auto rounded-[--re-border-radius] bg-[--re-bg-secondary]/60 backdrop-blur-md border border-[--re-border]/60">
  {/* Save status indicator */}
  <div className="sticky top-0 flex items-center justify-between px-4 py-2 bg-[--re-bg-secondary] border-b border-[--re-border-subtle] text-xs text-[--re-text-muted]">
    <span>Transcript</span>
    {saveStatus === 'saving' && <span className="text-[--re-text-muted]">Saving...</span>}
    {saveStatus === 'saved' && <span className="text-[--re-success]">Saved</span>}
    {saveStatus === 'error' && <span className="text-[--re-destructive]">Save failed</span>}
  </div>
  {localSegments.length === 0 && (
    <div className="p-6 text-center text-[--re-text-muted] text-sm">
      No transcript available for this video.
    </div>
  )}
  {localSegments.map((seg, i) => (
    <div key={i} className="flex gap-0 hover:bg-[--re-bg-hover]/50 transition-colors">
      {/* GUTTER: fixed 64px, click to seek */}
      <button
        onClick={() => onSeek?.(seg.startMs / 1000)}
        className="flex-shrink-0 w-16 px-3 py-2 text-xs text-[--re-accent-primary] hover:text-[--re-accent-secondary] font-mono text-right self-start pt-2.5 cursor-pointer"
        title={`Jump to ${seg.timestamp}`}
      >
        {seg.timestamp}
      </button>
      {/* TEXT: editable, full width, clean selection */}
      <div className="flex-1 py-2 pr-4">
        {editingIndex === i ? (
          <textarea
            autoFocus
            value={localSegments[i].text}
            onChange={e => {
              const updated = [...localSegments];
              updated[i] = { ...updated[i], text: e.target.value };
              setLocalSegments(updated);
              // debounce save
              clearTimeout(saveTimerRef.current);
              saveTimerRef.current = setTimeout(() => saveTranscript(updated), 1000);
            }}
            onBlur={() => setEditingIndex(null)}
            onKeyDown={e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); setEditingIndex(null); } }}
            className="w-full bg-[--re-bg-input] text-[--re-text-primary] text-sm rounded px-2 py-1 resize-none outline-none focus:ring-1 focus:ring-[--re-accent-primary]/50"
            rows={Math.max(1, Math.ceil(localSegments[i].text.length / 80))}
          />
        ) : (
          <p
            onClick={() => setEditingIndex(i)}
            className="text-[--re-text-secondary] text-sm leading-relaxed cursor-text select-text"
            title="Click to edit"
          >
            {seg.text}
          </p>
        )}
      </div>
    </div>
  ))}
</div>
```

useRef for save timer: `const saveTimerRef = useRef<ReturnType<typeof setTimeout>>(null)`.

**src/app/(dashboard)/projects/[id]/videos/[videoId]/page.tsx** — Server component. Media-focused detail page.

```typescript
export default async function VideoDetailPage({
  params,
}: {
  params: Promise<{ id: string; videoId: string }>;
}) {
  const { id: projectId, videoId } = await params;
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) redirect('/login');

  const { data: video } = await supabase
    .from('re_videos')
    .select('*')
    .eq('id', videoId)
    .eq('project_id', projectId)
    .single();
  if (!video) notFound();

  // Load transcript segments from storage (if available)
  let transcriptSegments: Array<{ timestamp: string; startMs: number; text: string }> = [];
  if (video.transcript_file_path) {
    const { data: signedData } = await supabaseAdmin.storage
      .from('remix-engine')
      .createSignedUrl(video.transcript_file_path, 300); // 5 min for SSR
    if (signedData?.signedUrl) {
      try {
        const res = await fetch(signedData.signedUrl);
        transcriptSegments = await res.json();
      } catch { /* if fetch fails, show empty transcript */ }
    }
  }

  return (
    <div>
      {/* Back link */}
      <Link href={`/dashboard/projects/${projectId}`} className="text-[--re-text-muted] text-sm hover:text-[--re-text-primary] flex items-center gap-1 mb-4">
        <ChevronLeft className="w-4 h-4" /> Back to project
      </Link>

      {/* Title + action buttons row */}
      <div className="flex items-start justify-between gap-4 mb-4">
        <div>
          <h1 className="text-xl font-semibold text-[--re-text-primary] leading-snug">
            {video.original_title || 'Untitled Video'}
          </h1>
          {/* Metadata chips */}
          <div className="flex items-center gap-3 mt-2 flex-wrap">
            {video.duration_seconds && (
              <span className="text-xs px-2 py-0.5 rounded bg-[--re-bg-hover] text-[--re-text-secondary] font-mono">
                {formatDuration(video.duration_seconds)}
              </span>
            )}
            {video.channel_name && (
              <span className="text-xs text-[--re-text-muted]">{video.channel_name}</span>
            )}
            {video.view_count && (
              <span className="text-xs text-[--re-text-muted]">{formatViewCount(video.view_count)}</span>
            )}
            {video.published_at && (
              <span className="text-xs text-[--re-text-muted]">
                Published {new Date(video.published_at).toLocaleDateString()}
              </span>
            )}
          </div>
        </div>
        {/* Action buttons */}
        <div className="flex gap-2 flex-shrink-0">
          <Button variant="default" size="sm" disabled>
            <Wand2 className="w-4 h-4 mr-1" /> Start Remix
          </Button>
          <Button variant="outline" size="sm">
            <RefreshCw className="w-4 h-4 mr-1" /> Re-scrape
          </Button>
          <Button variant="outline" size="sm" asChild>
            <a href={`/api/remix-engine/videos/${videoId}/signed-url`} download>
              <Download className="w-4 h-4" />
            </a>
          </Button>
          <Button variant="ghost" size="sm" className="text-[--re-destructive] hover:text-[--re-destructive]">
            <Trash2 className="w-4 h-4" />
          </Button>
        </div>
      </div>

      {/* Two-column layout: player (left/top) + transcript (right/bottom) */}
      <div className="grid grid-cols-1 lg:grid-cols-5 gap-6">
        {/* Video player — 3/5 width on large screens */}
        <div className="lg:col-span-3">
          <VideoPlayerWrapper youtubeId={video.youtube_id} videoId={videoId} transcriptSegments={transcriptSegments} />
        </div>
        {/* Transcript — 2/5 width */}
        <div className="lg:col-span-2">
          <TranscriptViewer segments={transcriptSegments} videoId={videoId} />
        </div>
      </div>
    </div>
  );
}
```

Create a thin client wrapper `VideoPlayerWrapper` component in the same file or a separate client component to bridge the player + transcript seek:

```typescript
// In the same file or a small client wrapper
'use client';
function VideoPlayerWrapper({ youtubeId, videoId, transcriptSegments }: ...) {
  const [seekTo, setSeekTo] = useState<((s: number) => void) | null>(null);
  return (
    <>
      <VideoPlayer youtubeId={youtubeId} videoId={videoId} onPlayerReady={setSeekTo} />
      <TranscriptViewer segments={transcriptSegments} videoId={videoId} onSeek={seekTo ?? undefined} />
    </>
  );
}
```

Wait — this layout would put transcript inside the wrapper. Adjust: VideoPlayerWrapper wraps the 5-column grid layout with shared seekTo state, since both VideoPlayer and TranscriptViewer need it. Create `src/components/scraper/VideoDetailLayout.tsx` as a 'use client' component that manages seekTo state and renders both VideoPlayer + TranscriptViewer. The page.tsx passes the data as props to VideoDetailLayout.

Create `src/components/scraper/VideoDetailLayout.tsx`:
- 'use client'
- Props: { youtubeId, videoId, transcriptSegments }
- State: seekTo function
- Renders: VideoPlayer (with onPlayerReady) + TranscriptViewer (with onSeek) in the grid layout

Update the page.tsx to use VideoDetailLayout instead of the separate grid.

Import: ChevronLeft, Wand2, RefreshCw, Download, Trash2 from lucide-react. Import supabaseAdmin from '@/lib/supabase/admin'. Import Link from 'next/link'.

Add formatDuration and formatViewCount as module-level helpers in the page file (same implementations as VideoCard).
  </action>
  <verify>
    <automated>cd /c/Antigravity/Sandbox && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    TypeScript compiles cleanly. Video detail page server component fetches video + transcript. VideoPlayer renders YouTube iframe with IFrame API. TranscriptViewer shows timestamps in gutter, editable text in main column. Timestamp click calls onSeek which calls player.seekTo(). PATCH /transcript route saves updated segments. GET /signed-url returns 1-hour signed URL. All colors use --re-* variables.
  </done>
</task>

</tasks>

<verification>
Run: npx tsc --noEmit — must pass with zero errors.
Check: src/components/scraper/TranscriptViewer.tsx contains "w-16" (fixed gutter) and "select-text" on text.
Check: src/components/scraper/VideoPlayer.tsx contains "onYouTubeIframeAPIReady".
Check: PATCH handler in transcript/route.ts calls storagePath() for the upload path.
Check: GET signed-url handler uses createSignedUrl with 3600 expiry.
</verification>

<success_criteria>
- Video detail page shows player (top) and transcript (right/below) in responsive grid
- YouTube IFrame API loaded and player.seekTo() called when transcript timestamp clicked
- Supabase signed URL fallback when YouTube embed fails
- Transcript timestamps in separate 64px gutter column — zero interference with text selection
- Click-to-edit inline editing with 1-second auto-save debounce
- PATCH /transcript saves full segments array to storage + plain text to DB
- Action buttons: Start Remix (disabled stub), Re-scrape, Download, Delete visible
- 1-hour signed URL returned from /signed-url route
</success_criteria>

<output>
After completion, create `.planning/phases/02-scraping-pipeline-4-hours/02-05-SUMMARY.md` following the summary template.
</output>
